import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BowlCylinderTower(Task):
    """Stack differently colored cylinders into a vertically ordered tower inside a bowl."""

    def __init__(self):
        super().__init__()
        self.max_steps = 4  # We expect to stack two cylinders, so we set max_steps to twice that number
        self.ee = Suction  # We use Suction end-effector to pick and place cylinders
        self.lang_template = "stack a {color} cylinder on top of the {base_color} one in the bowl"
        self.task_completed_desc = "done stacking the cylinder tower."

    def reset(self, env):
        super().reset(env)

        # Define the number of cylinders to stack
        n_cylinders = 2

        # Define the size of the bowl and cylinders
        bowl_size = (0.18, 0.18, 0.06)  # (x, y, z) dimensions
        cylinder_size = (0.05, 0.05, 0.15)  # (x, y, z) dimensions

        # Add the bowl to the environment
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_pose = self.get_random_pose(env, bowl_size)
        env.add_object(bowl_urdf, bowl_pose, 'fixed')

        # Initialize list to store cylinder IDs and target poses
        cylinders = []
        targ_poses = []

        # Define colors for the cylinders
        colors = ['red', 'blue']  # We will use red and blue cylinders

        # Add cylinders to the environment
        cylinder_template = 'cylinder/cylinder-template.urdf'
        for i in range(n_cylinders):
            # Get a random pose for the cylinder
            pose = self.get_random_pose(env, cylinder_size)
            # Define the color of the cylinder
            color = utils.COLORS[colors[i]]
            # Fill the URDF template with the cylinder's properties
            replace = {'SIZE': cylinder_size, 'COLOR': color}
            urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder to the environment and store its ID
            cylinder_id = env.add_object(urdf, pose)
            cylinders.append(cylinder_id)
            # Store the target pose for the cylinder (inside the bowl)
            targ_pose = (bowl_pose[0], (0, 0, 0, 1))  # We only care about the position, not the orientation
            targ_poses.append(targ_pose)

        # Add goals for stacking the cylinders
        for i in range(n_cylinders):
            # Define the language goal for the current step
            if i == 0:
                base_color = 'none'  # There is no cylinder below the first one
            else:
                base_color = colors[i-1]
            language_goal = self.lang_template.format(color=colors[i], base_color=base_color)
            # Add the goal for the current cylinder
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[targ_poses[i]],
                          replace=False, rotations=True, metric='pose', params=None,
                          step_max_reward=1/n_cylinders, language_goal=language_goal)

# Instantiate the task
task = BowlCylinderTower()