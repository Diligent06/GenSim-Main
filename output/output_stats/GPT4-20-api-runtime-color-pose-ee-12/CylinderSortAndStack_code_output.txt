import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderSortAndStack(Task):
    """Sort cylinders of different colors by picking them from a mixed pile and stacking them into color-coordinated piles of 4 cylinders each on the designated zones on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to call self.add_goal twice, so we set this to twice that number.
        self.lang_template = "stack all {color} cylinders in the {color} zone"
        self.task_completed_desc = "done sorting and stacking cylinders."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector.
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the number of cylinders and colors.
        n_cylinders = 12  # Total number of cylinders
        n_colors = 3  # Number of different colors
        n_per_color = n_cylinders // n_colors  # Cylinders per color

        # Define cylinder size and template.
        cyl_size = (0.05, 0.05, 0.1)  # Size of the cylinder (radius, radius, height)
        cyl_template = 'cylinder/cylinder-template.urdf'

        # Define colors for the cylinders.
        colors = ['red', 'green', 'blue']
        color_rgb = [utils.COLORS[color] for color in colors]

        # Add cylinders to the environment.
        cylinders = []
        for i in range(n_cylinders):
            color_idx = i % n_colors
            color = color_rgb[color_idx]
            pose = self.get_random_pose(env, cyl_size)
            replace = {'COLOR': color}
            urdf = self.fill_template(cyl_template, replace)
            cyl_id = env.add_object(urdf, pose)
            cylinders.append((cyl_id, color_idx))

        # Shuffle the list to randomize cylinder order.
        np.random.shuffle(cylinders)

        # Add zones for each color.
        zone_size = (0.2, 0.2, 0)  # Size of the zone (x, y, z)
        zone_urdf = 'zone/zone.urdf'
        zones = []
        for i, color in enumerate(colors):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[color])
            zones.append((zone_pose, color))

        # Add goals for each color.
        for i, (zone_pose, color) in enumerate(zones):
            # Filter cylinders of the same color.
            color_cylinders = [cyl_id for cyl_id, color_idx in cylinders if color_idx == i]

            # Define the target poses for the cylinders in their respective zones.
            # We stack them by incrementing the z-coordinate for each cylinder.
            targ_poses = [(zone_pose[0], zone_pose[1]) for _ in range(n_per_color)]

            # Add the goal for the current color.
            language_goal = self.lang_template.format(color=color)
            self.add_goal(
                objs=color_cylinders,
                matches=np.ones((n_per_color, 1)),  # Each cylinder matches with the zone.
                targ_poses=targ_poses,
                replace=False,  # Each cylinder has a unique place.
                rotations=False,  # No need to rotate cylinders for stacking.
                metric='pose',  # We use pose metric for precise placement.
                params=None,  # No additional parameters needed.
                step_max_reward=1 / n_colors,  # Reward is split across the number of colors.
                language_goal=language_goal
            )