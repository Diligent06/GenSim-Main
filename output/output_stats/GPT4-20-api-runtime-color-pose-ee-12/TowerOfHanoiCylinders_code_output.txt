import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class TowerOfHanoiCylinders(Task):
    """
    Transfer a pyramid of three differently-sized, colored cylinders from the initial zone to a target zone,
    by moving only one cylinder at a time and never placing a larger cylinder on top of a smaller one.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We have three cylinders to move, and we might move each twice.
        self.lang_template = "move the {color} cylinder to the {target_zone} zone"
        self.task_completed_desc = "done transferring the Tower of Hanoi."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector.

    def reset(self, env):
        super().reset(env)

        # Define the sizes for the three cylinders (small, medium, large)
        sizes = [(0.04, 0.04, 0.12), (0.06, 0.06, 0.18), (0.08, 0.08, 0.24)]
        colors = ['red', 'green', 'blue']  # Define the colors for the three cylinders

        # Add initial zone where the cylinders will be stacked
        init_zone_size = (0.15, 0.15, 0)
        init_zone_pose = self.get_random_pose(env, init_zone_size)
        env.add_object('zone/zone.urdf', init_zone_pose, 'fixed')

        # Add target zone where the cylinders need to be moved
        target_zone_size = (0.15, 0.15, 0)
        target_zone_pose = self.get_random_pose(env, target_zone_size)
        env.add_object('zone/zone.urdf', target_zone_pose, 'fixed')

        # Add cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []
        for i, size in enumerate(sizes):
            # Generate a random pose for the cylinder
            pose = self.get_random_pose(env, size)
            # Set the pose's z-coordinate to stack the cylinders on top of each other
            pose[0][2] += i * size[2]
            # Fill in the cylinder URDF template with size and color
            replace = {'SIZE': size, 'COLOR': utils.COLORS[colors[i]]}
            urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder object to the environment
            env.add_object(urdf, pose, 'rigid')
            cylinder_poses.append(pose)

        # Add goals for each cylinder to be moved to the target zone
        for i, (color, pose) in enumerate(zip(colors, cylinder_poses)):
            language_goal = self.lang_template.format(color=color, target_zone="target")
            # The target pose is the same x, y as the target zone but with the appropriate z for the cylinder size
            target_pose = [(target_zone_pose[0][0], target_zone_pose[0][1], target_zone_pose[0][2] + i * sizes[i][2]), target_zone_pose[1]]
            # Add the goal with a maximum reward of 1 since we have only one goal
            self.add_goal(objs=[i], matches=np.int32([[1]]), targ_poses=[target_pose], replace=True,
                          rotations=True, metric='pose', params=None, step_max_reward=1,
                          language_goal=language_goal)

# Note: The actual logic for ensuring that a larger cylinder is not placed on a smaller one
# and that only one cylinder is moved at a time would need to be handled in the reward function
# and potentially in custom environment stepping logic, which is not shown here.