import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class GradientTowerCreation(Task):
    """Build a gradient tower by stacking a green, a red, and a blue cylinder on a black pallet base in ascending size order, with the smallest on top."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice that number
        self.lang_template = "stack the {color} cylinder on the {base}"
        self.task_completed_desc = "done creating gradient tower."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector

    def reset(self, env):
        super().reset(env)

        # Define the colors for the cylinders
        colors = {
            'green': utils.COLORS['green'],
            'red': utils.COLORS['red'],
            'blue': utils.COLORS['blue'],
            'black': utils.COLORS['black']
        }

        # Define the sizes for the cylinders (diameter, height)
        sizes = {
            'small': (0.04, 0.08),  # Smallest cylinder
            'medium': (0.06, 0.08),  # Medium cylinder
            'large': (0.08, 0.08)   # Largest cylinder
        }

        # Add the black pallet base
        base_size = (0.15, 0.15, 0.02)  # Size of the pallet base
        base_pose = self.get_random_pose(env, base_size)
        base_template = 'pallet/pallet.urdf'
        base_urdf = self.fill_template(base_template, {'COLOR': colors['black']})
        env.add_object(base_urdf, base_pose, 'fixed')

        # Add cylinders in descending size order
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []
        cylinder_sizes = ['large', 'medium', 'small']
        cylinder_colors = ['green', 'red', 'blue']
        for size, color in zip(cylinder_sizes, cylinder_colors):
            # Generate a random pose for the cylinder
            cylinder_pose = self.get_random_pose(env, sizes[size])
            # Fill in the template URDF with the size and color of the cylinder
            replace = {'SIZE': sizes[size], 'COLOR': colors[color]}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            cylinder_poses.append((cylinder_pose, cylinder_id))

        # Define the target poses for the cylinders on the pallet
        # The target poses are offset from the base pose by the cylinder's height
        z_offset = base_size[2]
        target_poses = []
        for size in cylinder_sizes:
            z_offset += sizes[size][1]  # Add the height of the cylinder to the z-offset
            target_pose = (base_pose[0], (0, 0, z_offset))
            target_poses.append(target_pose)

        # Add goals for each cylinder
        for i, (cylinder_pose, cylinder_id) in enumerate(cylinder_poses):
            # The language goal describes the action to be performed
            language_goal = self.lang_template.format(color=cylinder_colors[i], base='black pallet')
            # Add the goal for the current cylinder
            self.add_goal(
                objs=[cylinder_id],
                matches=np.ones((1, 1)),  # Each cylinder has a unique target pose
                targ_poses=[target_poses[i]],  # The target pose for the cylinder
                replace=False,  # The target pose is not shared with other objects
                rotations=True,  # The cylinder can be rotated
                metric='pose',  # The goal is evaluated based on the pose of the cylinder
                params=None,  # No additional parameters
                step_max_reward=1,  # Full reward for completing this step
                language_goal=language_goal  # The language goal
            )