import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class SortAndStack(Task):
    """
    Sort and stack three colored balls into three separate bowls based on color matching,
    then carefully balance a cylinder on top of the balls in each bowl without knocking them over.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 8  # We have 4 goals, so max_steps is twice that number
        self.ee = Suction  # Using Suction end-effector to pick and place balls and cylinders
        self.lang_template = "put the {color} ball in the {color} bowl and balance the cylinder on top"
        self.task_completed_desc = "done sorting and stacking."

    def reset(self, env):
        super().reset(env)

        # Define colors for the balls and bowls
        ball_colors = ['red', 'green', 'blue']
        bowl_colors = ball_colors  # Matching colors for balls and bowls

        # Define sizes for the balls and bowls
        ball_size = (0.04, 0.04, 0.04)  # (x, y, z) dimensions
        bowl_size = (0.12, 0.12, 0.06)  # (x, y, z) dimensions
        cylinder_size = (0.02, 0.02, 0.1)  # (x, y, z) dimensions

        # Add bowls to the environment
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for color in bowl_colors:
            bowl_pose = self.get_random_pose(env, bowl_size)
            env.add_object(bowl_urdf, bowl_pose, 'fixed', color=utils.COLORS[color])
            bowl_poses.append(bowl_pose)

        # Add balls to the environment
        ball_urdf = 'ball/ball-template.urdf'
        balls = []
        for color in ball_colors:
            ball_pose = self.get_random_pose(env, ball_size)
            replace = {'COLOR': utils.COLORS[color]}
            ball_urdf_filled = self.fill_template(ball_urdf, replace)
            ball_id = env.add_object(ball_urdf_filled, ball_pose)
            balls.append(ball_id)

        # Add cylinders to the environment
        cylinder_urdf = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for color in ball_colors:
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            replace = {'COLOR': utils.COLORS[color]}
            cylinder_urdf_filled = self.fill_template(cylinder_urdf, replace)
            cylinder_id = env.add_object(cylinder_urdf_filled, cylinder_pose)
            cylinders.append(cylinder_id)

        # Define goals for sorting and stacking balls into bowls
        for i, color in enumerate(ball_colors):
            # Goal: ball is in the matching bowl
            language_goal = self.lang_template.format(color=color)
            self.add_goal(objs=[balls[i]], matches=np.ones((1, 1)), targ_poses=[bowl_poses[i]],
                          replace=False, rotations=True, metric='pose', params=None,
                          step_max_reward=1 / 4, language_goal=language_goal)

        # Define goals for balancing cylinders on top of the balls
        for i, color in enumerate(ball_colors):
            # Calculate the target pose for the cylinder to be on top of the ball
            # Assuming the ball is at the center of the bowl and the cylinder is balanced on the ball
            x, y, z = bowl_poses[i][0]
            z += bowl_size[2] / 2 + ball_size[2] + cylinder_size[2] / 2  # Adjust z for stacking
            cylinder_target_pose = [(x, y, z), (0, 0, 0, 1)]  # No rotation for the cylinder

            # Goal: cylinder is balanced on the ball in the bowl
            language_goal = self.lang_template.format(color=color)
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[cylinder_target_pose],
                          replace=False, rotations=False, metric='pose', params=None,
                          step_max_reward=1 / 4, language_goal=language_goal)