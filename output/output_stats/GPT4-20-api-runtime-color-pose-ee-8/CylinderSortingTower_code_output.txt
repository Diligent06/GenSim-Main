import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderSortingTower(Task):
    """Construct a color-sorted tower by stacking cylinders of various sizes and colors on top of each other on the pallet, ensuring the smallest and lightest cylinder is at the top."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to call self.add_goal 5 times, so we set max_steps to twice that number
        self.lang_template = "stack the {color} cylinder on the {target_color} one"
        self.task_completed_desc = "done constructing the cylinder tower."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the number of cylinders and their sizes
        n_cylinders = 5
        cylinder_sizes = [(0.04, 0.04, 0.08),  # Smallest cylinder
                          (0.05, 0.05, 0.1),
                          (0.06, 0.06, 0.12),
                          (0.07, 0.07, 0.14),
                          (0.08, 0.08, 0.16)]  # Largest cylinder

        # Define the colors for the cylinders
        cylinder_colors = ['red', 'green', 'blue', 'yellow', 'purple']
        color_rgb = [utils.COLORS[color] for color in cylinder_colors]

        # Add pallet
        pallet_size = (0.3, 0.3, 0.02)  # Size of the pallet
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Add cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for i in range(n_cylinders):
            size = cylinder_sizes[i]
            color = color_rgb[i]
            pose = self.get_random_pose(env, size)
            replace = {'SIZE': size, 'COLOR': color}
            urdf = self.fill_template(cylinder_template, replace)
            cylinder_id = env.add_object(urdf, pose)
            cylinders.append((cylinder_id, pose))

        # Sort cylinders by size to ensure the smallest is on top when stacked
        cylinders.sort(key=lambda x: x[1][0][2], reverse=True)

        # Add goals for stacking cylinders in order of size
        for i in range(1, n_cylinders):
            # The target pose for the current cylinder is on top of the previous one
            below_cylinder_pose = cylinders[i-1][1]
            current_cylinder_pose = cylinders[i][1]
            target_pose = (below_cylinder_pose[0], below_cylinder_pose[1])

            # Increment z-coordinate for the target pose by the height of the below cylinder plus a small offset
            target_pose[0][2] += cylinder_sizes[i-1][2] + 0.005

            # Create language goal
            language_goal = self.lang_template.format(color=cylinder_colors[i], target_color=cylinder_colors[i-1])

            # Add goal for the current cylinder
            self.add_goal(objs=[cylinders[i][0]], matches=np.ones((1, 1)), targ_poses=[target_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/n_cylinders,
                          language_goal=language_goal)

        # The last goal is to place the smallest cylinder on top of the second smallest
        language_goal = self.lang_template.format(color=cylinder_colors[0], target_color=cylinder_colors[1])
        self.add_goal(objs=[cylinders[0][0]], matches=np.ones((1, 1)), targ_poses=[target_pose], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1/n_cylinders,
                      language_goal=language_goal)