import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BowlPyramidPrecision(Task):
    """Stack three differently sized bowls into a descending size order pyramid."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice that number
        self.lang_template = "stack the {size} bowl on top of the {placement}"
        self.task_completed_desc = "done stacking the bowl pyramid."
        self.ee = Suction  # Use Suction end-effector to move bowls on the Z axis
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define bowl sizes and colors
        bowl_sizes = [(0.12, 0.12, 0.06), (0.10, 0.10, 0.05), (0.08, 0.08, 0.04)]
        bowl_colors = ['blue', 'green', 'red']
        bowl_urdf = 'bowl/bowl.urdf'

        # Add pallet as a base for the pyramid
        pallet_size = (0.3, 0.3, 0.02)
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object('pallet/pallet.urdf', pallet_pose, 'fixed')

        # Add bowls and store their initial poses for goal setting
        bowls = []
        for i, size in enumerate(bowl_sizes):
            color = utils.COLORS[bowl_colors[i]]
            pose = self.get_random_pose(env, size)
            bowl_id = env.add_object(bowl_urdf, pose, color=color)
            bowls.append((bowl_id, pose))

        # Define target poses for the bowls on the pallet
        # The target poses are offset on the z-axis based on the bowl heights
        targ_poses = [
            (pallet_pose[0], pallet_pose[1]),  # Bottom bowl
            utils.apply(pallet_pose, (0, 0, bowl_sizes[0][2])),  # Middle bowl
            utils.apply(pallet_pose, (0, 0, bowl_sizes[0][2] + bowl_sizes[1][2]))  # Top bowl
        ]

        # Add goals for stacking the bowls in descending size order
        for i in range(3):
            # Language goal describes the action to be performed
            if i == 0:
                placement = "the pallet"
            else:
                placement = f"the {bowl_colors[i-1]} bowl"
            language_goal = self.lang_template.format(size=bowl_colors[i], placement=placement)

            # Add the goal with the corresponding target pose
            self.add_goal(
                objs=[bowls[i][0]],  # Object ID
                matches=np.ones((1, 1)),  # Single object to single target
                targ_poses=[targ_poses[i]],  # Target pose
                replace=False,  # Unique matching
                rotations=True,  # Consider rotations
                metric='pose',  # Use pose matching
                params=None,  # No additional parameters
                step_max_reward=1 / 3,  # Equal reward for each step
                language_goal=language_goal  # Language goal
            )