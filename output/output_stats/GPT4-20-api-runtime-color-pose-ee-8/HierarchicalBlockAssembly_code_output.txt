import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class HierarchicalBlockAssembly(Task):
    """
    Construct a hierarchical structure by placing colored blocks within their matching colored bowls,
    then stacking those bowls on top of a large box, ensuring that the colors follow a specified sequence.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Set to twice the number of add_goal calls expected (5 goals)
        self.lang_template = "place the {color} block in the {color} bowl, then stack the bowls on the box in sequence"
        self.task_completed_desc = "completed hierarchical block assembly."
        self.ee = Suction  # Use suction end-effector to pick and place objects in 3D space

    def reset(self, env):
        super().reset(env)

        # Define the sequence of colors for the blocks and bowls
        color_sequence = ['red', 'green', 'blue', 'yellow', 'purple']
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks
        bowl_size = (0.12, 0.12, 0.06)   # Size of the bowls
        box_size = (0.3, 0.3, 0.15)      # Size of the large box

        # Add a large box to the environment
        box_pose = self.get_random_pose(env, box_size)
        box_template = 'box/box-template.urdf'
        replace = {'DIM': box_size, 'HALF': (box_size[0] / 2, box_size[1] / 2, box_size[2] / 2)}
        box_urdf = self.fill_template(box_template, replace)
        env.add_object(box_urdf, box_pose, 'fixed')

        # Add colored blocks and bowls to the environment
        blocks = []
        bowls = []
        for i, color in enumerate(color_sequence):
            # Add block
            block_color = utils.COLORS[color]
            block_pose = self.get_random_pose(env, block_size)
            block_urdf = 'stacking/block.urdf'
            block_id = env.add_object(block_urdf, block_pose, color=block_color)
            blocks.append(block_id)

            # Add bowl
            bowl_color = block_color  # Matching color for the bowl
            bowl_pose = self.get_random_pose(env, bowl_size)
            bowl_urdf = 'bowl/bowl.urdf'
            bowl_id = env.add_object(bowl_urdf, bowl_pose, color=bowl_color)
            bowls.append(bowl_id)

            # Goal: place block in the matching bowl
            language_goal = self.lang_template.format(color=color)
            self.add_goal(objs=[block_id], matches=np.ones((1, 1)), targ_poses=[bowl_pose],
                          replace=False, rotations=True, metric='pose', params=None,
                          step_max_reward=1/5, language_goal=language_goal)

        # Goal: stack the bowls on the box in the specified color sequence
        for i, bowl_id in enumerate(bowls):
            # Calculate the target pose for the bowl on the box
            z_offset = box_size[2] + (i * bowl_size[2])  # Incremental height for each bowl
            targ_pose = (box_pose[0], (0, 0, z_offset), box_pose[1])  # Target pose on top of the box

            # Add stacking goal for the bowl
            language_goal = self.lang_template.format(color=color_sequence[i])
            self.add_goal(objs=[bowl_id], matches=np.ones((1, 1)), targ_poses=[targ_pose],
                          replace=False, rotations=True, metric='pose', params=None,
                          step_max_reward=1/5, language_goal=language_goal)

        # Set the primitive to use for the task
        self.primitive = primitives.push  # Use push primitive for stacking bowls