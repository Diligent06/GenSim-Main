import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class TripleTowerTimber(Task):
    """
    Create three separate towers by stacking a red cylinder, a green block,
    and a blue ball respectively on each of three stands, ensuring they balance
    and do not fall over.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We have three objects to place, so max_steps is twice that number
        self.lang_template = "stack a {color} {shape} on the {nth} stand"
        self.task_completed_desc = "done building triple towers."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector

    def reset(self, env):
        super().reset(env)

        # Define the colors and shapes for the objects
        colors = {'red': utils.COLORS['red'], 'green': utils.COLORS['green'], 'blue': utils.COLORS['blue']}
        shapes = ['cylinder', 'block', 'ball']
        urdf_templates = {
            'cylinder': 'cylinder/cylinder-template.urdf',
            'block': 'stacking/block.urdf',
            'ball': 'ball/ball-template.urdf'
        }
        sizes = {
            'cylinder': (0.04, 0.04, 0.08),  # (radius, radius, height)
            'block': (0.04, 0.04, 0.04),     # (x, y, z)
            'ball': (0.04, 0.04, 0.04)       # (radius, radius, radius)
        }

        # Add stands
        stand_urdf = 'stacking/stand.urdf'
        stand_size = (0.05, 0.05, 0.02)  # (x, y, z)
        stands = []
        for _ in range(3):
            stand_pose = self.get_random_pose(env, stand_size)
            stand_id = env.add_object(stand_urdf, stand_pose, 'fixed')
            stands.append((stand_id, stand_pose))

        # Add objects and define goals
        for i, (color_name, shape) in enumerate(zip(colors, shapes)):
            color = colors[color_name]
            size = sizes[shape]
            urdf_template = urdf_templates[shape]

            # Get a random pose for the object
            object_pose = self.get_random_pose(env, size)

            # Fill in the URDF template if necessary
            if 'template' in urdf_template:
                replace = {'SIZE': size, 'COLOR': color}
                urdf = self.fill_template(urdf_template, replace)
            else:
                urdf = urdf_template

            # Add the object to the environment
            object_id = env.add_object(urdf, object_pose, 'rigid')

            # Define the target pose on top of the stand
            _, stand_pose = stands[i]
            target_pose = (stand_pose[0], (0, 0, 0, 1))  # No rotation needed, keep upright

            # Define the language goal
            language_goal = self.lang_template.format(color=color_name, shape=shape, nth=utils.ordinal(i + 1))

            # Add the goal for this object
            self.add_goal(objs=[object_id], matches=np.ones((1, 1)), targ_poses=[target_pose], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/3,
                          language_goal=language_goal)

        # The task is set up with three goals, one for each object to be placed on a stand