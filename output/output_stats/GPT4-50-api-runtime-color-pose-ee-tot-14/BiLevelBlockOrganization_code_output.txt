import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BiLevelBlockOrganization(Task):
    """
    Arrange four uniquely colored blocks on two different height stands,
    so each stand holds two blocks with matching colors.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 4  # We will have two goals, so max_steps is twice that
        self.ee = Suction  # We need to move objects on the Z axis, so we use Suction
        self.lang_template = "place the {color} block on the {level} stand"
        self.task_completed_desc = "done organizing blocks on stands."

    def reset(self, env):
        super().reset(env)

        # Define the colors for the blocks
        block_colors = ['red', 'green', 'blue', 'yellow']
        np.random.shuffle(block_colors)  # Shuffle to ensure randomness

        # Define the sizes for the stands
        stand_sizes = [(0.05, 0.15, 0.05), (0.05, 0.15, 0.10)]  # Two different heights
        stand_urdf = 'stacking/stand.urdf'

        # Add stands to the environment
        stands = []
        for size in stand_sizes:
            stand_pose = self.get_random_pose(env, size)
            env.add_object(stand_urdf, stand_pose, category='fixed')
            stands.append((stand_pose, size))

        # Add blocks to the environment
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks
        block_urdf = 'stacking/block.urdf'
        blocks = []
        for color_name in block_colors:
            block_pose = self.get_random_pose(env, block_size)
            color = utils.COLORS[color_name]
            block_id = env.add_object(block_urdf, block_pose, color=color)
            blocks.append((block_id, color_name))

        # Define goals for placing blocks on stands
        for i, (block_id, color_name) in enumerate(blocks):
            # Alternate between the two stands for each block
            stand_idx = i % 2
            stand_pose, stand_size = stands[stand_idx]
            level = 'lower' if stand_size[2] < 0.1 else 'higher'

            # Define the target pose for the block on the stand
            # We use the stand's pose but adjust the z-coordinate to be on top of the stand
            target_pose = (stand_pose[0], stand_pose[1])

            # Add the goal for the block
            self.add_goal(
                objs=[block_id],
                matches=np.ones((1, 1)),
                targ_poses=[target_pose],
                replace=False,
                rotations=False,
                metric='pose',
                params=None,
                step_max_reward=1 / len(blocks),  # Reward is split across all blocks
                language_goal=self.lang_template.format(color=color_name, level=level)
            )

        # The task is set up with blocks and stands, and goals are defined for organizing them.