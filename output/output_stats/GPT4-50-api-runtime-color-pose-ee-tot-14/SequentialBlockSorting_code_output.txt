import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class SequentialBlockSorting(Task):
    """Pick up colored blocks in a specific sequence and place them into correspondingly colored zones marked on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we have 5 blocks to sort, 2 steps per block (pick & place)
        self.lang_template = "pick up the {color} block and place it in the {color} zone"
        self.task_completed_desc = "done sorting all blocks."
        self.ee = Suction  # Use suction end-effector to pick up blocks
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the number of blocks and zones
        n_blocks = 5
        n_zones = n_blocks  # One zone per block

        # Define block size
        block_size = (0.04, 0.04, 0.04)  # x, y, z dimensions

        # Define colors for blocks and zones
        colors = ['red', 'green', 'blue', 'yellow', 'purple']
        np.random.shuffle(colors)  # Shuffle colors to randomize the order for the task

        # Add zones with corresponding colors
        zone_size = (0.1, 0.1, 0)  # x, y dimensions (no height for zones)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for color in colors:
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[color])
            zone_poses.append(zone_pose)

        # Add blocks with corresponding colors
        block_urdf = 'stacking/block.urdf'
        blocks = []
        for color in colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Add goals for each block to be placed in the matching color zone
        for i in range(n_blocks):
            color = colors[i]
            language_goal = self.lang_template.format(color=color)
            # IMPORTANT: Specify target zone pose for each block
            self.add_goal(objs=[blocks[i]], matches=np.int32([[1]]), targ_poses=[zone_poses[i]],
                          replace=False, rotations=True, metric='zone', params=None,
                          step_max_reward=1/n_blocks, language_goal=language_goal)

        # Set the sequence in which blocks should be sorted
        self.goals = self.goals[::-1]  # Reverse the goals to start with the last added (first in sequence)

# Instantiate the task
task = SequentialBlockSorting()