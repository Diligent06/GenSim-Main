import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class AscendingPyramidStack(Task):
    """Stack five differently colored bowls in an ascending pyramid formation."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to call self.add_goal 5 times, so set max_steps to twice that number
        self.lang_template = "stack the {color} bowl on the {position} position"
        self.task_completed_desc = "done stacking the bowls in ascending pyramid formation."
        self.ee = Suction  # Use Suction end-effector to move bowls on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define bowl sizes in descending order for the pyramid stack
        bowl_sizes = [
            (0.18, 0.18, 0.08),  # Largest bowl at the bottom
            (0.15, 0.15, 0.07),
            (0.12, 0.12, 0.06),
            (0.09, 0.09, 0.05),
            (0.06, 0.06, 0.04)   # Smallest bowl at the top
        ]

        # Define bowl colors
        bowl_colors = ['red', 'orange', 'yellow', 'green', 'blue']

        # Add target zone where the bowls will be stacked
        zone_size = (0.3, 0.3, 0.01)  # Size of the zone to accommodate the largest bowl
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add bowls and set goals for stacking
        bowls = []
        for i, size in enumerate(bowl_sizes):
            # Get a random pose for the bowl
            bowl_pose = self.get_random_pose(env, size)
            # Add the bowl to the environment with the corresponding color
            bowl_color = utils.COLORS[bowl_colors[i]]
            bowl_urdf = 'bowl/bowl.urdf'
            bowl_id = env.add_object(bowl_urdf, bowl_pose, color=bowl_color)
            bowls.append(bowl_id)

            # Define the target pose for the bowl in the stack
            # The x and y coordinates are the same as the zone, and z is incremented based on the bowl's height
            z_offset = sum(bowl_sizes[j][2] for j in range(i))  # Sum the heights of all bowls below the current one
            targ_pose = (zone_pose[0], (0, 0, 0, 1))  # Quaternion (0, 0, 0, 1) represents no rotation

            # Define the language goal
            position = ['bottom', 'second', 'middle', 'second to top', 'top'][i]
            language_goal = self.lang_template.format(color=bowl_colors[i], position=position)

            # Add the goal for the current bowl
            self.add_goal(
                objs=[bowl_id],
                matches=np.ones((1, 1)),  # Each bowl has a unique target pose
                targ_poses=[targ_pose],
                replace=False,  # Bowls should not be replaced once stacked
                rotations=False,  # Rotation is not considered in this task
                metric='pose',  # We are using pose metric to evaluate the placement
                params=None,  # No additional parameters needed
                step_max_reward=1 / len(bowl_sizes),  # Reward is evenly distributed across all bowls
                language_goal=language_goal
            )