import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CornerBlockClassification(Task):
    """Sort four differently colored blocks into their respective color-coded L-shaped corners."""

    def __init__(self):
        super().__init__()
        self.max_steps = 8  # We expect to call self.add_goal twice, so we set max_steps to 4x2=8
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        # Define the language template for the task
        self.lang_template = "put the {color} block in the {color} corner"
        self.task_completed_desc = "done sorting blocks into corners."

    def reset(self, env):
        super().reset(env)

        # Define the colors for the blocks and corners
        block_colors = ['red', 'green', 'blue', 'yellow']
        np.random.shuffle(block_colors)  # Shuffle to randomize the order for each reset

        # Define the size for the blocks
        block_size = (0.04, 0.04, 0.04)  # x, y, z dimensions for the block size

        # Add L-shaped corners
        corner_template = 'corner/corner-template.urdf'
        corner_poses = []
        for color in block_colors:
            # Generate a random pose for the corner within the workspace bounds
            corner_pose = self.get_random_pose(env, obj_size=block_size)
            # Replace the template URDF with the color of the corner
            replace = {'COLOR': utils.COLORS[color]}
            corner_urdf = self.fill_template(corner_template, replace)
            # Add the corner object to the environment
            env.add_object(corner_urdf, corner_pose, 'fixed')
            corner_poses.append(corner_pose)

        # Add blocks
        block_urdf = 'stacking/block.urdf'
        blocks = []
        for color in block_colors:
            # Generate a random pose for the block within the workspace bounds
            block_pose = self.get_random_pose(env, obj_size=block_size)
            # Add the block object to the environment with the specified color
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Define goals for each block to be in the matching color corner
        for i, color in enumerate(block_colors):
            # Define the language goal for placing the block in the correct corner
            language_goal = self.lang_template.format(color=color)
            # Add the goal for the block to be in the corresponding corner
            self.add_goal(objs=[blocks[i]], matches=np.int32([[1]]), targ_poses=[corner_poses[i]],
                          replace=False, rotations=False, metric='pose', params=None,
                          step_max_reward=1, language_goal=language_goal)

        # Note: We do not need to specify rotations for the blocks as they are symmetric
        # and the task does not require a specific orientation.