import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BowlTowerConstruction(Task):
    """
    Stack five differently colored bowls in descending order of size to form a tower on a designated zone
    without the structure toppling over.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Set to twice the number of goals (5 bowls to stack)
        self.lang_template = "stack the {color} bowl on top of the {target_color} one"
        self.task_completed_desc = "done constructing the bowl tower."
        self.ee = Suction  # Use Suction end-effector to lift bowls in Z axis

    def reset(self, env):
        super().reset(env)

        # Define the colors for the bowls
        bowl_colors = ['red', 'orange', 'yellow', 'green', 'blue']
        np.random.shuffle(bowl_colors)  # Shuffle to randomize the order for each episode

        # Define the size for the largest bowl and the size decrement for each smaller bowl
        largest_bowl_size = 0.15
        size_decrement = 0.02

        # Add target zone where the bowls will be stacked
        zone_size = (0.18, 0.18, 0)  # Slightly larger than the largest bowl
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Initialize list to keep track of bowl objects and their sizes
        bowls = []
        bowl_sizes = []

        # Add bowls in descending order of size
        for i in range(5):
            # Calculate the size of the current bowl
            bowl_size = largest_bowl_size - i * size_decrement
            bowl_sizes.append(bowl_size)

            # Get a random pose for the bowl
            pose = self.get_random_pose(env, (bowl_size, bowl_size, 0))

            # Add the bowl object to the environment
            color = utils.COLORS[bowl_colors[i]]
            bowl_urdf = 'bowl/bowl.urdf'
            bowl_id = env.add_object(bowl_urdf, pose, color=color)
            bowls.append(bowl_id)

        # Add goals for each bowl to be stacked
        for i in range(5):
            # The target pose is on top of the previously placed bowl or the zone for the first bowl
            if i == 0:
                target_pose = zone_pose
                target_color = "zone"
            else:
                # Calculate the height offset based on the bowl sizes
                z_offset = sum(bowl_sizes[:i]) * 0.5  # Half the total height of bowls below
                target_pose = (zone_pose[0], (0, 0, z_offset))  # Adjust z-coordinate
                target_color = bowl_colors[i-1]

            # Define the language goal for the current bowl
            language_goal = self.lang_template.format(color=bowl_colors[i], target_color=target_color)

            # Add the goal for the current bowl
            self.add_goal(objs=[bowls[i]], matches=np.ones((1, 1)), targ_poses=[target_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/5,
                          language_goal=language_goal)

        # Set the primitive to be used for this task
        self.primitive = primitives.pick_place