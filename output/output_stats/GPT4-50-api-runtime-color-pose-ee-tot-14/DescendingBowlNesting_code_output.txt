import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class DescendingBowlNesting(Task):
    """Nest a set of three bowls of decreasing sizes inside one another on the table, with the largest on the bottom and the smallest on top."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is set to twice that number
        self.lang_template = "nest the {size} bowl inside the {target_size} one"
        self.task_completed_desc = "done nesting all bowls."
        self.ee = Suction  # Using Suction end-effector as we need to move objects on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the sizes for the three bowls, largest to smallest
        bowl_sizes = [
            (0.18, 0.18, 0.08),  # Large bowl
            (0.12, 0.12, 0.06),  # Medium bowl
            (0.06, 0.06, 0.04)   # Small bowl
        ]

        # Define the colors for the three bowls
        bowl_colors = [
            utils.COLORS['blue'],   # Large bowl
            utils.COLORS['red'],    # Medium bowl
            utils.COLORS['green']   # Small bowl
        ]

        # Define the size names for language goals
        size_names = ['large', 'medium', 'small']

        # Load the URDF for the bowl
        bowl_urdf = 'bowl/bowl.urdf'

        # Initialize a list to store the bowl object IDs and poses
        bowl_ids = []
        bowl_poses = []

        # Add the three bowls to the environment
        for i in range(3):
            # Get a random pose for the bowl
            pose = self.get_random_pose(env, bowl_sizes[i])
            # Add the bowl to the environment with the corresponding color
            bowl_id = env.add_object(bowl_urdf, pose, color=bowl_colors[i])
            # Store the object ID and pose
            bowl_ids.append(bowl_id)
            bowl_poses.append(pose)

        # Add goals for nesting the bowls
        for i in range(2, 0, -1):  # Start from the smallest bowl and go up to the second largest
            # Language goal describes the current nesting step
            language_goal = self.lang_template.format(size=size_names[i], target_size=size_names[i-1])
            # Add the goal for the current bowl to be nested inside the next larger bowl
            self.add_goal(
                objs=[bowl_ids[i]],  # Current bowl
                matches=np.ones((1, 1)),  # Single match as we have one bowl to place
                targ_poses=[bowl_poses[i-1]],  # Target pose is the pose of the next larger bowl
                replace=False,  # Each bowl has a unique target
                rotations=False,  # Rotation is not considered in nesting
                metric='pose',  # We use pose metric to check if the bowl is nested correctly
                params=None,  # No additional parameters needed
                step_max_reward=1,  # Full reward for completing this step
                language_goal=language_goal  # Language goal for this step
            )