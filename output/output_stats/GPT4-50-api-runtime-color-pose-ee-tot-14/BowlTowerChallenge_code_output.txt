import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BowlTowerChallenge(Task):
    """
    Stack three differently colored bowls upside down in a vertical tower without letting the tower fall over,
    with the smallest bowl on top and the largest at the bottom.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice the number of goals
        self.ee = Suction  # Using Suction end-effector to lift bowls on the Z axis
        self.lang_template = "stack the {color} bowl {position} in the tower"
        self.task_completed_desc = "done stacking the bowls."

    def reset(self, env):
        super().reset(env)

        # Define bowl sizes (diameter, height)
        sizes = [
            (0.12, 0.06),  # Large bowl
            (0.10, 0.05),  # Medium bowl
            (0.08, 0.04)   # Small bowl
        ]

        # Define bowl colors
        colors = ['red', 'green', 'blue']
        color_names = ['red', 'green', 'blue']

        # Add bowls to the environment
        bowls = []
        for i in range(3):
            # Generate a random pose for the bowl
            pose = self.get_random_pose(env, sizes[i])
            # Get the color for the bowl
            color = utils.COLORS[colors[i]]
            # Load the URDF of the bowl
            bowl_urdf = 'bowl/bowl.urdf'
            # Add the bowl to the environment
            bowl_id = env.add_object(bowl_urdf, pose, color=color)
            bowls.append((bowl_id, pose))

        # Define the target poses for the bowls, stacked in order with the largest at the bottom
        targ_poses = [
            bowls[0][1],  # Target pose for the large bowl (bottom)
            (bowls[1][1][0], (bowls[0][1][1][0], bowls[0][1][1][1], bowls[0][1][1][2] + sizes[0][1])),  # Medium bowl
            (bowls[2][1][0], (bowls[1][1][1][0], bowls[1][1][1][1], bowls[1][1][1][2] + sizes[1][1]))   # Small bowl (top)
        ]

        # Add goals for each bowl
        for i in range(3):
            # Define the language goal
            position = ['on the bottom', 'in the middle', 'on the top'][i]
            language_goal = self.lang_template.format(color=color_names[i], position=position)
            # Add the goal to the task
            self.add_goal(
                objs=[bowls[i][0]],  # Object ID
                matches=np.ones((1, 1)),  # Single object to single target
                targ_poses=[targ_poses[i]],  # Target pose
                replace=False,  # Each bowl has a unique target pose
                rotations=False,  # Rotation is not considered in this task
                metric='pose',  # We are using pose metric
                params=None,  # No additional parameters
                step_max_reward=1 / 3,  # Equal reward for each step, summing to 1
                language_goal=language_goal  # Language goal
            )