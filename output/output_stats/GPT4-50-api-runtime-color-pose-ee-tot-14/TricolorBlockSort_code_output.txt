import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class TricolorBlockSort(Task):
    """
    Task to pick up nine blocks, three of each color (red, blue, green),
    and sort them into three matching colored zones on a table.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We expect to call self.add_goal three times, so max_steps is twice that
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        # Define the language templates for each color
        self.lang_templates = {
            'red': "sort the red blocks into the red zone",
            'blue': "sort the blue blocks into the blue zone",
            'green': "sort the green blocks into the green zone"
        }
        self.task_completed_desc = "done sorting the blocks by color."

    def reset(self, env):
        super().reset(env)

        # Define the number of blocks per color and the size of each block
        n_blocks_per_color = 3
        block_size = (0.04, 0.04, 0.04)  # x, y, z dimensions for the asset size

        # Define the colors for the blocks and zones
        block_colors = ['red', 'blue', 'green']
        zone_colors = block_colors.copy()

        # Add colored zones
        zone_size = (0.12, 0.12, 0)  # x, y dimensions for the zone size (z is 0 because it's a flat zone)
        zone_urdf = 'zone/zone.urdf'
        zone_poses = {}
        for color in zone_colors:
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[color])
            zone_poses[color] = zone_pose

        # Add blocks and sort them into the corresponding colored zones
        block_urdf = 'stacking/block.urdf'
        for color in block_colors:
            # Add three blocks of the same color
            blocks = []
            for _ in range(n_blocks_per_color):
                block_pose = self.get_random_pose(env, block_size)
                block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
                blocks.append(block_id)

            # Define the goal for each color
            self.add_goal(
                objs=blocks,
                matches=np.ones((n_blocks_per_color, 1)),  # Each block matches with the zone of the same color
                targ_poses=[zone_poses[color]],  # Target pose is the pose of the zone with the same color
                replace=False,  # Each block can only match with one zone
                rotations=False,  # Blocks do not need to be rotated
                metric='zone',  # We are placing blocks in a zone, not matching exact poses
                params=[(zone_poses[color], zone_size)],  # Parameters for the zone metric
                step_max_reward=1 / 3,  # There are three goals, so each goal contributes 1/3 to the total reward
                language_goal=self.lang_templates[color]  # Language goal for the current color
            )

        # The task is set up with three goals, one for each color, and the environment is ready for the agent to execute the task.