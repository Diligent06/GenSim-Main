import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderTowerChallenge(Task):
    """Sequentially stack six different colored cylinders on top of a square stand."""

    def __init__(self):
        super().__init__()
        self.max_steps = 12  # We have 6 cylinders to stack, so 12 steps should be sufficient
        self.lang_template = "stack the {color} cylinder on top of the {prev_color} one"
        self.task_completed_desc = "done stacking the cylinder tower."
        self.ee = Suction  # Use Suction end-effector to lift cylinders along the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the colors for the cylinders
        colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple']
        color_names = ['red', 'orange', 'yellow', 'green', 'blue', 'purple']

        # Add base stand
        base_size = (0.15, 0.15, 0.005)  # Size of the square stand
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Add cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_size = (0.05, 0.05, 0.1)  # Size of the cylinders (diameter, diameter, height)
        cylinder_poses = []
        cylinder_ids = []

        for i, color in enumerate(colors):
            # Generate a random pose for the cylinder
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_poses.append(cylinder_pose)

            # Fill in the cylinder URDF template with the specific color and size
            replace = {'COLOR': utils.COLORS[color], 'SIZE': cylinder_size}
            cylinder_urdf = self.fill_template(cylinder_template, replace)

            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            cylinder_ids.append(cylinder_id)

            # Define the language goal for stacking this cylinder
            prev_color = 'the stand' if i == 0 else color_names[i - 1]
            language_goal = self.lang_template.format(color=color, prev_color=prev_color)

            # Define the target pose for the cylinder (central alignment with the one below)
            target_pose = (base_pose[0], base_pose[1]) if i == 0 else (cylinder_poses[i - 1][0], base_pose[1])
            target_height = base_size[2] + cylinder_size[2] * (i + 1)  # Calculate the height of the stack
            target_pose = (target_pose[0], (target_pose[1][0], target_pose[1][1], target_height, target_pose[1][3]))

            # Add the goal for this cylinder
            self.add_goal(objs=[cylinder_ids[i]], matches=np.ones((1, 1)), targ_poses=[target_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / 6,
                          language_goal=language_goal)

        # Set the primitive action to be used for this task
        self.primitive = primitives.push