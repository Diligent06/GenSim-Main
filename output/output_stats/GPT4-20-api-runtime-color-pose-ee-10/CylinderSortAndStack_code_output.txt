import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderSortAndStack(Task):
    """Pick and sort cylinders of three different colors into corresponding colored zones, 
    and then stack them into three separate towers, each within its own zone."""

    def __init__(self):
        super().__init__()
        self.max_steps = 12  # We expect to call self.add_goal 6 times (3 for sorting, 3 for stacking)
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector

        # Language templates for the task
        self.lang_template_sort = "sort the {color} cylinder into the {color} zone"
        self.lang_template_stack = "stack the {color} cylinder on top of the other {color} cylinder in the {color} zone"
        self.task_completed_desc = "done sorting and stacking cylinders."

    def reset(self, env):
        super().reset(env)

        # Define the colors and create zones for each color
        colors = ['red', 'green', 'blue']
        zones = []
        for color in colors:
            # Create a zone for each color
            zone_size = (0.1, 0.1, 0)  # Zones are flat squares on the table
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object('zone/zone.urdf', zone_pose, 'fixed', color=utils.COLORS[color])
            zones.append((zone_pose, zone_size))

        # Add cylinders of each color
        cylinders = []
        for color in colors:
            for _ in range(3):  # Three cylinders per color
                # Define the size of the cylinder
                size = (0.04, 0.04, 0.12)  # Diameter, Diameter, Height
                pose = self.get_random_pose(env, size)
                replace = {'DIM': size, 'COLOR': utils.COLORS[color]}
                cylinder_urdf = self.fill_template('cylinder/cylinder-template.urdf', replace)
                cylinder_id = env.add_object(cylinder_urdf, pose)
                cylinders.append((cylinder_id, color))

        # Sort cylinders into corresponding colored zones
        for cylinder, color in cylinders:
            # Define the sorting goal for each cylinder
            zone_pose, _ = zones[colors.index(color)]
            language_goal = self.lang_template_sort.format(color=color)
            self.add_goal(objs=[cylinder], matches=np.int32([[1]]), targ_poses=[zone_pose], replace=True,
                          rotations=False, metric='zone', params=[zone_pose], step_max_reward=1/6,
                          language_goal=language_goal)

        # Stack cylinders into towers within their zones
        for i, (zone_pose, zone_size) in enumerate(zones):
            color = colors[i]
            # Get the cylinders of the same color
            color_cylinders = [cyl for cyl, cyl_color in cylinders if cyl_color == color]
            # Define the stacking goals for each cylinder
            for j in range(1, len(color_cylinders)):
                # The target pose is on top of the previous cylinder
                base_cylinder_pose = p.getBasePositionAndOrientation(color_cylinders[j-1])
                target_pose = (base_cylinder_pose[0], base_cylinder_pose[1])
                target_pose[0][2] += size[2]  # Increase the z-coordinate to stack on top
                language_goal = self.lang_template_stack.format(color=color)
                self.add_goal(objs=[color_cylinders[j]], matches=np.int32([[1]]), targ_poses=[target_pose], replace=False,
                              rotations=True, metric='pose', params=None, step_max_reward=1/6,
                              language_goal=language_goal)

        # The task is set up with sorting and stacking goals for the cylinders