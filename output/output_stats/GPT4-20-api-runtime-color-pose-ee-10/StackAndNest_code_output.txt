import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class StackAndNest(Task):
    """
    Stack three differently sized cylinders on the stand and then nest a bowl on top of them
    without toppling the structure.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 8  # We expect to add 4 goals, so max_steps is twice that number
        self.ee = Suction  # Use Suction end-effector to lift objects along the Z axis

        # Language templates for the task
        self.lang_template = "stack the {size} cylinder on the {place}"
        self.task_completed_desc = "done stacking and nesting."

        # Initialize additional variables if needed
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the sizes for the cylinders (small, medium, large)
        sizes = [(0.04, 0.04, 0.08), (0.06, 0.06, 0.12), (0.08, 0.08, 0.16)]
        size_names = ['small', 'medium', 'large']

        # Define the color for the cylinders
        colors = [utils.COLORS['red'], utils.COLORS['green'], utils.COLORS['blue']]

        # Add stand
        stand_size = (0.1, 0.1, 0.02)
        stand_urdf = 'stacking/stand.urdf'
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object(stand_urdf, stand_pose, category='fixed')

        # Add cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []
        for i, size in enumerate(sizes):
            replace = {'SIZE': size}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_pose = self.get_random_pose(env, size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=colors[i])
            cylinder_poses.append((cylinder_id, cylinder_pose))

        # Add bowl on top of the largest cylinder
        bowl_size = (0.1, 0.1, 0.04)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_pose = self.get_random_pose(env, bowl_size)
        bowl_id = env.add_object(bowl_urdf, bowl_pose, color=utils.COLORS['yellow'])

        # Define target poses for the cylinders on the stand
        # The cylinders are stacked in order of increasing size
        targ_poses = []
        z_offset = 0.02  # Initial z-offset from the stand
        for size in sizes:
            z_offset += size[2] / 2  # Increment z-offset by half the height of the cylinder
            targ_pose = (stand_pose[0], (0, 0, z_offset), stand_pose[1])
            targ_poses.append(targ_pose)
            z_offset += size[2] / 2  # Increment z-offset for the next cylinder

        # Add goals for stacking cylinders
        for i, (cylinder_id, _) in enumerate(cylinder_poses):
            self.add_goal(
                objs=[cylinder_id],
                matches=np.ones((1, 1)),
                targ_poses=[targ_poses[i]],
                replace=False,
                rotations=True,
                metric='pose',
                params=None,
                step_max_reward=1 / 4,
                language_goal=self.lang_template.format(size=size_names[i], place="stand")
            )

        # Add goal for nesting the bowl on top of the largest cylinder
        bowl_targ_pose = (stand_pose[0], (0, 0, z_offset + bowl_size[2] / 2), stand_pose[1])
        self.add_goal(
            objs=[bowl_id],
            matches=np.ones((1, 1)),
            targ_poses=[bowl_targ_pose],
            replace=False,
            rotations=True,
            metric='pose',
            params=None,
            step_max_reward=1 / 4,
            language_goal="nest the yellow bowl on top of the stack"
        )