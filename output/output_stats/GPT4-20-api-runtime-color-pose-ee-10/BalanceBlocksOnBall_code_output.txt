import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BalanceBlocksOnBall(Task):
    """
    Sequentially stack three differently colored blocks on top of a large, static ball,
    ensuring each block remains balanced without falling off.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We have 3 blocks to place, so 6 steps should be sufficient
        self.lang_template = "put the {color} block on top of the {target}"
        self.task_completed_desc = "done balancing blocks on ball."
        self.ee = Suction  # We need to move objects on the Z axis, so Suction is appropriate

    def reset(self, env):
        super().reset(env)

        # Define the colors for the blocks
        block_colors = ['red', 'green', 'blue']
        block_color_values = [utils.COLORS[color] for color in block_colors]

        # Define the size of the blocks
        block_size = (0.04, 0.04, 0.04)  # x, y, z dimensions

        # Add the large static ball
        ball_size = (0.1, 0.1, 0.1)  # x, y, z dimensions
        ball_template = 'ball/ball-template.urdf'
        ball_pose = self.get_random_pose(env, ball_size)
        replace = {'DIM': ball_size}
        ball_urdf = self.fill_template(ball_template, replace)
        ball_id = env.add_object(ball_urdf, ball_pose, 'fixed')

        # Add the blocks and define their initial random poses
        blocks = []
        for i, color in enumerate(block_colors):
            block_pose = self.get_random_pose(env, block_size)
            block_urdf = 'stacking/block.urdf'
            block_id = env.add_object(block_urdf, block_pose, color=block_color_values[i])
            blocks.append(block_id)

        # Define the target poses for the blocks on the ball
        # The z-coordinate is incremented for each block to stack them
        targ_poses = [
            (ball_pose[0], ball_pose[1]),  # First block directly on the ball
            (ball_pose[0], ball_pose[1] + np.array([0, 0, block_size[2]])),  # Second block on top of the first
            (ball_pose[0], ball_pose[1] + np.array([0, 0, 2 * block_size[2]])),  # Third block on top of the second
        ]

        # Add goals for each block to be placed on the ball
        for i, block_id in enumerate(blocks):
            language_goal = self.lang_template.format(color=block_colors[i], target="ball")
            self.add_goal(
                objs=[block_id],
                matches=np.ones((1, 1)),  # Each block has a unique target pose
                targ_poses=[targ_poses[i]],
                replace=False,  # Each target pose is unique to a block
                rotations=True,  # Allow rotations for the blocks
                metric='pose',  # We are using pose matching for the goal
                params=None,  # No additional parameters needed
                step_max_reward=1 / len(blocks),  # Reward is evenly distributed across blocks
                language_goal=language_goal
            )