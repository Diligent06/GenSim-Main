import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PalletCylinderPattern(Task):
    """Sort and place colored cylinders onto a pallet to form a specific checkerboard pattern."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we will have 5 cylinders to place, 2 steps per cylinder
        self.ee = Suction  # Using Suction end-effector to pick and place cylinders vertically

        # Language templates for instructions
        self.lang_template = "place the {color} cylinder on the {location} location on the pallet"
        self.task_completed_desc = "completed the checkerboard pattern."

        # Additional initialization if needed
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the size and pose of the pallet
        pallet_size = (0.3, 0.3, 0.02)  # Size of the pallet (x, y, z)
        pallet_pose = self.get_random_pose(env, pallet_size)  # Get a random pose for the pallet
        pallet_urdf = 'pallet/pallet.urdf'  # URDF file for the pallet
        env.add_object(pallet_urdf, pallet_pose, 'fixed')  # Add the pallet to the environment

        # Define the cylinders' properties
        n_cylinders = 5  # Number of cylinders to place
        cylinder_template = 'cylinder/cylinder-template.urdf'  # URDF template for the cylinders
        cylinder_size = (0.02, 0.02, 0.1)  # Size of the cylinders (x, y, z)

        # Define the checkerboard pattern colors
        colors = ['red', 'blue']  # Colors used in the checkerboard pattern
        color_objs = []  # List to store the color and object ID

        # Add cylinders to the environment
        for i in range(n_cylinders):
            # Alternate colors for the checkerboard pattern
            color_name = colors[i % len(colors)]
            color_rgb = utils.COLORS[color_name]  # Get the RGB values for the color

            # Get a random pose for the cylinder
            cylinder_pose = self.get_random_pose(env, cylinder_size)

            # Fill in the URDF template with the specific color and size
            replace = {'COLOR': color_rgb, 'SIZE': cylinder_size}
            cylinder_urdf = self.fill_template(cylinder_template, replace)

            # Add the cylinder to the environment and store its ID and color
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            color_objs.append((color_name, cylinder_id))

        # Define the target locations on the pallet for the checkerboard pattern
        # Assuming a 2x2 pattern on the pallet, with one extra cylinder
        target_positions = [
            (pallet_pose[0][0] - 0.05, pallet_pose[0][1] - 0.05, pallet_pose[0][2] + 0.1),
            (pallet_pose[0][0] + 0.05, pallet_pose[0][1] - 0.05, pallet_pose[0][2] + 0.1),
            (pallet_pose[0][0] - 0.05, pallet_pose[0][1] + 0.05, pallet_pose[0][2] + 0.1),
            (pallet_pose[0][0] + 0.05, pallet_pose[0][1] + 0.05, pallet_pose[0][2] + 0.1),
        ]

        # Add goals for each cylinder
        for idx, (color_name, cylinder_id) in enumerate(color_objs):
            # Calculate the target position index based on the cylinder index
            target_idx = idx % len(target_positions)
            target_position = target_positions[target_idx]

            # Create the language goal for placing the cylinder
            location_desc = f"{color_name} square"
            language_goal = self.lang_template.format(color=color_name, location=location_desc)

            # Add the goal for the cylinder
            self.add_goal(
                objs=[cylinder_id],
                matches=np.int32([[1]]),
                targ_poses=[(target_position, (0, 0, 0, 1))],  # Upright orientation
                replace=False,
                rotations=False,  # Cylinders should be upright, no rotation needed
                metric='pose',
                params=None,
                step_max_reward=1 / n_cylinders,
                language_goal=language_goal
            )