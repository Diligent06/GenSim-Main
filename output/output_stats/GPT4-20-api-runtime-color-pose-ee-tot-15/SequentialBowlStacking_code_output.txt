import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class SequentialBowlStacking(Task):
    """
    Stack multiple bowls within each other in a specific color order,
    ensuring that each bowl is nested neatly within the larger one without misalignment.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 4  # We expect to stack two bowls, so max_steps is twice the number of add_goal calls
        self.ee = Suction  # Use Suction end-effector to lift bowls in Z-axis
        self.lang_template = "put the {color} bowl inside the {target_color} bowl"
        self.task_completed_desc = "done stacking bowls."

    def reset(self, env):
        super().reset(env)

        # Define the colors and sizes for the bowls
        bowl_colors = ['red', 'green', 'blue', 'yellow']
        bowl_sizes = [(0.18, 0.18, 0.08), (0.16, 0.16, 0.07), (0.14, 0.14, 0.06), (0.12, 0.12, 0.05)]
        bowl_urdf = 'bowl/bowl.urdf'

        # Shuffle the colors and sizes to randomize the task each reset
        np.random.shuffle(bowl_colors)
        np.random.shuffle(bowl_sizes)

        # Add bowls to the environment with decreasing size
        bowls = []
        for i in range(len(bowl_sizes)):
            color = utils.COLORS[bowl_colors[i]]  # Get the RGB values for the color
            size = bowl_sizes[i]  # Get the size for the bowl
            pose = self.get_random_pose(env, size)  # Get a random pose for the bowl
            bowl_id = env.add_object(bowl_urdf, pose, color=color)  # Add bowl to the environment
            bowls.append((bowl_id, pose, size))  # Keep track of the bowl's ID, pose, and size

        # Create stacking goals for each bowl, starting from the second-smallest
        for i in range(1, len(bowls)):
            # Current bowl to stack
            bowl_id, _, _ = bowls[i]
            # Target (larger) bowl to stack into
            target_bowl_id, target_bowl_pose, _ = bowls[i - 1]
            # Language goal for the current stacking action
            language_goal = self.lang_template.format(color=bowl_colors[i], target_color=bowl_colors[i - 1])
            # Add goal for stacking the current bowl into the target bowl
            self.add_goal(
                objs=[bowl_id],  # Object to move
                matches=np.ones((1, 1)),  # Single object to single target
                targ_poses=[target_bowl_pose],  # Target pose is the pose of the larger bowl
                replace=False,  # Object cannot match with multiple targets
                rotations=False,  # Rotation is not considered in this task
                metric='pose',  # Evaluation based on the pose of the object
                params=None,  # No additional parameters needed
                step_max_reward=1 / (len(bowls) - 1),  # Reward is split across the number of stacking actions
                language_goal=language_goal  # Language instruction for the goal
            )