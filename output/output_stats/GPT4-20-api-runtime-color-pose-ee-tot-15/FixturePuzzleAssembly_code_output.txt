import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class FixturePuzzleAssembly(Task):
    """Place a set of differently colored ell-shaped blocks into matching colored fixtures arranged in a specific sequence on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 4  # We expect to call self.add_goal twice, so we set this to twice that number
        self.lang_template = "put the {color} ell-shaped block into the matching {color} fixture"
        self.task_completed_desc = "done placing all ell-shaped blocks into fixtures."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector

    def reset(self, env):
        super().reset(env)

        # Define the colors for the ell-shaped blocks and fixtures
        block_colors = ['red', 'green', 'blue', 'yellow']
        np.random.shuffle(block_colors)  # Shuffle to ensure random order

        # Define the size for the ell-shaped blocks and fixtures
        block_size = (0.05, 0.05, 0.05)  # Placeholder size, adjust as needed
        fixture_size = (0.1, 0.1, 0.05)  # Placeholder size, adjust as needed

        # Add ell-shaped blocks and fixtures to the environment
        ell_urdf = 'insertion/ell.urdf'
        fixture_urdf = 'insertion/fixture.urdf'
        blocks = []
        fixtures = []

        for i, color in enumerate(block_colors):
            # Add ell-shaped block
            block_pose = self.get_random_pose(env, block_size)
            block_color = utils.COLORS[color]  # Get the RGB value for the color
            block_id = env.add_object(ell_urdf, block_pose, color=block_color)
            blocks.append((block_id, block_pose))

            # Add fixture
            fixture_pose = self.get_random_pose(env, fixture_size)
            fixture_color = block_color  # Match the color with the ell-shaped block
            fixture_id = env.add_object(fixture_urdf, fixture_pose, color=fixture_color)
            fixtures.append((fixture_id, fixture_pose))

            # Add goal for each block to be placed in the matching fixture
            language_goal = self.lang_template.format(color=color)
            self.add_goal(objs=[block_id], matches=np.ones((1, 1)), targ_poses=[fixture_pose], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/len(block_colors),
                          language_goal=language_goal)

        # The task is to place each block into the fixture of the same color in a specific sequence
        # The sequence is determined by the order of block_colors after shuffling
        # Each block has a corresponding fixture with a matching color
        # The goal is added for each block with its matching fixture pose as the target pose
        # The reward is divided equally among the blocks to encourage placing all blocks correctly