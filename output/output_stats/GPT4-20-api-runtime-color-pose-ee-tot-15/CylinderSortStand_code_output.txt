import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderSortStand(Task):
    """Sort cylinders of three different colors onto the corresponding colored section of the stand."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We have 3 cylinders to sort, so 6 steps should be enough (2x for safety)
        self.ee = Suction  # We need to move objects on the Z axis, so Suction is appropriate
        self.lang_template = "put the {color} cylinder on the {color} section of the stand"
        self.task_completed_desc = "done sorting cylinders."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors for the cylinders and the sections on the stand
        colors = ['red', 'green', 'blue']
        color_names = ['red', 'green', 'blue']

        # Add the stand with three sections, each section corresponding to a color
        stand_size = (0.3, 0.1, 0.05)  # Size of the stand
        stand_urdf = 'stacking/stand.urdf'
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object(stand_urdf, stand_pose, category='fixed')

        # Define the target poses for each cylinder on the stand
        # Assuming the sections are aligned along the x-axis of the stand
        section_offsets = [-0.1, 0, 0.1]  # Offsets for each section on the stand
        targ_poses = []
        for offset in section_offsets:
            # Calculate the pose for each section on the stand
            section_pose = (stand_pose[0][0] + offset, stand_pose[0][1], stand_pose[0][2] + stand_size[2])
            targ_poses.append((section_pose, (0, 0, 0, 1)))  # No rotation needed, quaternions for identity rotation

        # Add cylinders and define goals
        cylinder_template = 'cylinder/cylinder-template.urdf'
        for i, color in enumerate(colors):
            # Define the size and color of the cylinder
            cylinder_size = (0.02, 0.02, 0.1)  # Diameter and height of the cylinder
            cylinder_color = utils.COLORS[color]  # Get the RGB values for the color

            # Get a random pose for the cylinder
            cylinder_pose = self.get_random_pose(env, cylinder_size)

            # Fill the cylinder URDF template with the specific color and size
            replace = {'COLOR': cylinder_color, 'SIZE': cylinder_size}
            cylinder_urdf = self.fill_template(cylinder_template, replace)

            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)

            # Define the language goal for this step
            language_goal = self.lang_template.format(color=color_names[i])

            # Add the goal for the cylinder to be placed on the correct section of the stand
            self.add_goal(objs=[cylinder_id], matches=np.int32([[1]]), targ_poses=[targ_poses[i]],
                          replace=False, rotations=False, metric='pose', params=None,
                          step_max_reward=1 / len(colors), language_goal=language_goal)

        # Note: We assume that the cylinders are placed on the stand without knocking over other cylinders
        # as part of the task requirements. This would be enforced by the reward function and the done condition.