import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderTowerBalancing(Task):
    """Stack and balance a tower of three differently colored cylinders on top of each other on a single green line without the tower toppling over."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice the number of goals
        self.lang_template = "stack the {color} cylinder on top of the {base_color} one"
        self.task_completed_desc = "done stacking and balancing the cylinder tower."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector

    def reset(self, env):
        super().reset(env)

        # Define the size and color of the cylinders
        cylinder_size = (0.05, 0.05, 0.15)  # Diameter, Diameter, Height
        cylinder_colors = ['red', 'blue', 'yellow']  # Three different colors for the cylinders
        cylinder_urdf_template = 'cylinder/cylinder-template.urdf'

        # Define the size and color of the line
        line_size = (0.005, 0.5, 0.005)  # Width, Length, Height
        line_color = utils.COLORS['green']  # Single green line
        line_urdf_template = 'line/single-green-line-template.urdf'

        # Add the single green line to the environment
        line_pose = self.get_random_pose(env, line_size)
        replace = {'COLOR': line_color}
        line_urdf = self.fill_template(line_urdf_template, replace)
        env.add_object(line_urdf, line_pose, 'fixed')

        # Add cylinders to the environment
        cylinder_ids = []
        for color_name in cylinder_colors:
            color = utils.COLORS[color_name]
            replace = {'COLOR': color}
            cylinder_urdf = self.fill_template(cylinder_urdf_template, replace)
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            cylinder_ids.append(cylinder_id)

        # Define the target poses for the cylinders to be stacked on the line
        # The cylinders should be stacked along the center of the line
        line_x, line_y, _ = line_pose[0]
        base_height = line_pose[0][2] + cylinder_size[2] / 2  # Base height is the top of the line plus half the cylinder height
        target_poses = [
            (line_x, line_y, base_height),  # Base cylinder
            (line_x, line_y, base_height + cylinder_size[2]),  # Middle cylinder
            (line_x, line_y, base_height + 2 * cylinder_size[2])  # Top cylinder
        ]

        # Add goals for stacking the cylinders
        for i in range(3):
            # The target pose for the current cylinder
            targ_pose = target_poses[i]
            # The language goal describes the action to be taken
            if i == 0:
                base_color = "the green line"
            else:
                base_color = cylinder_colors[i - 1]
            language_goal = self.lang_template.format(color=cylinder_colors[i], base_color=base_color)
            # Add the goal with a step_max_reward of 1 since we have only one goal
            self.add_goal(objs=[cylinder_ids[i]], matches=np.ones((1, 1)), targ_poses=[(targ_pose, (0, 0, 0, 1))],
                          replace=False, rotations=True, metric='pose', params=None, step_max_reward=1,
                          language_goal=language_goal)

        # Note: We assume that the cylinders are perfectly cylindrical and can be placed without considering rotation
        # around the vertical axis. If rotation matters, we would need to specify the rotation part of the target poses.