import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class StackBlocksAroundBowl(Task):
    """Stack four different colored blocks around a bowl without placing any block inside the bowl or knocking it over."""

    def __init__(self):
        super().__init__()
        self.max_steps = 8  # We have 4 blocks to stack, so 8 steps should be sufficient
        self.ee = Suction  # We need to move blocks in the Z axis, so we use the Suction end-effector
        self.lang_template = "put the {color} block {location} of the bowl"
        self.task_completed_desc = "done stacking blocks around the bowl."

    def reset(self, env):
        super().reset(env)

        # Define the size and color of the bowl
        bowl_size = (0.18, 0.18, 0.06)  # x, y, z dimensions for the bowl
        bowl_color = utils.COLORS['green']  # Bowl color

        # Add the bowl to the environment
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_pose = self.get_random_pose(env, bowl_size)
        env.add_object(bowl_urdf, bowl_pose, 'fixed', color=bowl_color)

        # Define block properties
        block_size = (0.04, 0.04, 0.04)  # x, y, z dimensions for the blocks
        block_urdf = 'stacking/block.urdf'
        block_colors = ['red', 'blue', 'yellow', 'purple']  # Block colors

        # Add blocks to the environment
        blocks = []
        for color in block_colors:
            block_pose = self.get_random_pose(env, block_size)
            block_color = utils.COLORS[color]
            block_id = env.add_object(block_urdf, block_pose, color=block_color)
            blocks.append((block_id, color))

        # Define target locations around the bowl
        # We will place the blocks at 90 degree intervals around the bowl
        bowl_x, bowl_y, _ = bowl_pose[0]
        offsets = [(0.1, 0), (0, 0.1), (-0.1, 0), (0, -0.1)]
        locations = ['in front', 'to the right', 'behind', 'to the left']

        # Add goals for each block
        for i, (block_id, color) in enumerate(blocks):
            # Calculate the target position based on the bowl's position and the offset
            offset_x, offset_y = offsets[i]
            target_x = bowl_x + offset_x
            target_y = bowl_y + offset_y
            target_z = 0.01  # Slightly above the table to avoid collision
            target_pose = [(target_x, target_y, target_z), (0, 0, 0, 1)]  # No rotation needed

            # Define the language goal
            language_goal = self.lang_template.format(color=color, location=locations[i])

            # Add the goal for the current block
            self.add_goal(objs=[block_id], matches=np.ones((1, 1)), targ_poses=[target_pose], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/4,
                          language_goal=language_goal)

        # Set the progress metric
        self.progress = 0