import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderTowerBalance(Task):
    """
    Sequentially stack different colored cylinders to form a vertical tower,
    ensuring that each cylinder is completely balanced on the previous one without any part hanging off.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we will have 5 cylinders to stack, 2 steps per cylinder
        self.lang_template = "stack the {color} cylinder on top of the tower"
        self.task_completed_desc = "done stacking the cylinder tower."
        self.ee = Suction  # Suction is needed to lift cylinders along the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the number of cylinders and their colors
        n_cylinders = 5
        colors = ['red', 'green', 'blue', 'yellow', 'purple']
        color_names = ['red', 'green', 'blue', 'yellow', 'purple']

        # Define the size of the cylinders
        cylinder_height = 0.08
        cylinder_radius = 0.04
        cylinder_size = (cylinder_radius * 2, cylinder_radius * 2, cylinder_height)

        # Add cylinders to the environment
        cylinders = []
        for i in range(n_cylinders):
            # Get a random pose for the cylinder
            pose = self.get_random_pose(env, cylinder_size)
            # Define the color of the cylinder using the COLORS dictionary
            color = utils.COLORS[colors[i]]
            # Fill in the template URDF with the size and color parameters
            replace = {'DIM': cylinder_size, 'COLOR': color}
            cylinder_urdf = self.fill_template('cylinder/cylinder-template.urdf', replace)
            # Add the cylinder object to the environment
            cylinder_id = env.add_object(cylinder_urdf, pose)
            cylinders.append(cylinder_id)

        # Define the target poses for the cylinders to be stacked
        # The first cylinder's target pose is its initial pose
        targ_poses = [env.get_pose(cylinders[0])]
        # For subsequent cylinders, the target pose is above the previous one
        for i in range(1, n_cylinders):
            # Get the pose of the cylinder below
            below_pose = targ_poses[-1]
            # Calculate the pose for the current cylinder to be stacked on top
            above_pose = (below_pose[0], (below_pose[1][0], below_pose[1][1], below_pose[1][2] + cylinder_height, below_pose[1][3]))
            targ_poses.append(above_pose)

        # Add goals for each cylinder
        for i in range(n_cylinders):
            # Define the language goal for the current cylinder
            language_goal = self.lang_template.format(color=color_names[i])
            # Add the goal for the current cylinder
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[targ_poses[i]], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/n_cylinders,
                          language_goal=language_goal)

        # Set the primitive action to be used for this task
        self.primitive = primitives.pick_place