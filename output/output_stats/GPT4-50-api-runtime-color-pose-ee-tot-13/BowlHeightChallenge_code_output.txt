import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BowlHeightChallenge(Task):
    """Stack a series of three differently sized bowls inside one another from largest to smallest without toppling them."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice that number
        self.lang_template = "put the {color} bowl inside the {target_color} bowl"
        self.task_completed_desc = "done stacking the bowls."
        self.ee = Suction  # Use Suction end-effector to move bowls on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define bowl sizes from largest to smallest
        bowl_sizes = [
            (0.18, 0.18, 0.08),  # Large bowl
            (0.12, 0.12, 0.06),  # Medium bowl
            (0.06, 0.06, 0.04)   # Small bowl
        ]

        # Define bowl colors
        bowl_colors = ['blue', 'green', 'red']

        # Add bowls to the environment and store their IDs and poses for later reference
        bowl_urdf = 'bowl/bowl.urdf'
        bowls = []
        bowl_poses = []
        for size, color in zip(bowl_sizes, bowl_colors):
            # Get a random pose for the bowl
            pose = self.get_random_pose(env, size)
            # Add the bowl to the environment
            bowl_id = env.add_object(bowl_urdf, pose, color=utils.COLORS[color])
            # Store the bowl ID and pose
            bowls.append(bowl_id)
            bowl_poses.append(pose)

        # Add goals for stacking the bowls
        # The goal is to place the next smaller bowl inside the previously placed larger bowl
        for i in range(1, len(bowls)):
            # The target pose for the current bowl is the pose of the next larger bowl
            target_pose = bowl_poses[i - 1]
            # Define the language goal for the current action
            language_goal = self.lang_template.format(color=bowl_colors[i], target_color=bowl_colors[i - 1])
            # Add the goal to the task
            self.add_goal(
                objs=[bowls[i]],  # Current bowl to move
                matches=np.ones((1, 1)),  # One-to-one correspondence
                targ_poses=[target_pose],  # Target pose is the pose of the larger bowl
                replace=False,  # Bowls should not replace each other
                rotations=False,  # Rotation is not necessary for this task
                metric='pose',  # We are using pose metric for evaluation
                params=None,  # No additional parameters needed
                step_max_reward=1 / (len(bowls) - 1),  # Reward is divided among the number of stacking actions
                language_goal=language_goal  # Language goal for the current action
            )