import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderPrecisionStack(Task):
    """Stack three cylinders of different colors in ascending order of size onto a small stand without knocking them over."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is set to twice the number of goals
        self.ee = Suction  # Use Suction end-effector to pick and place cylinders
        self.lang_template = "stack the {color} cylinder on the {target} stand"
        self.task_completed_desc = "done stacking cylinders."

    def reset(self, env):
        super().reset(env)

        # Define the colors for the cylinders
        colors = ['red', 'green', 'blue']
        color_rgb = [utils.COLORS[color] for color in colors]  # Get RGB values for the colors

        # Define the sizes for the cylinders (ascending order)
        sizes = [(0.02, 0.02, 0.08),  # Smallest
                 (0.03, 0.03, 0.12),  # Medium
                 (0.04, 0.04, 0.16)]  # Largest

        # Add stand
        stand_size = (0.05, 0.05, 0.02)  # Size of the stand
        stand_pose = self.get_random_pose(env, stand_size)  # Get a random pose for the stand
        stand_urdf = 'stacking/stand.urdf'
        env.add_object(stand_urdf, stand_pose, 'fixed')  # Add the stand to the environment

        # Add cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []  # Store initial poses of cylinders to use as target poses
        for i in range(3):
            # Get a random pose for the cylinder
            pose = self.get_random_pose(env, sizes[i])
            cylinder_poses.append(pose)

            # Fill in the URDF template for the cylinder
            replace = {'SIZE': sizes[i], 'COLOR': color_rgb[i]}
            urdf = self.fill_template(cylinder_template, replace)

            # Add the cylinder to the environment
            env.add_object(urdf, pose)

        # Add goals for stacking cylinders in ascending order of size
        for i in range(3):
            # Language goal for the current cylinder
            language_goal = self.lang_template.format(color=colors[i], target='small')

            # The target pose is on top of the stand, with each cylinder stacked on the previous one
            z_offset = sum([size[2] for size in sizes[:i]])  # Calculate the cumulative height of the cylinders below
            target_pose = (stand_pose[0], (stand_pose[1][0], stand_pose[1][1], stand_pose[1][2] + z_offset))

            # Add the goal for the current cylinder
            self.add_goal(objs=[i],  # Object index (cylinders are added in order)
                          matches=np.ones((1, 1)),  # Each cylinder has only one correct placement
                          targ_poses=[target_pose],  # Target pose calculated above
                          replace=False,  # Each cylinder has a unique target pose
                          rotations=False,  # Rotation is not considered in this task
                          metric='pose',  # We are using pose metric for precision stacking
                          params=None,  # No additional parameters needed
                          step_max_reward=1 / 3,  # Reward is equally divided among the three goals
                          language_goal=language_goal)  # Language goal for the current cylinder