import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ContainerizedCylinderArrangement(Task):
    """Arrange a set of five differently-sized cylinders inside a container, with the smallest at the bottom and the largest at the top."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to arrange 5 cylinders, so 10 steps should be sufficient
        self.lang_template = "put the {size} cylinder in the container"
        self.task_completed_desc = "done arranging the cylinders."
        self.ee = Suction  # We need to move objects on the Z axis, so Suction is appropriate

    def reset(self, env):
        super().reset(env)

        # Define the number of cylinders and their sizes
        n_cylinders = 5
        cylinder_sizes = np.linspace(0.02, 0.1, n_cylinders)  # Smallest to largest diameters

        # Add container
        container_size = (0.3, 0.3, 0.2)  # Length, width, height of the container
        container_pose = self.get_random_pose(env, container_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': tuple(s / 2 for s in container_size)}
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, container_pose, 'fixed')

        # Add cylinders
        cylinders = []
        cylinder_template = 'cylinder/cylinder-template.urdf'
        for i, size in enumerate(cylinder_sizes):
            # Define the cylinder size and pose
            cylinder_size = (size, size, 0.1)  # Diameter and height
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            replace = {'SIZE': cylinder_size, 'HALF': tuple(s / 2 for s in cylinder_size)}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            color = utils.COLORS['silver']  # All cylinders will be silver
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=color)
            cylinders.append(cylinder_id)

        # Define the language goals and add them to the task
        for i, cylinder_id in enumerate(cylinders):
            size_desc = "smallest" if i == 0 else "largest" if i == n_cylinders - 1 else f"{i+1}-th size"
            language_goal = self.lang_template.format(size=size_desc)
            # The target pose is inside the container, at the bottom for the smallest cylinder
            targ_pose = (container_pose[0], container_pose[1])
            self.add_goal(objs=[cylinder_id], matches=np.ones((1, 1)), targ_poses=[targ_pose], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/n_cylinders,
                          language_goal=language_goal)

        # Note: The cylinders are expected to be arranged from smallest at the bottom to largest at the top
        # within the container. The task does not explicitly encode the order, but the language goals imply it.
        # The reward structure and task completion criteria would need to be more complex to enforce this order.