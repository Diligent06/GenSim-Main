import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class SequentialInsertion(Task):
    """Insert a series of three increasingly smaller boxes into one another."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We have 3 insertions, so max_steps is twice the number of insertions
        self.ee = Suction  # Using Suction end-effector as we need to move objects on the Z axis

        # Language templates for each step
        self.lang_templates = [
            "insert the large red box into the workspace",
            "insert the medium green box into the large red box",
            "insert the small blue box into the medium green box"
        ]
        self.task_completed_desc = "done with sequential insertion."

    def reset(self, env):
        super().reset(env)

        # Define the sizes for the large, medium, and small boxes
        sizes = [
            (0.12, 0.12, 0.12),  # Large box size
            (0.09, 0.09, 0.09),  # Medium box size
            (0.06, 0.06, 0.06)   # Small box size
        ]

        # Define the colors for the large, medium, and small boxes
        colors = [
            utils.COLORS['red'],    # Large box color
            utils.COLORS['green'],  # Medium box color
            utils.COLORS['blue']    # Small box color
        ]

        # Template for the box URDF
        box_template = 'box/box-template.urdf'

        # Initialize a list to store the object IDs and poses
        object_ids = []
        object_poses = []

        # Add boxes to the environment
        for i in range(3):
            # Get a random pose for the box
            pose = self.get_random_pose(env, sizes[i])
            # Fill in the template URDF with the size and color of the box
            replace = {'SIZE': sizes[i], 'COLOR': colors[i]}
            box_urdf = self.fill_template(box_template, replace)
            # Add the box to the environment
            box_id = env.add_object(box_urdf, pose)
            # Store the object ID and pose
            object_ids.append(box_id)
            object_poses.append(pose)

        # Add goals for each insertion step
        for i in range(3):
            # The target pose for the current box is the pose of the next larger box
            # For the largest box, the target pose is its initial pose
            targ_pose = object_poses[i - 1] if i > 0 else object_poses[i]
            # Add the goal for the current box
            self.add_goal(
                objs=[object_ids[i]],  # Current box
                matches=np.ones((1, 1)),  # One-to-one correspondence
                targ_poses=[targ_pose],  # Target pose
                replace=False,  # The box should not be replaced once inserted
                rotations=True,  # Allow rotation for insertion
                metric='pose',  # Use pose metric for evaluation
                params=None,  # No additional parameters
                step_max_reward=1,  # Full reward for completing this step
                language_goal=self.lang_templates[i]  # Language goal for this step
            )

# Instantiate the task
task = SequentialInsertion()