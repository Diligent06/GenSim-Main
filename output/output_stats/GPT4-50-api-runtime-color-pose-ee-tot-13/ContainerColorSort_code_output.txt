import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ContainerColorSort(Task):
    """Sort a set of small colored blocks into containers based on color, with each container accepting only blocks of its designated color."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we'll have 5 goals, 2 steps per goal is reasonable
        self.lang_template = "put the {color} blocks in the {color} container"
        self.task_completed_desc = "done sorting blocks by color."
        self.ee = Suction  # We need to move objects on the Z axis into containers

    def reset(self, env):
        super().reset(env)

        # Define the number of containers and blocks
        n_containers = 3
        n_blocks_per_container = 3

        # Define the colors for the containers and blocks
        container_colors = ['red', 'green', 'blue']
        block_colors = container_colors

        # Add containers with corresponding colors
        container_size = (0.15, 0.15, 0.05)  # Size of the container
        container_urdf = 'container/container-template.urdf'
        containers = []
        for color in container_colors:
            # Get a random pose for the container
            container_pose = self.get_random_pose(env, container_size)
            # Fill the container URDF template with size and color
            replace = {'DIM': container_size, 'HALF': np.array(container_size) / 2, 'COLOR': utils.COLORS[color]}
            container_urdf_filled = self.fill_template(container_urdf, replace)
            # Add the container to the environment
            container_id = env.add_object(container_urdf_filled, container_pose, 'fixed')
            containers.append((container_id, container_pose, color))

        # Add blocks with corresponding colors
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks
        block_urdf = 'stacking/block.urdf'
        for color in block_colors:
            for _ in range(n_blocks_per_container):
                # Get a random pose for the block
                block_pose = self.get_random_pose(env, block_size)
                # Add the block to the environment with the specified color
                block_color = utils.COLORS[color]
                block_id = env.add_object(block_urdf, block_pose, color=block_color)
                
                # Find the corresponding container for this block
                for container_id, container_pose, container_color in containers:
                    if container_color == color:
                        # Define the language goal for this block-container pair
                        language_goal = self.lang_template.format(color=color)
                        # Add the goal for this block to be in the corresponding container
                        self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[container_pose], replace=False,
                                      rotations=False, metric='zone', params=[(container_pose, container_size)], step_max_reward=1/n_blocks_per_container,
                                      language_goal=language_goal)
                        break  # Move on to the next block once the goal is added