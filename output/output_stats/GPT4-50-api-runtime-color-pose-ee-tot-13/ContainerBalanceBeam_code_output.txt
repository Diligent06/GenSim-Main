import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ContainerBalanceBeam(Task):
    """Place a series of differently colored boxes on a narrow stand, arranging them in a balanced fashion so they don't fall off."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we will call self.add_goal 5 times
        self.lang_template = "place the {color} box on the stand"
        self.task_completed_desc = "done placing all boxes in balance."
        self.ee = Suction  # Using Suction end-effector to lift boxes in Z axis

    def reset(self, env):
        super().reset(env)

        # Define the number of boxes and the stand size
        n_boxes = 5
        stand_size = (0.6, 0.04, 0.02)  # A narrow stand

        # Add the stand to the environment
        stand_urdf = 'stacking/stand.urdf'
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object(stand_urdf, stand_pose, category='fixed')

        # Define available colors for the boxes
        colors = ['red', 'green', 'blue', 'yellow', 'purple']
        color_names = [f"{color} box" for color in colors]

        # Add boxes to the environment
        box_template = 'box/box-template.urdf'
        box_size = (0.05, 0.05, 0.05)  # Size of each box
        box_poses = []  # Store initial poses to use as target poses later
        for i in range(n_boxes):
            # Get a random pose for the box
            box_pose = self.get_random_pose(env, box_size)
            box_poses.append(box_pose)

            # Fill the URDF template with the specific color and size for the box
            replace = {'SIZE': box_size, 'HALF': tuple(s / 2 for s in box_size), 'COLOR': utils.COLORS[colors[i]]}
            box_urdf = self.fill_template(box_template, replace)

            # Add the box to the environment
            env.add_object(box_urdf, box_pose)

        # Add goals for placing each box on the stand
        for i in range(n_boxes):
            # Define the language goal for placing the current box
            language_goal = self.lang_template.format(color=color_names[i])

            # The target pose is on the stand with the same orientation as the initial pose
            targ_pose = (stand_pose[0], box_poses[i][1])

            # Add the goal for the current box
            self.add_goal(objs=[i], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/n_boxes,
                          language_goal=language_goal)

        # The task is to place the boxes in a balanced way, so we need to ensure that the boxes do not fall off
        # This is implicitly handled by the physics simulation and the reward function