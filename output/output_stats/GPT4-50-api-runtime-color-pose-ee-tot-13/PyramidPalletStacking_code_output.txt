import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PyramidPalletStacking(Task):
    """
    Stack colored blocks on a pallet in a pyramid configuration 3-2-1,
    ensuring the same colored blocks are not touching each other.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice that
        self.lang_template = "stack the {color} block on the pallet to form a pyramid"
        self.task_completed_desc = "done stacking the pyramid."
        self.ee = Suction  # We need to move objects on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the size and add the pallet.
        pallet_size = (0.15, 0.15, 0.02)  # x, y, z dimensions
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Define block size and URDF.
        block_size = (0.04, 0.04, 0.04)  # x, y, z dimensions
        block_urdf = 'stacking/block.urdf'

        # Define colors for the blocks.
        block_colors = ['red', 'green', 'blue', 'yellow', 'purple', 'orange']
        np.random.shuffle(block_colors)  # Shuffle to ensure random color order

        # Add blocks and store their IDs and colors.
        blocks = []
        for color in block_colors:
            block_pose = self.get_random_pose(env, block_size)
            color_rgb = utils.COLORS[color]
            block_id = env.add_object(block_urdf, block_pose, color=color_rgb)
            blocks.append((block_id, color))

        # Define target poses for the pyramid configuration on the pallet.
        # Positions are relative to the pallet's pose.
        target_positions = [
            (0, -0.05, 0.04),  # Bottom row, left
            (0, 0, 0.04),      # Bottom row, center
            (0, 0.05, 0.04),   # Bottom row, right
            (0, -0.025, 0.08), # Middle row, left
            (0, 0.025, 0.08),  # Middle row, right
            (0, 0, 0.12)       # Top row, center
        ]

        # Create goals for each block to be placed in the pyramid configuration.
        for i, (block_id, color) in enumerate(blocks):
            # Calculate the target pose for the current block.
            target_pose = utils.apply(pallet_pose, target_positions[i])
            # Create the language goal description.
            language_goal = self.lang_template.format(color=color)
            # Add the goal for the current block.
            self.add_goal(
                objs=[block_id],
                matches=np.ones((1, 1)),  # Each block has a unique target pose.
                targ_poses=[target_pose],  # Target pose for the block.
                replace=False,  # Blocks should not be replaced once placed.
                rotations=True,  # Allow rotations for the block placement.
                metric='pose',  # Use pose metric for evaluation.
                params=None,  # No additional parameters needed.
                step_max_reward=1 / len(blocks),  # Reward is split across all blocks.
                language_goal=language_goal  # Language goal description.
            )

        # Note: We assume that the blocks are placed in the correct order,
        # and the same colored blocks are not touching each other as per the shuffled list.