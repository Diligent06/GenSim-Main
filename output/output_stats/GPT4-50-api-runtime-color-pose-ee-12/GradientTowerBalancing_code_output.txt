import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class GradientTowerBalancing(Task):
    """
    Construct a color-gradient tower by sequentially stacking one cylindrical block on top of another from largest to smallest,
    alternating between placing a ball of a matching color on each cylindrical block, without knocking the tower over.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to add 5 goals, so max_steps is set to twice that number
        self.ee = Suction  # Use Suction end-effector to pick and place objects in the Z axis
        self.lang_template = "stack the {color} {object} on top of the {base_object}"
        self.task_completed_desc = "done building the gradient tower."

    def reset(self, env):
        super().reset(env)

        # Define the colors for the gradient tower in order
        colors = ['red', 'orange', 'yellow', 'green', 'blue']
        color_rgb = [utils.COLORS[color] for color in colors]

        # Define sizes for the cylindrical blocks, from largest to smallest
        cylinder_height = 0.04
        cylinder_radii = np.linspace(0.07, 0.03, len(colors))  # Gradually decreasing radii

        # Define size for the balls, which will be constant
        ball_radius = 0.02

        # Initialize lists to store object IDs and target poses
        cylinder_ids = []
        ball_ids = []
        target_poses = []

        # Add cylindrical blocks and balls to the environment
        for i, radius in enumerate(cylinder_radii):
            # Add cylinder
            cylinder_size = (2 * radius, 2 * radius, cylinder_height)  # (dx, dy, dz)
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_template = 'cylinder/cylinder-template.urdf'
            replace = {'DIM': cylinder_size, 'COLOR': color_rgb[i]}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            cylinder_ids.append(cylinder_id)

            # Add ball
            ball_size = (2 * ball_radius, 2 * ball_radius, 2 * ball_radius)  # (dx, dy, dz)
            ball_pose = self.get_random_pose(env, ball_size)
            ball_template = 'ball/ball-template.urdf'
            replace = {'DIM': ball_size, 'COLOR': color_rgb[i]}
            ball_urdf = self.fill_template(ball_template, replace)
            ball_id = env.add_object(ball_urdf, ball_pose)
            ball_ids.append(ball_id)

            # Store the target pose for the cylinder (on top of the previous one)
            z_offset = (i + 1) * cylinder_height if i > 0 else cylinder_height / 2
            target_pose = (cylinder_pose[0], (0, 0, z_offset), cylinder_pose[1])
            target_poses.append(target_pose)

        # Add goals for stacking cylinders and placing balls
        for i in range(len(colors)):
            # Goal for stacking cylinder
            language_goal = self.lang_template.format(color=colors[i], object='cylinder', base_object='base' if i == 0 else 'cylinder')
            self.add_goal(objs=[cylinder_ids[i]], matches=np.ones((1, 1)), targ_poses=[target_poses[i]],
                          replace=False, rotations=True, metric='pose', params=None, step_max_reward=1,
                          language_goal=language_goal)

            # Goal for placing ball on cylinder
            if i > 0:  # Skip the first cylinder as it does not have a ball goal
                ball_target_pose = (target_poses[i-1][0], (0, 0, target_poses[i-1][1][2] + ball_radius + cylinder_height / 2))
                language_goal = self.lang_template.format(color=colors[i-1], object='ball', base_object='cylinder')
                self.add_goal(objs=[ball_ids[i-1]], matches=np.ones((1, 1)), targ_poses=[ball_target_pose],
                              replace=False, rotations=False, metric='pose', params=None, step_max_reward=1,
                              language_goal=language_goal)

        # The last ball goes on top of the last cylinder
        final_ball_target_pose = (target_poses[-1][0], (0, 0, target_poses[-1][1][2] + ball_radius + cylinder_height / 2))
        language_goal = self.lang_template.format(color=colors[-1], object='ball', base_object='cylinder')
        self.add_goal(objs=[ball_ids[-1]], matches=np.ones((1, 1)), targ_poses=[final_ball_target_pose],
                      replace=False, rotations=False, metric='pose', params=None, step_max_reward=1,
                      language_goal=language_goal)