import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ContainerizedCylinderSorting(Task):
    """Pick up five cylinders of different colors and sizes and place each one into a corresponding container marked with a matching color outline on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to call self.add_goal twice, so set max_steps to twice that number
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.lang_template = "put the {color} cylinder in the {color} container"
        self.task_completed_desc = "done sorting cylinders into containers."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the number of cylinders and containers
        n_objects = 5

        # Define colors for cylinders and containers
        colors = ['red', 'green', 'blue', 'yellow', 'purple']
        np.random.shuffle(colors)  # Shuffle colors to ensure randomness

        # Add containers with matching color outlines
        container_size = (0.1, 0.1, 0.05)  # Define a standard size for all containers
        container_template = 'container/container-template.urdf'
        container_poses = []  # To store the poses of the containers

        for i in range(n_objects):
            # Generate a random pose for the container
            container_pose = self.get_random_pose(env, container_size)
            container_poses.append(container_pose)

            # Fill the container URDF template with size and color
            replace = {'DIM': container_size, 'HALF': tuple(s / 2 for s in container_size), 'COLOR': utils.COLORS[colors[i]]}
            container_urdf = self.fill_template(container_template, replace)

            # Add the container object to the environment
            env.add_object(container_urdf, container_pose, 'fixed')

        # Add cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_sizes = [(0.02, 0.02, np.random.uniform(0.05, 0.15)) for _ in range(n_objects)]  # Random heights
        cylinders = []  # To store the IDs of the cylinders

        for i in range(n_objects):
            # Generate a random pose for the cylinder
            cylinder_pose = self.get_random_pose(env, cylinder_sizes[i])
            
            # Fill the cylinder URDF template with size and color
            replace = {'DIM': cylinder_sizes[i], 'HALF': tuple(s / 2 for s in cylinder_sizes[i]), 'COLOR': utils.COLORS[colors[i]]}
            cylinder_urdf = self.fill_template(cylinder_template, replace)

            # Add the cylinder object to the environment
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            cylinders.append(cylinder_id)

        # Define goals for each cylinder to be placed in the matching container
        for i in range(n_objects):
            # Define the language goal for placing the cylinder
            language_goal = self.lang_template.format(color=colors[i])

            # Add the goal for the cylinder to be placed in the matching container
            self.add_goal(objs=[cylinders[i]], matches=np.int32([[1]]), targ_poses=[container_poses[i]], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1,
                          language_goal=language_goal)

# Note: The task assumes that the containers and cylinders are uniquely color-coded and that the agent
# is able to recognize and match these colors to complete the task.