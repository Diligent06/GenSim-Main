import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ColorCoordinatedStacking(Task):
    """Construct a color-coordinated tower on a pallet by alternating stacking of boxes and cylinders with the same color on each level, following a given sequence of colors."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to stack 5 objects, so 10 steps should be sufficient
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.lang_template = "stack the {color} {object} on the {target_object}"
        self.task_completed_desc = "done stacking the color-coordinated tower."

    def reset(self, env):
        super().reset(env)

        # Define the sequence of colors for the stacking task
        color_sequence = ['red', 'green', 'blue', 'yellow', 'purple']
        # Define the size of the boxes and cylinders
        box_size = (0.05, 0.05, 0.05)  # (x, y, z) dimensions
        cylinder_size = (0.05, 0.05, 0.1)  # (radius, height) dimensions

        # Add a pallet to the environment as the base for stacking
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, (0.1, 0.1, 0.05))  # Pallet size is arbitrary
        env.add_object(pallet_urdf, pallet_pose, category='fixed')

        # Initialize lists to keep track of objects and their poses
        boxes = []
        cylinders = []
        object_poses = []

        # Add boxes and cylinders to the environment
        for i, color_name in enumerate(color_sequence):
            color = utils.COLORS[color_name]  # Get the RGB values for the color

            # Add a box
            box_template = 'box/box-template.urdf'
            box_pose = self.get_random_pose(env, box_size)
            replace = {'DIM': box_size, 'COLOR': color}
            box_urdf = self.fill_template(box_template, replace)
            box_id = env.add_object(box_urdf, box_pose)
            boxes.append(box_id)
            object_poses.append(box_pose)

            # Add a cylinder
            cylinder_template = 'cylinder/cylinder-template.urdf'
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            replace = {'DIM': cylinder_size, 'COLOR': color}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            cylinders.append(cylinder_id)
            object_poses.append(cylinder_pose)

        # Define the stacking order and add goals
        for i in range(len(color_sequence)):
            # Alternate between stacking a box and a cylinder
            if i % 2 == 0:
                obj_id = boxes[i // 2]
                object_type = 'box'
            else:
                obj_id = cylinders[i // 2]
                object_type = 'cylinder'

            # The target pose is on top of the previous object or the pallet
            if i == 0:
                # The first object is placed on the pallet
                target_pose = pallet_pose
                target_object = 'pallet'
            else:
                # Subsequent objects are stacked on top of the previous one
                target_pose = object_poses[i - 1]
                target_object = 'previous ' + ('box' if i % 2 == 1 else 'cylinder')

            # Adjust the z-coordinate for the target pose to stack on top
            target_pose = (target_pose[0], (target_pose[1][0], target_pose[1][1], target_pose[1][2] + box_size[2]))

            # Add the goal for the current object
            language_goal = self.lang_template.format(color=color_sequence[i], object=object_type, target_object=target_object)
            self.add_goal(objs=[obj_id], matches=np.ones((1, 1)), targ_poses=[target_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / len(color_sequence),
                          language_goal=language_goal)