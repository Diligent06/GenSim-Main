import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PalletTowerSorting(Task):
    """Sort colored blocks by stacking them onto designated color-matched zones on a pallet."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we will call self.add_goal 5 times
        self.lang_template = "stack the {color} block on the {color} zone on the pallet"
        self.task_completed_desc = "done sorting the blocks on the pallet."
        self.ee = Suction  # Using Suction since we need to move objects on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the number of blocks and zones
        n_blocks = 5
        n_zones = 5

        # Define the size of the blocks and the pallet
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks
        pallet_size = (0.3, 0.3, 0.02)  # Size of the pallet

        # Add pallet to the environment
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Define colors for the blocks and zones
        block_colors = ['red', 'blue', 'green', 'yellow', 'purple']
        zone_colors = block_colors.copy()  # Same colors for zones

        # Add zones to the pallet
        zone_size = (0.1, 0.1, 0)  # Size of the zones
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for i, color in enumerate(zone_colors):
            # Calculate zone position on the pallet
            zone_pose = (pallet_pose[0][0] + (i - 2) * 0.1, pallet_pose[0][1], pallet_pose[0][2] + 0.01)
            zone_full_pose = (zone_pose, pallet_pose[1])
            env.add_object(zone_urdf, zone_full_pose, 'fixed', color=utils.COLORS[color])
            zone_poses.append(zone_full_pose)

        # Add blocks to the environment
        block_urdf = 'stacking/block.urdf'
        blocks = []
        for i, color in enumerate(block_colors):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Add goals for each block to be stacked on the matching color zone
        for i, block_id in enumerate(blocks):
            # Define the target pose for the block on top of the zone
            zone_pose = zone_poses[i]
            targ_pose = (zone_pose[0], (0, 0, 0, 1))  # No rotation needed, blocks are axis-aligned
            language_goal = self.lang_template.format(color=block_colors[i])

            # Add the goal for the current block
            self.add_goal(objs=[block_id], matches=np.ones((1, 1)), targ_poses=[targ_pose], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/n_blocks,
                          language_goal=language_goal)

        # Set the primitive for the task
        self.primitive = primitives.push  # Although we use Suction, we still need to define the primitive