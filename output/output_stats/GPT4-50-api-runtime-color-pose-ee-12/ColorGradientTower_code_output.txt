import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ColorGradientTower(Task):
    """Construct a color-gradient tower using colored cylinders by stacking them in order of their hues,
    from red at the bottom to violet on top, ensuring each cylinder is upright and aligned within the center of the previous one."""

    def __init__(self):
        super().__init__()
        self.max_steps = 14  # 7 colors, hence 7 goals, max_steps is twice the number of goals
        self.lang_template = "stack the {color} cylinder on top of the {prev_color} one"
        self.task_completed_desc = "done building the color-gradient tower."
        self.ee = Suction  # Suction end-effector is needed to lift cylinders in Z-axis
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors in the order of the color gradient (from bottom to top of the tower)
        color_names = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']
        colors = [utils.COLORS[name] for name in color_names]

        # Define the size of the cylinders
        cylinder_size = (0.04, 0.04, 0.08)  # (radius, radius, height)

        # Add target zone where the tower will be built
        zone_size = (0.15, 0.15, 0)  # (x_size, y_size, z_size)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add cylinders in the environment with the specified colors
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for i, color in enumerate(colors):
            # Get a random pose for the cylinder
            pose = self.get_random_pose(env, cylinder_size)
            replace = {'COLOR': color, 'SIZE': cylinder_size}
            # Fill the cylinder URDF template with color and size
            urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder to the environment
            cylinder_id = env.add_object(urdf, pose)
            cylinders.append(cylinder_id)

            # Define the language goal for stacking this cylinder
            prev_color = 'the base' if i == 0 else color_names[i - 1]
            language_goal = self.lang_template.format(color=color_names[i], prev_color=prev_color)

            # The target pose is the same as the zone pose but with increasing height for each cylinder
            target_pose = (zone_pose[0], zone_pose[1])  # Use the zone pose as the base pose
            target_pose[0][2] += i * cylinder_size[2]  # Increase z-coordinate for height

            # Add the goal for this cylinder
            self.add_goal(
                objs=[cylinder_id],
                matches=np.ones((1, 1)),  # Each cylinder has a unique place
                targ_poses=[target_pose],  # Target pose where the cylinder should be placed
                replace=False,  # Cylinders should not be replaced once placed
                rotations=False,  # No need for rotations, cylinders are symmetrical
                metric='pose',  # We are using pose metric for the placement
                params=None,  # No additional parameters needed
                step_max_reward=1 / len(colors),  # Reward is equally distributed across steps
                language_goal=language_goal  # Language goal for the current step
            )