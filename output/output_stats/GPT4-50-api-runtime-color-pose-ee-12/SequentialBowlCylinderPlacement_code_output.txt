import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class SequentialBowlCylinderPlacement(Task):
    """Place a series of five colored cylinders into bowls of the same color sequentially."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We have 5 goals, so max_steps is set to twice the number of goals
        self.lang_template = "place the {color} cylinder in the {color} bowl"
        self.task_completed_desc = "all cylinders placed in the corresponding bowls."
        self.ee = Suction  # Using Suction end-effector to pick and place cylinders

    def reset(self, env):
        super().reset(env)

        # Define the size of the bowls and cylinders
        bowl_size = (0.18, 0.18, 0.06)  # (x, y, z) dimensions
        cylinder_height = 0.15  # Height of the tallest cylinder
        cylinder_radius = 0.05  # Radius of the base of the cylinders

        # Define the colors for the cylinders and bowls
        colors = ['red', 'green', 'blue', 'yellow', 'purple']
        color_rgb = [utils.COLORS[color] for color in colors]

        # Add bowls to the environment
        bowls = []
        for i, color in enumerate(colors):
            bowl_pose = self.get_random_pose(env, bowl_size)
            bowl_urdf = 'bowl/bowl.urdf'
            bowl_id = env.add_object(bowl_urdf, bowl_pose, color=color_rgb[i])
            bowls.append((bowl_id, bowl_pose))

        # Add cylinders to the environment
        cylinders = []
        for i, color in enumerate(colors):
            # Gradually decrease the size of the cylinders
            size = (cylinder_radius * (1 - 0.1 * i), cylinder_height * (1 - 0.1 * i))
            cylinder_template = 'cylinder/cylinder-template.urdf'
            replace = {'SIZE': size}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_pose = self.get_random_pose(env, size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=color_rgb[i])
            cylinders.append((cylinder_id, cylinder_pose))

        # Add goals for placing cylinders into the corresponding bowls
        for i, (cylinder_id, _) in enumerate(cylinders):
            _, bowl_pose = bowls[i]
            # The target pose for the cylinder is the pose of the bowl with an adjusted z-coordinate
            target_pose = (bowl_pose[0], (0, 0, 0, 1))  # No rotation needed, cylinder stands upright
            language_goal = self.lang_template.format(color=colors[i])
            self.add_goal(objs=[cylinder_id], matches=np.ones((1, 1)), targ_poses=[target_pose],
                          replace=True, rotations=False, metric='pose', params=None,
                          step_max_reward=1, language_goal=language_goal)

# Comment: The task is designed to sequentially place cylinders into bowls of matching colors.
# The cylinders decrease in size to simulate a sequence from smallest to largest.
# The Suction end-effector is used to pick and place the cylinders.
# The target pose for each cylinder is derived from the corresponding bowl's pose.
# The language goal is dynamically generated to match the color of the current cylinder and bowl.
# The `step_max_reward` is set to 1 for each goal since there is only one goal at each step.