import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CascadeCylinderArrangement(Task):
    """Arrange cylinders in ascending order of height along a green line."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to call self.add_goal 5 times, so set max_steps to twice that number
        self.lang_template = "place the {color} cylinder on the green line in {position} position"
        self.task_completed_desc = "done arranging the cylinders."
        self.ee = Suction  # Use Suction end-effector to pick and place cylinders vertically

    def reset(self, env):
        super().reset(env)

        # Define the number of cylinders and their colors
        n_cylinders = 5
        colors = ['red', 'orange', 'yellow', 'green', 'blue']

        # Add the green line to the environment
        line_size = (0.01, 0.5, 0.001)  # Thin and long line
        line_pose = self.get_random_pose(env, line_size)
        line_template = 'line/single-green-line-template.urdf'
        replace = {'DIM': line_size}
        line_urdf = self.fill_template(line_template, replace)
        env.add_object(line_urdf, line_pose, 'fixed')

        # Add cylinders with increasing heights
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_radius = 0.02  # Fixed radius for all cylinders
        min_height = 0.05
        max_height = 0.15
        height_step = (max_height - min_height) / (n_cylinders - 1)

        # Store cylinder IDs and target poses
        cylinders = []
        target_poses = []

        for i in range(n_cylinders):
            # Calculate the height of the cylinder
            height = min_height + i * height_step
            size = (2 * cylinder_radius, 2 * cylinder_radius, height)

            # Get a random pose for the cylinder
            pose = self.get_random_pose(env, size)

            # Set the color of the cylinder
            color_name = colors[i]
            color_rgb = utils.COLORS[color_name]

            # Replace the placeholders in the URDF template
            replace = {
                'DIM': size,
                'HALF': (size[0] / 2, size[1] / 2, size[2] / 2),
                'COLOR': color_rgb,
            }
            cylinder_urdf = self.fill_template(cylinder_template, replace)

            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, pose)
            cylinders.append(cylinder_id)

            # Calculate the target pose on the green line
            # The x-coordinate is fixed, y-coordinate is based on the position along the line, z is the base height
            target_x = line_pose[0][0]
            target_y = line_pose[0][1] - line_size[1] / 2 + (i + 0.5) * (line_size[1] / n_cylinders)
            target_z = line_pose[0][2] + height / 2  # Base of the cylinder should touch the line
            target_pose = [(target_x, target_y, target_z), (0, 0, 0, 1)]  # No rotation needed, keep upright
            target_poses.append(target_pose)

            # Add language goal
            position = ['first', 'second', 'third', 'fourth', 'fifth'][i]
            language_goal = self.lang_template.format(color=color_name, position=position)

            # Add goal for each cylinder
            self.add_goal(
                objs=[cylinder_id],
                matches=np.ones((1, 1)),  # Each cylinder has a unique target
                targ_poses=[target_pose],
                replace=False,  # Each cylinder has a unique target
                rotations=False,  # Cylinders should remain upright
                metric='pose',
                params=None,
                step_max_reward=1 / n_cylinders,  # Equal reward for each cylinder
                language_goal=language_goal
            )