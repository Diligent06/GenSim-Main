import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PalletRingTower(Task):
    """Construct a tower by stacking three rings of decreasing sizes onto a cylindrical stand,
    with the largest ring at the bottom and the smallest at the top, then cap the tower with a ball,
    all positioned on a designated pallet zone."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = "stack the {color} ring on the {target}"
        self.task_completed_desc = "done constructing the ring tower."
        self.ee = Suction  # Use Suction end-effector to pick and place objects in 3D space
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors for the rings and ball
        ring_colors = [utils.COLORS['red'], utils.COLORS['green'], utils.COLORS['blue']]
        ball_color = utils.COLORS['yellow']

        # Define sizes for the rings (large, medium, small) and ball
        ring_sizes = [(0.12, 0.12, 0.02), (0.1, 0.1, 0.02), (0.08, 0.08, 0.02)]
        ball_size = (0.04, 0.04, 0.04)

        # Add pallet zone
        zone_size = (0.3, 0.3, 0)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add cylindrical stand
        stand_size = (0.05, 0.05, 0.15)
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object('stacking/stand.urdf', stand_pose, 'fixed')

        # Add rings and ball
        ring_ids = []
        for i, size in enumerate(ring_sizes):
            ring_pose = self.get_random_pose(env, size)
            ring_urdf = 'cylinder/cylinder-template.urdf'
            replace = {'DIM': size, 'HALF': (size[0] / 2, size[1] / 2, size[2] / 2)}
            ring_urdf = self.fill_template(ring_urdf, replace)
            ring_id = env.add_object(ring_urdf, ring_pose, color=ring_colors[i])
            ring_ids.append(ring_id)

        ball_pose = self.get_random_pose(env, ball_size)
        ball_urdf = 'ball/ball-template.urdf'
        replace = {'DIM': ball_size, 'HALF': (ball_size[0] / 2, ball_size[1] / 2, ball_size[2] / 2)}
        ball_urdf = self.fill_template(ball_urdf, replace)
        ball_id = env.add_object(ball_urdf, ball_pose, color=ball_color)

        # Define target poses for the rings and ball on the stand
        target_poses = [
            (stand_pose[0], stand_pose[1]),  # Bottom ring
            (stand_pose[0], stand_pose[1]),  # Middle ring
            (stand_pose[0], stand_pose[1]),  # Top ring
            (stand_pose[0], stand_pose[1])   # Ball
        ]

        # Adjust z-coordinate for stacking
        z_offset = 0.02  # Thickness of each ring
        for i in range(3):
            target_poses[i] = (target_poses[i][0], (target_poses[i][1][0], target_poses[i][1][1], target_poses[i][1][2] + (i + 1) * z_offset, target_poses[i][1][3]))
        # Place the ball on top of the rings
        target_poses[3] = (target_poses[3][0], (target_poses[3][1][0], target_poses[3][1][1], target_poses[3][1][2] + 3 * z_offset + ball_size[2], target_poses[3][1][3]))

        # Add goals for each ring and the ball
        for i, ring_id in enumerate(ring_ids):
            language_goal = self.lang_template.format(color=ring_colors[i], target="stand")
            self.add_goal(objs=[ring_id], matches=np.ones((1, 1)), targ_poses=[target_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / (len(ring_ids) + 1),
                          language_goal=language_goal)

        # Add goal for the ball
        language_goal = "place the yellow ball on top of the tower"
        self.add_goal(objs=[ball_id], matches=np.ones((1, 1)), targ_poses=[target_poses[3]], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1 / (len(ring_ids) + 1),
                      language_goal=language_goal)