import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ColorBlockTower(Task):
    """Create a stable tower by stacking a red cylinder, a green block, and a blue ball in sequence on a flat surface."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is set to twice that number
        self.lang_template = "stack a {color} {shape} on the {surface}"
        self.task_completed_desc = "done building the color block tower."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector

    def reset(self, env):
        super().reset(env)

        # Define the colors and shapes for the objects
        colors = {'red': utils.COLORS['red'], 'green': utils.COLORS['green'], 'blue': utils.COLORS['blue']}
        shapes = ['cylinder', 'block', 'ball']
        urdfs = {
            'cylinder': 'cylinder/cylinder-template.urdf',
            'block': 'stacking/block.urdf',
            'ball': 'ball/ball-template.urdf'
        }

        # Define sizes for the objects
        sizes = {
            'cylinder': (0.04, 0.04, 0.1),  # (radius, radius, height)
            'block': (0.04, 0.04, 0.04),    # (x, y, z)
            'ball': (0.04, 0.04, 0.04)      # (radius, radius, radius)
        }

        # Add objects to the environment
        objects = {}
        for shape in shapes:
            size = sizes[shape]
            pose = self.get_random_pose(env, size)
            color = colors[shape.split()[0]]  # Extract color from shape name
            urdf = urdfs[shape]
            obj_id = env.add_object(urdf, pose, color=color)
            objects[shape] = obj_id

        # Define target poses for the objects
        # The target pose for the first object (cylinder) is its initial pose
        # The target poses for the block and ball are on top of the previous object
        targ_poses = [env.get_pose(objects['cylinder'])]  # Get the initial pose of the cylinder
        targ_poses.append((targ_poses[0][0], (0, 0, 0, 1)))  # Place block on top of cylinder
        targ_poses.append((targ_poses[1][0], (0, 0, 0, 1)))  # Place ball on top of block

        # Adjust z-coordinates for stacking
        targ_poses[1][0][2] += sizes['cylinder'][2]  # Block on top of cylinder
        targ_poses[2][0][2] += sizes['cylinder'][2] + sizes['block'][2]  # Ball on top of block

        # Add goals for stacking the objects
        # Goal 1: Place the red cylinder on the surface
        self.add_goal(objs=[objects['cylinder']], matches=np.ones((1, 1)), targ_poses=[targ_poses[0]],
                      replace=False, rotations=True, metric='pose', params=None, step_max_reward=1,
                      language_goal=self.lang_template.format(color='red', shape='cylinder', surface='surface'))

        # Goal 2: Stack the green block on the red cylinder
        self.add_goal(objs=[objects['block']], matches=np.ones((1, 1)), targ_poses=[targ_poses[1]],
                      replace=False, rotations=True, metric='pose', params=None, step_max_reward=1,
                      language_goal=self.lang_template.format(color='green', shape='block', surface='red cylinder'))

        # Goal 3: Stack the blue ball on the green block
        self.add_goal(objs=[objects['ball']], matches=np.ones((1, 1)), targ_poses=[targ_poses[2]],
                      replace=False, rotations=True, metric='pose', params=None, step_max_reward=1,
                      language_goal=self.lang_template.format(color='blue', shape='ball', surface='green block'))