import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Spatula

class CylinderPalletMaze(Task):
    """Create a maze pathway on the tabletop using colored cylinders, leading to a specific zone on the pallet,
    then navigate a ball through the maze to rest within that zone without disturbing the cylinder arrangement."""

    def __init__(self):
        super().__init__()
        self.max_steps = 4  # We will have two main goals, so set max_steps to twice that number
        self.lang_template = "navigate the ball through the maze to the {color} zone"
        self.task_completed_desc = "done navigating the ball through the maze."
        self.primitive = primitives.push  # We will use the push primitive to navigate the ball
        self.ee = Spatula  # Spatula is suitable for pushing the ball in a 2D plane
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors for the cylinders and the ball
        cylinder_color = utils.COLORS['blue']  # Blue cylinders
        ball_color = utils.COLORS['red']  # Red ball
        zone_color = utils.COLORS['green']  # Green zone

        # Add the pallet object
        pallet_size = (0.3, 0.3, 0.02)  # Define the size of the pallet
        pallet_pose = self.get_random_pose(env, pallet_size)  # Get a random pose for the pallet
        pallet_urdf = 'pallet/pallet.urdf'
        env.add_object(pallet_urdf, pallet_pose, 'fixed')  # Add the pallet as a fixed object

        # Add the zone on the pallet where the ball must be navigated to
        zone_size = (0.1, 0.1, 0)  # Define the size of the zone
        # The zone pose should be on the pallet, so we use the pallet pose and adjust the z-coordinate
        zone_pose = (pallet_pose[0], (pallet_pose[1][0], pallet_pose[1][1], pallet_pose[1][2] + pallet_size[2]))
        zone_urdf = 'zone/zone.urdf'
        env.add_object(zone_urdf, zone_pose, 'fixed', color=zone_color)  # Add the zone as a fixed object

        # Add cylinders to create the maze
        cylinder_size = (0.02, 0.02, 0.1)  # Define the size of the cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        num_cylinders = 10  # Define the number of cylinders to create the maze
        for _ in range(num_cylinders):
            cylinder_pose = self.get_random_pose(env, cylinder_size)  # Get a random pose for each cylinder
            replace = {'COLOR': cylinder_color}
            cylinder_urdf = self.fill_template(cylinder_template, replace)  # Fill the template with the color
            env.add_object(cylinder_urdf, cylinder_pose)  # Add the cylinder as a non-fixed object

        # Add the ball that needs to be navigated through the maze
        ball_size = (0.04, 0.04, 0.04)  # Define the size of the ball
        ball_pose = self.get_random_pose(env, ball_size)  # Get a random pose for the ball
        ball_template = 'ball/ball-template.urdf'
        replace = {'COLOR': ball_color}
        ball_urdf = self.fill_template(ball_template, replace)  # Fill the template with the color
        ball_id = env.add_object(ball_urdf, ball_pose)  # Add the ball as a non-fixed object

        # Define the goal for the task
        # The ball must be navigated to the zone without disturbing the cylinder arrangement
        language_goal = self.lang_template.format(color="green")
        self.add_goal(objs=[ball_id], matches=np.int32([[1]]), targ_poses=[zone_pose], replace=False,
                      rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1,
                      language_goal=language_goal)