import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PalletJenga(Task):
    """
    Carefully extract and reposition a single randomly colored block from the lower layers
    without toppling the tower of multicolored blocks stacked in a jenga-like fashion on a pallet.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 2  # One step to extract and one step to reposition
        self.lang_template = "move the {color} block from the pallet to the target zone"
        self.task_completed_desc = "done with pallet-jenga."
        self.ee = Suction  # Use Suction end-effector to pick and place blocks

    def reset(self, env):
        super().reset(env)

        # Define the size of the pallet and blocks
        pallet_size = (0.3, 0.3, 0.02)  # x, y, z dimensions for the pallet
        block_size = (0.04, 0.04, 0.12)  # x, y, z dimensions for the blocks

        # Add the pallet to the environment
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Define the number of blocks and their colors
        n_blocks = 9  # Total number of blocks in the jenga tower
        block_urdf = 'stacking/block.urdf'
        block_colors = [utils.COLORS[color] for color in utils.COLORS.keys() if color != 'white']

        # Add blocks to form the jenga tower
        blocks = []
        for i in range(n_blocks):
            # Get a random color for the block
            color = block_colors[i % len(block_colors)]
            # Calculate the position of the block in the tower
            level = i // 3
            position_in_level = i % 3
            x = pallet_pose[0][0] + (position_in_level - 1) * block_size[0]
            y = pallet_pose[0][1]
            z = pallet_pose[0][2] + pallet_size[2] + level * block_size[2]
            block_pose = ((x, y, z), pallet_pose[1])
            # Add the block to the environment
            block_id = env.add_object(block_urdf, block_pose, color=color)
            blocks.append(block_id)

        # Choose a random block from the lower two levels to be moved
        movable_blocks = blocks[:6]  # Only blocks from the first two levels
        block_to_move = np.random.choice(movable_blocks)

        # Define the target zone for the block to be moved to
        target_size = (0.05, 0.05, 0.01)  # Size of the target zone
        target_pose = self.get_random_pose(env, target_size)

        # Add the target zone to the environment
        env.add_object('zone/zone.urdf', target_pose, 'fixed')

        # Define the language goal
        block_color_name = [name for name, color in utils.COLORS.items() if color == env.get_object_color(block_to_move)][0]
        language_goal = self.lang_template.format(color=block_color_name)

        # Add the goal for the task
        self.add_goal(objs=[block_to_move], matches=np.ones((1, 1)), targ_poses=[target_pose[0]], replace=False,
                      rotations=False, metric='pose', params=None, step_max_reward=1, language_goal=language_goal)