import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class SequentialBowlPyramid(Task):
    """
    Stack three differently colored bowls in ascending size order to form an inverted pyramid on the pallet,
    then place a differently colored ball on top of the smallest bowl without toppling the structure.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 8  # We will have 4 goals, so max_steps is set to twice the number of goals
        self.lang_template = "stack the {color} bowl"
        self.task_completed_desc = "done stacking the bowl pyramid."
        self.ee = Suction  # Using Suction since we need to move objects on the Z axis
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors for the bowls and the ball
        bowl_colors = ['red', 'green', 'blue']
        ball_color = 'yellow'

        # Define the sizes for the bowls (ascending order)
        bowl_sizes = [(0.12, 0.12, 0.06), (0.15, 0.15, 0.08), (0.18, 0.18, 0.10)]

        # Add pallet
        pallet_size = (0.3, 0.3, 0.02)
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object('pallet/pallet.urdf', pallet_pose, category='fixed')

        # Add bowls and ball
        bowls = []
        for i, size in enumerate(bowl_sizes):
            # Get a random pose for the bowl
            pose = self.get_random_pose(env, size)
            # Add the bowl to the environment
            bowl_urdf = 'bowl/bowl.urdf'
            color = utils.COLORS[bowl_colors[i]]
            bowl_id = env.add_object(bowl_urdf, pose, color=color)
            bowls.append((bowl_id, pose))

        # Add the ball
        ball_size = (0.06, 0.06, 0.06)
        ball_pose = self.get_random_pose(env, ball_size)
        ball_template = 'ball/ball-template.urdf'
        replace = {'COLOR': utils.COLORS[ball_color]}
        ball_urdf = self.fill_template(ball_template, replace)
        ball_id = env.add_object(ball_urdf, ball_pose)

        # Define the target poses for the bowls on the pallet
        # The bowls are stacked in ascending size order to form an inverted pyramid
        target_poses = [
            (pallet_pose[0], pallet_pose[1]),  # Base bowl on the pallet
            utils.apply(pallet_pose, (0, 0, bowl_sizes[0][2])),  # Middle bowl on top of the base bowl
            utils.apply(pallet_pose, (0, 0, bowl_sizes[0][2] + bowl_sizes[1][2])),  # Top bowl on top of the middle bowl
        ]

        # Add goals for stacking the bowls
        for i, (bowl_id, _) in enumerate(bowls):
            language_goal = self.lang_template.format(color=bowl_colors[i])
            self.add_goal(objs=[bowl_id], matches=np.ones((1, 1)), targ_poses=[target_poses[i]],
                          replace=False, rotations=True, metric='pose', params=None,
                          step_max_reward=1 / 4, language_goal=language_goal)

        # Add goal for placing the ball on top of the smallest bowl
        ball_target_pose = utils.apply(target_poses[-1], (0, 0, bowl_sizes[-1][2]))
        language_goal = "place the yellow ball on top of the smallest bowl"
        self.add_goal(objs=[ball_id], matches=np.ones((1, 1)), targ_poses=[ball_target_pose],
                      replace=False, rotations=False, metric='pose', params=None,
                      step_max_reward=1 / 4, language_goal=language_goal)