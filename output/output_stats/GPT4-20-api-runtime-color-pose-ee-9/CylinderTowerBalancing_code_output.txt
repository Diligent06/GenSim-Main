import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderTowerBalancing(Task):
    """Sequentially stack five differently colored cylinders onto a stand, with the largest at the base and the smallest at the top, forming a stable gradient tower without any toppling."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We have 5 cylinders to stack, so 10 steps should be sufficient
        self.lang_template = "stack the {color} cylinder on the {place}"
        self.task_completed_desc = "done stacking the cylinder tower."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector

    def reset(self, env):
        super().reset(env)

        # Define the colors for the cylinders
        colors = ['red', 'orange', 'yellow', 'green', 'blue']
        color_names = [utils.COLORS[color] for color in colors]  # Get the RGB values for the colors

        # Add the stand
        stand_size = (0.05, 0.05, 0.005)  # Size of the stand
        stand_urdf = 'stacking/stand.urdf'
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object(stand_urdf, stand_pose, category='fixed')

        # Add cylinders with decreasing sizes
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_sizes = [(0.04 - i*0.005, 0.04 - i*0.005, 0.08) for i in range(5)]  # Decreasing sizes
        cylinder_poses = []
        cylinder_ids = []

        for i, size in enumerate(cylinder_sizes):
            # Get a random pose for the cylinder
            pose = self.get_random_pose(env, size)
            cylinder_poses.append(pose)

            # Fill in the URDF template for the cylinder
            replace = {'SIZE': size, 'COLOR': color_names[i]}
            urdf = self.fill_template(cylinder_template, replace)

            # Add the cylinder to the environment
            cylinder_id = env.add_object(urdf, pose)
            cylinder_ids.append(cylinder_id)

        # Define the target poses for the cylinders on the stand
        targ_poses = []
        z_offset = stand_size[2]  # Start stacking from the top of the stand
        for size in cylinder_sizes:
            z_offset += size[2] / 2  # Increment z_offset by half the height of the cylinder
            targ_pose = (stand_pose[0], (0, 0, z_offset), stand_pose[1])  # Target pose on the stand
            targ_poses.append(targ_pose)
            z_offset += size[2] / 2  # Increment z_offset for the next cylinder

        # Add goals for each cylinder
        for i, (cylinder_id, targ_pose) in enumerate(zip(cylinder_ids, targ_poses)):
            # Language goal describes the action to be taken
            language_goal = self.lang_template.format(color=colors[i], place="stand" if i == 0 else f"{colors[i-1]} cylinder")
            # Add the goal with the target pose
            self.add_goal(objs=[cylinder_id], matches=np.ones((1, 1)), targ_poses=[targ_pose], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/5, language_goal=language_goal)