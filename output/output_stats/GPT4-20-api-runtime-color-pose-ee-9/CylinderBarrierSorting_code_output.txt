import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderBarrierSorting(Task):
    """Pick up colored cylinders and place them on the opposite side of a row of boxes,
    using the boxes as barriers that segregate cylinders by color."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we will call self.add_goal 5 times
        self.lang_template = "place the {color} cylinder on the other side of the boxes"
        self.task_completed_desc = "done sorting cylinders."
        self.ee = Suction  # Using Suction since we need to move objects on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the number of cylinders and boxes
        n_cylinders = 5
        n_boxes = n_cylinders - 1  # One less box than cylinders to create barriers

        # Define cylinder and box sizes
        cylinder_size = (0.04, 0.04, 0.1)  # (x, y, z) dimensions
        box_size = (0.1, 0.1, 0.05)  # (x, y, z) dimensions

        # Define cylinder and box URDF templates
        cylinder_template = 'cylinder/cylinder-template.urdf'
        box_template = 'box/box-template.urdf'

        # Define colors for the cylinders
        colors = ['red', 'green', 'blue', 'yellow', 'purple']
        color_names = [utils.COLORS[color] for color in colors]

        # Add cylinders with random poses and colors
        cylinders = []
        for i in range(n_cylinders):
            pose = self.get_random_pose(env, cylinder_size)
            replace = {'COLOR': color_names[i]}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_id = env.add_object(cylinder_urdf, pose)
            cylinders.append((cylinder_id, pose, colors[i]))

        # Add boxes as barriers with fixed poses in a row
        box_x_positions = np.linspace(0.35, 0.65, n_boxes)  # Evenly spaced along the x-axis
        for i, x in enumerate(box_x_positions):
            pose = ((x, 0, 0.025), (0, 0, 0, 1))  # Fixed y and z, no rotation
            box_urdf = self.fill_template(box_template, {'DIM': box_size})
            env.add_object(box_urdf, pose, 'fixed')

        # Add a zone on the opposite side of the boxes for the cylinders to be placed in
        zone_size = (0.1, 0.5, 0)  # Span the y-axis
        zone_pose = ((0.85, 0, 0), (0, 0, 0, 1))  # Fixed x and z, no rotation
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Define goals for each cylinder to be placed in the zone on the opposite side of the boxes
        for cylinder_id, initial_pose, color in cylinders:
            language_goal = self.lang_template.format(color=color)
            # Target pose is the same y and z as initial, but x is on the opposite side of the boxes
            target_pose = ((0.85, initial_pose[0][1], initial_pose[0][2]), initial_pose[1])
            self.add_goal(objs=[cylinder_id], matches=np.int32([[1]]), targ_poses=[target_pose], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/n_cylinders,
                          language_goal=language_goal)

# Note: The task assumes that the workspace is set up such that the x-axis is the direction
# in which the cylinders need to be moved across the boxes, and the y-axis is along the row of boxes.
# The z-axis is vertical. The zone is placed at an x-coordinate of 0.85, which is on the opposite side
# of the boxes from the starting x-coordinates of the cylinders.