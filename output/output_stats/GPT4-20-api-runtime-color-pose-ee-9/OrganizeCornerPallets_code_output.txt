import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class OrganizeCornerPallets(Task):
    """Arrange four different colored boxes into corresponding color-coded corners on the tabletop using a designated pallet as an intermediary."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to call self.add_goal twice, so we set this to twice that number
        self.lang_template = "put the {color} box in the {color} corner"
        self.task_completed_desc = "done organizing corner pallets."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors for the boxes and corners
        box_colors = ['blue', 'red', 'green', 'yellow']
        corner_colors = box_colors.copy()  # Same colors for corners

        # Add pallet in the center of the workspace
        pallet_size = (0.3, 0.3, 0.05)  # Size of the pallet
        pallet_pose = self.get_random_pose(env, pallet_size)
        pallet_urdf = 'pallet/pallet.urdf'
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Add boxes and corners
        boxes = []
        corners = []
        for i in range(4):
            # Add box
            box_size = (0.05, 0.05, 0.05)  # Size of the box
            box_pose = self.get_random_pose(env, box_size)
            box_template = 'box/box-template.urdf'
            box_color = utils.COLORS[box_colors[i]]
            replace = {'SIZE': box_size, 'COLOR': box_color}
            box_urdf = self.fill_template(box_template, replace)
            box_id = env.add_object(box_urdf, box_pose)
            boxes.append((box_id, box_pose))  # Store box id and initial pose

            # Add corner
            corner_size = (0.1, 0.1, 0.01)  # Size of the corner
            corner_pose = self.get_random_pose(env, corner_size)
            corner_template = 'corner/corner-template.urdf'
            corner_color = utils.COLORS[corner_colors[i]]
            replace = {'SIZE': corner_size, 'COLOR': corner_color}
            corner_urdf = self.fill_template(corner_template, replace)
            env.add_object(corner_urdf, corner_pose, 'fixed')
            corners.append(corner_pose)  # Store corner pose

        # Define goals for moving boxes to the pallet, then to the corners
        for i, (box_id, box_initial_pose) in enumerate(boxes):
            # First goal: move box to the pallet
            language_goal = self.lang_template.format(color=box_colors[i]) + " on the pallet"
            self.add_goal(objs=[box_id], matches=np.int32([[1]]), targ_poses=[pallet_pose], replace=True,
                          rotations=True, metric='pose', params=None, step_max_reward=0.5, language_goal=language_goal)

            # Second goal: move box from the pallet to the corresponding corner
            language_goal = self.lang_template.format(color=box_colors[i])
            self.add_goal(objs=[box_id], matches=np.int32([[1]]), targ_poses=[corners[i]], replace=True,
                          rotations=True, metric='pose', params=None, step_max_reward=0.5, language_goal=language_goal)

# Note: The task assumes that the robot can pick and place the boxes onto the pallet and then into the corners.
# The Suction end-effector is used because we need to lift the boxes. The pallet serves as an intermediary
# location to simplify the task into two steps: first moving the boxes onto the pallet, then to the corners.
# The step_max_reward is set to 0.5 for each step, summing to a total of 1 when both steps are completed for a box.