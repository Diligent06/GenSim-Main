import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BowlBalancingBlocks(Task):
    """Balance a stack of three uniquely colored blocks on top of an inverted bowl without the stack falling over for a set duration."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We have 3 blocks to place, so max_steps is twice the number of blocks
        self.lang_template = "balance the {color} block on the {surface}"
        self.task_completed_desc = "done balancing blocks."
        self.ee = Suction  # Using Suction since we need to move objects on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the size of the bowl and blocks
        bowl_size = (0.18, 0.18, 0.06)  # x, y, z dimensions for the bowl
        block_size = (0.04, 0.04, 0.04)  # x, y, z dimensions for the blocks

        # Add an inverted bowl to the environment
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_pose = self.get_random_pose(env, bowl_size)
        bowl_id = env.add_object(bowl_urdf, bowl_pose, 'fixed')

        # Define colors for the blocks
        block_colors = ['red', 'green', 'blue']
        block_ids = []

        # Add three blocks with unique colors to the environment
        block_urdf = 'stacking/block.urdf'
        for color in block_colors:
            block_pose = self.get_random_pose(env, block_size)
            color_rgb = utils.COLORS[color]
            block_id = env.add_object(block_urdf, block_pose, color=color_rgb)
            block_ids.append(block_id)

        # Define the target poses for the blocks on top of the inverted bowl
        # The blocks should be stacked, so we adjust the z-coordinate accordingly
        targ_poses = [
            (bowl_pose[0], bowl_pose[1]),  # First block on the bowl
            (bowl_pose[0], bowl_pose[1]),  # Second block on top of the first
            (bowl_pose[0], bowl_pose[1])   # Third block on top of the second
        ]
        targ_poses[1][0][2] += block_size[2]  # Adjust z-coordinate for the second block
        targ_poses[2][0][2] += 2 * block_size[2]  # Adjust z-coordinate for the third block

        # Add goals for each block
        for i, block_id in enumerate(block_ids):
            language_goal = self.lang_template.format(color=block_colors[i], surface="inverted bowl")
            self.add_goal(
                objs=[block_id],
                matches=np.ones((1, 1)),
                targ_poses=[targ_poses[i]],
                replace=False,
                rotations=False,  # No need for rotations as blocks are axis-aligned
                metric='pose',
                params=None,
                step_max_reward=1 / len(block_ids),  # Reward is evenly distributed across blocks
                language_goal=language_goal
            )