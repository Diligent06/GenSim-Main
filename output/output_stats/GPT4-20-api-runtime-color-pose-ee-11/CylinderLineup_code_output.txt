import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderLineup(Task):
    """Arrange a series of differently colored cylinders in a straight line on the tabletop, 
    each cylinder touching the next one, with colors alternating between red and green."""

    def __init__(self):
        super().__init__()
        self.max_steps = 4  # We expect to call self.add_goal twice, so set max_steps to twice that number
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.lang_template = "line up the {color} cylinder next to the {other_color} one"
        self.task_completed_desc = "done arranging the cylinders."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Number of cylinders to line up
        n_cylinders = 2  # We will have one red and one green cylinder

        # Cylinder size
        cylinder_size = (0.05, 0.05, 0.1)  # Diameter, Diameter, Height

        # Cylinder URDF template
        cylinder_template = 'cylinder/cylinder-template.urdf'

        # Colors for the cylinders
        red_color = utils.COLORS['red']
        green_color = utils.COLORS['green']

        # Add cylinders to the environment
        cylinders = []
        for i in range(n_cylinders):
            # Alternate colors
            color = red_color if i % 2 == 0 else green_color
            color_name = 'red' if i % 2 == 0 else 'green'

            # Get a random pose for the cylinder
            pose = self.get_random_pose(env, cylinder_size)

            # Replace the color in the URDF template
            replace = {'COLOR': color}

            # Generate the URDF for the cylinder
            urdf = self.fill_template(cylinder_template, replace)

            # Add the cylinder to the environment
            cylinder_id = env.add_object(urdf, pose)
            cylinders.append(cylinder_id)

        # Define the target line where the cylinders should be placed
        # We use a green line as a visual guide for the placement
        line_template = 'line/single-green-line-template.urdf'
        line_size = (0.1, 0.6, 0.001)  # Width, Length, Height
        line_pose = self.get_random_pose(env, line_size)

        # Add the line to the environment
        env.add_object(line_template, line_pose, 'fixed')

        # Define the target poses for the cylinders along the line
        # We want the cylinders to touch each other, so we calculate their positions accordingly
        targ_poses = []
        for i in range(n_cylinders):
            # Calculate the x offset for each cylinder to be placed next to each other
            x_offset = line_pose[0][0] - line_size[1] / 2 + cylinder_size[0] / 2 + i * cylinder_size[0]
            # The y and z positions are the same as the line's
            y_pos = line_pose[0][1]
            z_pos = line_pose[0][2] + cylinder_size[2] / 2  # Place cylinders on top of the table surface
            targ_poses.append(((x_offset, y_pos, z_pos), line_pose[1]))  # We keep the same orientation as the line

        # Add goals for each cylinder
        for i, cylinder_id in enumerate(cylinders):
            other_color = 'green' if i % 2 == 0 else 'red'
            language_goal = self.lang_template.format(color=color_name, other_color=other_color)
            self.add_goal(objs=[cylinder_id], matches=np.int32([[1]]), targ_poses=[targ_poses[i]], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1 / n_cylinders,
                          language_goal=language_goal)