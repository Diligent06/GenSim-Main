import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BowlCylinderAlignment(Task):
    """
    Arrange a specified number of colored cylinders around a central bowl without touching it,
    maintaining equal spacing between each cylinder.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we may need up to 5 steps to align the cylinders
        self.lang_template = "place the {color} cylinder around the bowl without touching it"
        self.task_completed_desc = "done aligning cylinders around the bowl."
        self.ee = Suction  # Suction is needed to pick and place cylinders
        self.primitive = None  # No specific primitive is required as we are using the Suction gripper
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the number of cylinders to align
        n_cylinders = np.random.randint(3, 6)  # Randomly choose between 3 to 5 cylinders

        # Add central bowl
        bowl_size = (0.18, 0.18, 0.06)  # Define the size of the bowl (x, y, z)
        bowl_pose = self.get_random_pose(env, bowl_size)  # Get a random pose for the bowl
        bowl_urdf = 'bowl/bowl.urdf'
        env.add_object(bowl_urdf, bowl_pose, 'fixed')  # Add the bowl to the environment

        # Add cylinders around the bowl
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_radius = 0.04  # Define the radius of the cylinder
        cylinder_height = 0.1  # Define the height of the cylinder
        cylinder_size = (2 * cylinder_radius, 2 * cylinder_radius, cylinder_height)
        angle_step = 2 * np.pi / n_cylinders  # Calculate the angle step for equal spacing

        # Initialize list to store cylinder IDs and target poses
        cylinder_ids = []
        target_poses = []

        # Loop to create and place cylinders
        for i in range(n_cylinders):
            # Calculate angle for current cylinder
            angle = i * angle_step
            # Calculate position around the bowl with equal spacing
            x = bowl_pose[0][0] + (bowl_size[0] / 2 + cylinder_radius) * np.cos(angle)
            y = bowl_pose[0][1] + (bowl_size[1] / 2 + cylinder_radius) * np.sin(angle)
            z = bowl_size[2]  # Place the cylinder at the same height as the bowl

            # Define the pose for the current cylinder
            cylinder_pose = ((x, y, z), (0, 0, 0, 1))  # No rotation needed, keep it upright

            # Choose a random color for the cylinder
            color_name = np.random.choice(['red', 'green', 'blue', 'yellow', 'purple', 'orange'])
            color_rgb = utils.COLORS[color_name]

            # Replace the template URDF with the chosen color
            replace = {'COLOR': color_rgb}
            cylinder_urdf = self.fill_template(cylinder_template, replace)

            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            cylinder_ids.append(cylinder_id)

            # Store the target pose for the goal
            target_poses.append(cylinder_pose)

            # Define the language goal
            language_goal = self.lang_template.format(color=color_name)

            # Add the goal for the current cylinder
            self.add_goal(objs=[cylinder_id], matches=np.int32([[1]]), targ_poses=[cylinder_pose], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1 / n_cylinders,
                          language_goal=language_goal)

        # Set the goal for the task
        self.goals = [{
            'objs': cylinder_ids,
            'matches': np.ones((n_cylinders, 1)),  # Each cylinder has one unique target pose
            'targ_poses': target_poses,  # Target poses for the cylinders
            'replace': False,  # Cylinders should not replace each other
            'rotations': False,  # Cylinders should remain upright
            'metric': 'pose',  # The metric to use for evaluating the goal
            'params': None,  # No additional parameters needed
            'step_max_reward': 1,  # Full reward for completing the task
            'symmetries': None,  # No symmetries needed as the cylinders are rotationally symmetric
            'language_goal': self.task_completed_desc  # Language goal for the entire task
        }]