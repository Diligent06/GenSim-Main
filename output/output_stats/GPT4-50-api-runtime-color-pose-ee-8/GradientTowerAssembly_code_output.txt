import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class GradientTowerAssembly(Task):
    """Sequentially stack five differently sized cylinders to form a gradient tower."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We will have 5 goals, so 10 steps should be sufficient
        self.lang_template = "stack the {color} cylinder on top of the tower"
        self.task_completed_desc = "done building the gradient tower."
        self.ee = Suction  # We need to move objects on the Z axis, so Suction is required

    def reset(self, env):
        super().reset(env)

        # Define the colors for the gradient tower
        colors = ['red', 'orange', 'yellow', 'green', 'blue']
        color_names = ['red', 'orange', 'yellow', 'green', 'blue']

        # Define the sizes for the cylinders, from largest at the bottom to smallest at the top
        sizes = [(0.08, 0.08, 0.02 * i) for i in range(5, 0, -1)]

        # Add cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        objs = []
        for i in range(5):
            # Get a random pose for the object
            pose = self.get_random_pose(env, sizes[i])
            replace = {
                'DIM': sizes[i],
                'COLOR': utils.COLORS[colors[i]],
            }
            # Replace the template URDF with the specific size and color
            urdf = self.fill_template(cylinder_template, replace)
            # Add the object to the environment
            obj_id = env.add_object(urdf, pose)
            objs.append(obj_id)

        # Define the target poses for each cylinder, stacked on top of each other
        base_pose = (0.5, 0, 0.01)  # Starting pose for the base of the tower
        targ_poses = []
        z_offset = 0.01  # Initial z-offset for the first cylinder
        for size in sizes:
            # Increment the z-offset by the height of each cylinder
            z_offset += size[2]
            # The target pose is directly above the base pose, with the updated z-offset
            targ_pose = (base_pose[0], base_pose[1], z_offset)
            # Use the same orientation for all cylinders (identity quaternion)
            targ_poses.append((targ_pose, (0, 0, 0, 1)))

        # Add goals for each cylinder
        for i in range(5):
            language_goal = self.lang_template.format(color=color_names[i])
            # Each cylinder must be placed on top of the previous one
            self.add_goal(objs=[objs[i]], matches=np.ones((1, 1)), targ_poses=[targ_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/5,
                          language_goal=language_goal)

# Example usage:
# env = ...  # Assume we have an environment object from the simulation
# task = GradientTowerAssembly()
# task.reset(env)