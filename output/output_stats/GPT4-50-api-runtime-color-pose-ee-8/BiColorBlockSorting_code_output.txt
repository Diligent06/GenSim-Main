import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BiColorBlockSorting(Task):
    """
    Sort a set of bi-colored blocks into two separate zones on the tabletop,
    with each zone designated for one of the two colors present on the blocks.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 4  # We expect to call self.add_goal twice, so max_steps is set to twice that number
        self.lang_template = "sort the {color} blocks into the designated zone"
        self.task_completed_desc = "done sorting bi-color blocks."
        self.ee = Suction  # Using Suction since blocks may need to be lifted

    def reset(self, env):
        super().reset(env)

        # Define the two colors for the bi-color blocks
        color1 = 'red'
        color2 = 'blue'

        # Generate the RGB values for the two colors
        color1_rgb = utils.COLORS[color1]
        color2_rgb = utils.COLORS[color2]

        # Define the number of blocks
        n_blocks = 4

        # Add two zones, one for each color
        zone_size = (0.12, 0.12, 0)  # Size of the zone
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for _ in range(2):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed')
            zone_poses.append(zone_pose)

        # Add bi-color blocks
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks
        block_urdf = 'stacking/block.urdf'
        blocks = []
        for i in range(n_blocks):
            block_pose = self.get_random_pose(env, block_size)
            # Alternate colors for the blocks
            block_color = color1_rgb if i % 2 == 0 else color2_rgb
            block_id = env.add_object(block_urdf, block_pose, color=block_color)
            blocks.append((block_id, block_color))

        # Sort blocks into the corresponding zones based on their color
        for i, zone_pose in enumerate(zone_poses):
            # Select blocks that match the current zone's color
            color_blocks = [block[0] for block in blocks if block[1] == (color1_rgb if i == 0 else color2_rgb)]
            # Define the language goal for the current color
            language_goal = self.lang_template.format(color=color1 if i == 0 else color2)
            # Add the goal for the current color
            self.add_goal(objs=color_blocks, matches=np.ones((len(color_blocks), 1)), targ_poses=[zone_pose],
                          replace=True, rotations=True, metric='zone', params=[(zone_pose, zone_size)],
                          step_max_reward=1, language_goal=language_goal)