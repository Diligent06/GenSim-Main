import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderTowerBalance(Task):
    """Build a tower by stacking five different colored cylinders on top of each other in size-descending order on a small stand without the tower toppling over."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to stack 5 cylinders, so 10 steps should be sufficient
        self.lang_template = "stack the {color} cylinder on top of the {place} one"
        self.task_completed_desc = "done building the cylinder tower."
        self.ee = Suction  # We need to move objects on the Z axis, so Suction is appropriate

    def reset(self, env):
        super().reset(env)

        # Define the colors and sizes for the cylinders
        colors = ['red', 'orange', 'yellow', 'green', 'blue']
        sizes = [(0.08, 0.08, 0.12), (0.07, 0.07, 0.10), (0.06, 0.06, 0.08), (0.05, 0.05, 0.06), (0.04, 0.04, 0.04)]

        # Add base stand
        base_size = (0.1, 0.1, 0.02)  # Size of the base stand
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Add cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []
        cylinder_ids = []
        for i in range(5):
            # Get a random pose for the cylinder
            pose = self.get_random_pose(env, sizes[i])
            # Set the color for the cylinder
            color = utils.COLORS[colors[i]]
            # Replace the placeholders in the URDF template
            replace = {'SIZE': sizes[i], 'COLOR': color}
            # Generate the URDF for the cylinder
            urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder to the environment
            cylinder_id = env.add_object(urdf, pose)
            cylinder_ids.append(cylinder_id)
            cylinder_poses.append(pose)

        # Define the target poses for the cylinders, stacked on the base
        targ_poses = []
        z_offset = base_size[2]
        for size in sizes:
            # The x, y position is the same as the base, and z is incremented for each cylinder
            targ_poses.append((base_pose[0], (0, 0, z_offset)))
            z_offset += size[2]

        # Add goals for each cylinder
        for i in range(5):
            # The language goal describes the action to stack the cylinder
            if i == 0:
                place = "stand"
            else:
                place = colors[i-1]
            language_goal = self.lang_template.format(color=colors[i], place=place)
            # Add the goal for the current cylinder
            self.add_goal(objs=[cylinder_ids[i]], matches=np.ones((1, 1)), targ_poses=[targ_poses[i]],
                          replace=False, rotations=True, metric='pose', params=None,
                          step_max_reward=1, language_goal=language_goal)

        # The task is to stack the cylinders in size-descending order, so we reverse the lists
        self.goals.reverse()
        cylinder_ids.reverse()
        cylinder_poses.reverse()