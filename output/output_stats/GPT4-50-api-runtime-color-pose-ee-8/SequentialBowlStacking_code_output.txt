import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class SequentialBowlStacking(Task):
    """Stack three differently colored bowls inside each other in a specific color order on top of a pallet."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice the number of goals
        self.lang_template = "stack the {color} bowl inside the {target_color} bowl"
        self.task_completed_desc = "done stacking the bowls."
        self.ee = Suction  # Use Suction end-effector to lift bowls in Z axis
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors for the bowls in the order they should be stacked
        bowl_colors = ['red', 'green', 'blue']
        bowl_color_names = ['red', 'green', 'blue']
        bowl_urdf = 'bowl/bowl.urdf'

        # Define the size of the bowls (diameter, height)
        # The sizes are chosen such that each bowl can fit into the next larger one
        bowl_sizes = [(0.12, 0.06), (0.18, 0.06), (0.24, 0.06)]

        # Add pallet.
        pallet_size = (0.3, 0.3, 0.02)  # Size of the pallet
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Add bowls and set goals for stacking them in order.
        bowls = []
        for i in range(3):
            # Get a random pose for the bowl
            bowl_pose = self.get_random_pose(env, bowl_sizes[i])

            # Add the bowl to the environment
            color = utils.COLORS[bowl_colors[i]]
            bowl_id = env.add_object(bowl_urdf, bowl_pose, color=color)
            bowls.append((bowl_id, bowl_pose))

            # Set the language goal for stacking the bowl
            if i < 2:
                language_goal = self.lang_template.format(color=bowl_color_names[i], target_color=bowl_color_names[i+1])
            else:
                # The last bowl does not have a target color since it's the largest
                language_goal = f"place the {bowl_color_names[i]} bowl on the pallet"

            # Set the target pose for the bowl
            # The target pose is the pose of the next larger bowl for the first two bowls
            # The last bowl's target pose is the pallet's pose
            if i == 0:
                target_pose = bowls[i+1][1]
            elif i == 1:
                target_pose = bowls[i+1][1]
            else:
                target_pose = pallet_pose

            # Add the goal for the current bowl
            self.add_goal(objs=[bowl_id], matches=np.ones((1, 1)), targ_poses=[target_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/3,
                          language_goal=language_goal)

        # Note: The bowls are added in reverse order (smallest to largest) so that the goals are set correctly
        # The smallest bowl should be stacked first, followed by the medium, and then the largest on the pallet

# Instantiate the task
task = SequentialBowlStacking()