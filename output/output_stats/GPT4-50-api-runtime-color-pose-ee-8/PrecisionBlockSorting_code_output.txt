import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PrecisionBlockSorting(Task):
    """Pick up five blocks of different shapes and place each one into a matching outline on a large box."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We have 5 blocks to place, so 10 steps should be sufficient
        self.lang_template = "place the {shape} block into the matching outline on the large box"
        self.task_completed_desc = "done sorting all precision blocks."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector

    def reset(self, env):
        super().reset(env)

        # Define the shapes and their corresponding URDFs
        shapes = ['cube', 'ell', 'cylinder', 'ball']
        urdfs = {
            'cube': 'stacking/block.urdf',
            'ell': 'insertion/ell.urdf',
            'cylinder': 'cylinder/cylinder-template.urdf',
            'ball': 'ball/ball-template.urdf'
        }

        # Define the colors for the blocks
        colors = {
            'cube': utils.COLORS['red'],
            'ell': utils.COLORS['blue'],
            'cylinder': utils.COLORS['green'],
            'ball': utils.COLORS['yellow']
        }

        # Add the large box with outlines for the blocks
        box_size = (0.3, 0.3, 0.01)  # Size of the large box
        box_pose = self.get_random_pose(env, box_size)  # Random pose for the box
        box_urdf = 'box/box-template.urdf'
        env.add_object(box_urdf, box_pose, 'fixed')

        # Add the blocks and set their goals
        for shape in shapes:
            # Get the size, color, and URDF for the current shape
            size = (0.04, 0.04, 0.04) if shape != 'ball' else (0.04, 0.04, 0.04)  # Size for non-spherical shapes
            color = colors[shape]
            urdf = urdfs[shape]

            # Get a random pose for the block
            pose = self.get_random_pose(env, size)

            # Add the block to the environment
            block_id = env.add_object(urdf, pose, color=color)

            # Define the target pose for the block on the large box
            # For non-spherical shapes, orientation matters, so we need to align them properly
            target_pose = [(box_pose[0][0], box_pose[0][1], box_pose[0][2] + 0.02), box_pose[1]]

            # Add the goal for the block
            language_goal = self.lang_template.format(shape=shape)
            self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[target_pose], replace=False,
                          rotations=True if shape != 'ball' else False, metric='pose', params=None,
                          step_max_reward=1 / len(shapes), language_goal=language_goal)

        # The task is set up with all blocks and their corresponding goals