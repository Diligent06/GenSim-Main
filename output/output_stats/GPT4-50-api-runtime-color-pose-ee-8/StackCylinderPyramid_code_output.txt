import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class StackCylinderPyramid(Task):
    """Stack five differently colored cylinders on top of each other to form a color-ordered pyramid."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We will have 5 goals, so set max_steps to twice the number of goals
        self.ee = Suction  # Use Suction end-effector to move objects on the Z axis
        self.lang_template = "stack the {color} cylinder on top of the {base_color} one"
        self.task_completed_desc = "done stacking the cylinder pyramid."

    def reset(self, env):
        super().reset(env)

        # Define cylinder colors in the order they should be stacked (from base to top)
        colors = ['red', 'orange', 'yellow', 'green', 'blue']
        color_names = ['red', 'orange', 'yellow', 'green', 'blue']

        # Define the size for each cylinder, from largest at the base to smallest on top
        sizes = [(0.08, 0.08, 0.04),  # Base cylinder
                 (0.07, 0.07, 0.04),  # Second cylinder
                 (0.06, 0.06, 0.04),  # Third cylinder
                 (0.05, 0.05, 0.04),  # Fourth cylinder
                 (0.04, 0.04, 0.04)]  # Top cylinder

        # Add goal zone
        zone_size = (0.2, 0.2, 0)  # Define a zone size that can contain the pyramid
        zone_pose = self.get_random_pose(env, zone_size)  # Get a random pose for the zone within workspace bounds
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')  # Add the zone to the environment

        # Add cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []
        for i in range(5):
            # Get a random pose for the cylinder within workspace bounds
            pose = self.get_random_pose(env, sizes[i])
            # Set the color for the cylinder
            color = utils.COLORS[colors[i]]
            # Replace placeholders in the URDF template with actual values
            replace = {'SIZE': sizes[i], 'COLOR': color}
            # Fill the URDF template
            urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder to the environment
            cylinder_id = env.add_object(urdf, pose)
            # Store the pose for later to define the goal
            cylinder_poses.append((cylinder_id, pose))

        # Define goals for stacking the cylinders
        for i in range(1, 5):
            # The target pose for the current cylinder is on top of the previous one
            base_pose = cylinder_poses[i-1][1]
            targ_pose = (base_pose[0], (base_pose[1][0], base_pose[1][1], base_pose[1][2] + sizes[i-1][2]))
            # Define the language goal
            language_goal = self.lang_template.format(color=color_names[i], base_color=color_names[i-1])
            # Add the goal to the task
            self.add_goal(objs=[cylinder_poses[i][0]], matches=np.ones((1, 1)), targ_poses=[targ_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/5, language_goal=language_goal)

        # The final goal is to have the smallest cylinder on top
        top_pose = cylinder_poses[-1][1]
        targ_pose = (top_pose[0], (top_pose[1][0], top_pose[1][1], top_pose[1][2] + sizes[-2][2]))
        language_goal = self.lang_template.format(color=color_names[-1], base_color=color_names[-2])
        self.add_goal(objs=[cylinder_poses[-1][0]], matches=np.ones((1, 1)), targ_poses=[targ_pose], replace=False,
                      rotations=True, metric='pose', params=None, step_max_reward=1/5, language_goal=language_goal)