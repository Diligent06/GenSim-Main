import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ColorCodedPyramidAssembly(Task):
    """
    Construct a color-coded pyramid by stacking a blue block, a red block,
    and a green block on a stand, with the base layer consisting of the blue block,
    followed by the red block, and topped by the green block.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We have 3 blocks to place, so max_steps is twice the number of blocks
        self.lang_template = "stack the {color} block"
        self.task_completed_desc = "done constructing the color-coded pyramid."
        self.ee = Suction  # Using Suction since we need to move objects on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the size and URDF for the stand and blocks
        stand_size = (0.05, 0.15, 0.005)
        stand_urdf = 'stacking/stand.urdf'
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        # Add the stand to the environment
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object(stand_urdf, stand_pose, category='fixed')

        # Define block colors
        block_colors = {
            'blue': utils.COLORS['blue'],
            'red': utils.COLORS['red'],
            'green': utils.COLORS['green']
        }

        # Add blocks and store their IDs
        block_ids = {}
        for color in block_colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors[color])
            block_ids[color] = block_id

        # Define target poses for each block on the stand
        target_poses = {
            'blue': (stand_pose[0], stand_pose[1]),  # Base layer
            'red': (utils.apply(stand_pose, (0, 0, block_size[2])), stand_pose[1]),  # Middle layer
            'green': (utils.apply(stand_pose, (0, 0, block_size[2] * 2)), stand_pose[1])  # Top layer
        }

        # Add goals for each block
        for color, block_id in block_ids.items():
            language_goal = self.lang_template.format(color=color)
            self.add_goal(
                objs=[block_id],
                matches=np.ones((1, 1)),
                targ_poses=[target_poses[color]],
                replace=False,
                rotations=True,
                metric='pose',
                params=None,
                step_max_reward=1 / len(block_ids),  # Equal reward for each block
                language_goal=language_goal
            )

        # Note: The order of stacking is implicitly defined by the target poses' Z-coordinates