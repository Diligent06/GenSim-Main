import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BowlCrownStack(Task):
    """
    Sequentially stack different colored blocks around the rim of a bowl without any falling inside,
    creating a crown-like arrangement.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to stack 5 blocks, so 10 steps should be sufficient
        self.lang_template = "put the {color} block on the rim of the bowl"
        self.task_completed_desc = "done stacking the crown."
        self.ee = Suction  # We need to move blocks in the Z axis, so we use the Suction gripper
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add a bowl to the environment
        bowl_size = (0.18, 0.18, 0.06)  # x, y, z dimensions for the bowl
        bowl_pose = self.get_random_pose(env, bowl_size)
        bowl_urdf = 'bowl/bowl.urdf'
        env.add_object(bowl_urdf, bowl_pose, 'fixed')

        # Define block properties
        block_size = (0.04, 0.04, 0.04)  # x, y, z dimensions for the blocks
        block_urdf = 'stacking/block.urdf'
        block_colors = ['red', 'green', 'blue', 'yellow', 'purple']  # Colors for the blocks

        # Add blocks and set goals for each block
        for i, color in enumerate(block_colors):
            # Generate a random pose for the block
            block_pose = self.get_random_pose(env, block_size)
            # Add the block to the environment
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            # Define the language goal for this block
            language_goal = self.lang_template.format(color=color)
            # Calculate the target pose for the block on the rim of the bowl
            # We assume the bowl's rim is at z = bowl_size[2] (height of the bowl)
            # and we distribute blocks evenly around the bowl's circumference
            angle = 2 * np.pi * i / len(block_colors)  # Angle for this block
            x_offset = 0.07 * np.cos(angle)  # Offset from the bowl's center
            y_offset = 0.07 * np.sin(angle)  # Offset from the bowl's center
            target_pose = [(bowl_pose[0][0] + x_offset, bowl_pose[0][1] + y_offset, bowl_size[2]),
                           (0, 0, 0, 1)]  # We keep the block's orientation upright

            # Add the goal for this block
            self.add_goal(objs=[block_id], matches=np.ones((1, 1)), targ_poses=[target_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / len(block_colors),
                          language_goal=language_goal)

        # The task is to stack blocks around the rim of the bowl, so we need to ensure
        # that the blocks are placed without falling inside the bowl. The target poses
        # are calculated to be on the rim, and the blocks should be placed sequentially.