import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Spatula

class BowlBridgeBalancing(Task):
    """
    Balance a specified number of differently colored balls on top of a narrow bridge
    created by placing two bowls upside-down side by side.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 4  # We expect to add two goals, so max_steps is twice that
        self.lang_template = "balance the {color} ball on the bridge"
        self.task_completed_desc = "done balancing balls on the bridge."
        self.primitive = primitives.push  # We use the push primitive to balance the balls
        self.ee = Spatula  # Spatula is suitable for the 2D translation required
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the size and pose for the bowls that will form the bridge
        bowl_size = (0.12, 0.12, 0.06)  # Size of the bowl
        bowl_urdf = 'bowl/bowl.urdf'  # URDF file for the bowl

        # Add two bowls upside-down to form the bridge
        bowl_poses = []
        for _ in range(2):
            bowl_pose = self.get_random_pose(env, bowl_size)
            env.add_object(bowl_urdf, bowl_pose, 'fixed')
            bowl_poses.append(bowl_pose)

        # Define the size and template for the balls that need to be balanced
        ball_size = (0.04, 0.04, 0.04)  # Size of the ball
        ball_template = 'ball/ball-template.urdf'  # URDF template for the ball

        # Add balls with different colors
        ball_colors = ['red', 'blue', 'green', 'yellow']  # Possible ball colors
        balls = []
        for color in ball_colors:
            ball_pose = self.get_random_pose(env, ball_size)
            replace = {'COLOR': utils.COLORS[color]}  # Replace color in URDF
            ball_urdf = self.fill_template(ball_template, replace)
            ball_id = env.add_object(ball_urdf, ball_pose)
            balls.append((ball_id, color))

        # Define the narrow bridge by taking the midpoint between the two bowls
        bridge_center_x = (bowl_poses[0][0][0] + bowl_poses[1][0][0]) / 2
        bridge_center_y = (bowl_poses[0][0][1] + bowl_poses[1][0][1]) / 2
        bridge_center_z = bowl_size[2]  # Height of the bowl to place the ball on top
        bridge_center_pose = (bridge_center_x, bridge_center_y, bridge_center_z)

        # Add goals for each ball to be balanced on the bridge
        for ball_id, color in balls:
            language_goal = self.lang_template.format(color=color)
            # Target pose is the bridge center with the same orientation as the ball's initial pose
            target_pose = [(bridge_center_pose, ball_pose[1])]
            self.add_goal(objs=[ball_id], matches=np.ones((1, 1)), targ_poses=target_pose, replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1 / len(balls),
                          language_goal=language_goal)

        # The task is to balance each ball on the bridge, which requires precise control
        # and potentially multiple steps to ensure each ball is stable on the narrow bridge.