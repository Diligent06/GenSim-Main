import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Spatula

class DiagonalBlockBridge(Task):
    """Create a diagonal bridge across a marked zone using differently colored blocks."""

    def __init__(self):
        super().__init__()
        self.max_steps = 4  # We expect to add two goals, so max_steps is twice that
        self.lang_template = "build a bridge using the {color} block"
        self.task_completed_desc = "done building the diagonal block bridge."
        self.primitive = primitives.push  # We will be pushing blocks into place
        self.ee = Spatula  # Using the Spatula end-effector for pushing
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the size and color of the blocks
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks
        block_colors = ['red', 'green', 'blue', 'yellow']  # Available colors

        # Add the zone where the bridge will be built
        zone_size = (0.24, 0.12, 0)  # Size of the zone
        zone_pose = self.get_random_pose(env, zone_size)  # Random pose for the zone
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')  # Add the zone to the environment

        # Add blocks to the environment
        blocks = []
        for color in block_colors:
            block_pose = self.get_random_pose(env, block_size)  # Get a random pose for the block
            block_color = utils.COLORS[color]  # Get the RGB values for the block color
            block_urdf = 'stacking/block.urdf'  # URDF for the block
            block_id = env.add_object(block_urdf, block_pose, color=block_color)  # Add the block to the environment
            blocks.append(block_id)  # Keep track of the block IDs

        # Define the target poses for the blocks to form the bridge
        # The bridge should be diagonal, so we adjust the x and y coordinates accordingly
        targ_poses = []
        for i, block_id in enumerate(blocks):
            x = zone_pose[0][0] + (i * block_size[0])  # Increment x-coordinate for each block
            y = zone_pose[0][1]  # Keep y-coordinate constant for a straight line
            z = zone_pose[0][2]  # Z-coordinate is the same as the zone's
            targ_pose = [(x, y, z), zone_pose[1]]  # Target pose is the same orientation as the zone
            targ_poses.append(targ_pose)

        # Add goals for each block
        for i, block_id in enumerate(blocks):
            language_goal = self.lang_template.format(color=block_colors[i])
            self.add_goal(objs=[block_id], matches=np.ones((1, 1)), targ_poses=[targ_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / len(blocks),
                          language_goal=language_goal)

# Note: The bridge stability is not explicitly checked in this code and would typically be evaluated
# by the simulation environment after executing the actions to see if the bridge remains intact.