import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ColorCodedContainerFilling(Task):
    """Pick up and vertically stack three differently colored cylinders inside a container matching the color of the bottom cylinder."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is set to twice that number
        self.lang_template = "stack the {color} cylinder on top of the {base_color} one in the {container_color} container"
        self.task_completed_desc = "done stacking cylinders."
        self.ee = Suction  # Using Suction since we need to move objects on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the colors for the cylinders and the container
        cylinder_colors = ['red', 'green', 'blue']
        container_color = 'brown'

        # Add container
        container_size = (0.15, 0.15, 0.15)  # Define the size of the container
        container_pose = self.get_random_pose(env, container_size)  # Get a random pose for the container
        container_template = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': tuple([x / 2 for x in container_size])}
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, container_pose, 'fixed')

        # Add cylinders
        cylinder_size = (0.05, 0.05, 0.15)  # Define the size of the cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for color in cylinder_colors:
            # Get a random pose for the cylinder
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            # Set the color of the cylinder
            color_rgb = utils.COLORS[color]
            replace = {'DIM': cylinder_size, 'HALF': tuple([x / 2 for x in cylinder_size]), 'COLOR': color_rgb}
            # Fill the template and add the object
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            cylinders.append((cylinder_id, color))

        # Define goals for stacking cylinders inside the container
        for i, (cylinder_id, color) in enumerate(cylinders):
            # The target pose is inside the container, on top of the previous cylinder or the container base
            z_offset = container_size[2] / 2 + (i * cylinder_size[2])
            target_pose = (container_pose[0], (0, 0, z_offset, 1))  # No rotation, only translation
            # Define the language goal
            base_color = container_color if i == 0 else cylinders[i-1][1]
            language_goal = self.lang_template.format(color=color, base_color=base_color, container_color=container_color)
            # Add the goal
            self.add_goal(objs=[cylinder_id], matches=np.ones((1, 1)), targ_poses=[target_pose], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/3, language_goal=language_goal)

        # Comment: The step_max_reward is set to 1/3 because we have three separate goals to stack each cylinder.