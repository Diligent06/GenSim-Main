import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderGridAlignment(Task):
    """Arrange five differently colored cylinders standing upright in a specific order within five designated areas on a grid marked by a container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to call self.add_goal 5 times, so we set max_steps to twice that number.
        self.lang_template = "place the {color} cylinder in the {color} area"
        self.task_completed_desc = "done aligning cylinders."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector.

    def reset(self, env):
        super().reset(env)

        # Define the colors for the cylinders.
        cylinder_colors = ['red', 'green', 'blue', 'yellow', 'purple']
        np.random.shuffle(cylinder_colors)  # Shuffle the colors to randomize the task each time.

        # Add container with grid.
        container_size = (0.25, 0.25, 0.01)  # Size of the container to hold the grid.
        container_pose = self.get_random_pose(env, container_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, container_pose, 'fixed')

        # Add cylinders.
        cylinder_size = (0.05, 0.05, 0.1)  # Size of the cylinders.
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []  # To store the initial poses of the cylinders.
        cylinder_ids = []  # To store the IDs of the cylinders.

        for i, color_name in enumerate(cylinder_colors):
            # Get a random pose for the cylinder.
            pose = self.get_random_pose(env, cylinder_size)
            cylinder_poses.append(pose)

            # Get the color RGB values.
            color = utils.COLORS[color_name]

            # Fill the URDF template with the specific values for this cylinder.
            replace = {'COLOR': color}
            urdf = self.fill_template(cylinder_template, replace)

            # Add the cylinder to the environment.
            cylinder_id = env.add_object(urdf, pose)
            cylinder_ids.append(cylinder_id)

        # Define the target areas for each cylinder on the grid.
        grid_positions = [(container_pose[0][0] - 0.1, container_pose[0][1] - 0.1, 0.05),
                          (container_pose[0][0], container_pose[0][1] - 0.1, 0.05),
                          (container_pose[0][0] + 0.1, container_pose[0][1] - 0.1, 0.05),
                          (container_pose[0][0] - 0.1, container_pose[0][1], 0.05),
                          (container_pose[0][0], container_pose[0][1], 0.05)]
        target_poses = [(pos, container_pose[1]) for pos in grid_positions]  # Use the container's orientation.

        # Add goals for each cylinder.
        for i, cylinder_id in enumerate(cylinder_ids):
            language_goal = self.lang_template.format(color=cylinder_colors[i])
            self.add_goal(objs=[cylinder_id], matches=np.int32([[1]]), targ_poses=[target_poses[i]], replace=True,
                          rotations=False, metric='pose', params=None, step_max_reward=1/5,
                          language_goal=language_goal)

        # Note: We set replace=True because each cylinder can only go to one target area.
        # We set rotations=False because the cylinders are symmetric and upright placement does not require rotation.
        # The step_max_reward is 1/5 because we have 5 goals and each goal completion contributes equally to the task.