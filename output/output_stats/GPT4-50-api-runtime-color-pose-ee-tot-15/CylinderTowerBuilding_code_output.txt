import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderTowerBuilding(Task):
    """
    Construct a tower by stacking red cylinders of descending diameter sizes on a green fixture.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 4  # We will have two goals, so max_steps is twice that
        self.lang_template = "stack the {size} red cylinder on the {place}"
        self.task_completed_desc = "done building the cylinder tower."
        self.ee = Suction  # Use Suction end-effector to move cylinders on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the sizes for the cylinders, descending in diameter
        cylinder_sizes = [
            (0.08, 0.08, 0.1),  # Large cylinder
            (0.06, 0.06, 0.1),  # Medium cylinder
            (0.04, 0.04, 0.1)   # Small cylinder
        ]

        # Define the color for the cylinders
        cylinder_color = utils.COLORS['red']

        # Define the size and color for the green fixture
        fixture_size = (0.1, 0.1, 0.02)
        fixture_color = utils.COLORS['green']

        # Add the green fixture to the environment
        fixture_pose = self.get_random_pose(env, fixture_size)
        fixture_urdf = 'fixture/fixture.urdf'
        env.add_object(fixture_urdf, fixture_pose, 'fixed', color=fixture_color)

        # Add cylinders to the environment
        cylinder_urdf_template = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []
        for size in cylinder_sizes:
            # Get a random pose for the cylinder
            pose = self.get_random_pose(env, size)
            cylinder_poses.append(pose)

            # Fill in the URDF template for the cylinder
            replace = {'SIZE': size}
            cylinder_urdf = self.fill_template(cylinder_urdf_template, replace)

            # Add the cylinder object to the environment
            env.add_object(cylinder_urdf, pose, color=cylinder_color)

        # Define goals for stacking the cylinders
        # The target pose for each cylinder is on top of the previous one, starting with the fixture
        for i, size in enumerate(cylinder_sizes):
            # The bottom cylinder goes on the fixture, others on top of the previous cylinder
            if i == 0:
                target_pose = fixture_pose
            else:
                target_pose = cylinder_poses[i-1]

            # Adjust the z-coordinate for the target pose to stack the cylinders
            target_pose = (target_pose[0], (target_pose[1][0], target_pose[1][1], target_pose[1][2] + size[2]))

            # Define the language goal
            size_desc = ["large", "medium", "small"][i]
            place_desc = "green fixture" if i == 0 else "previous cylinder"
            language_goal = self.lang_template.format(size=size_desc, place=place_desc)

            # Add the goal for the current cylinder
            self.add_goal(
                objs=[i],  # Object index corresponds to the order they were added
                matches=np.ones((1, 1)),  # Each cylinder has a unique target pose
                targ_poses=[target_pose],  # Target pose for the cylinder
                replace=False,  # Cylinders should not be interchangeable
                rotations=False,  # Rotation is not considered in this task
                metric='pose',  # We are using pose metric for evaluation
                params=None,  # No additional parameters needed
                step_max_reward=1 / len(cylinder_sizes),  # Reward is split across goals
                language_goal=language_goal  # Language description of the goal
            )