import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class TowerOfHanoi(Task):
    """
    Arrange increasingly smaller cylinders onto a stand in size-descending order
    to form a tower of Hanoi.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 cylinders to place, so 6 steps should be enough
        self.lang_template = "place the {color} cylinder on the {target}"
        self.task_completed_desc = "done building the tower of Hanoi."
        self.ee = Suction  # Using Suction since we need to move objects on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the sizes for the cylinders, from largest to smallest
        cylinder_sizes = [
            (0.04, 0.04, 0.12),  # Large cylinder
            (0.03, 0.03, 0.09),  # Medium cylinder
            (0.02, 0.02, 0.06)   # Small cylinder
        ]

        # Add the stand for the tower of Hanoi
        stand_size = (0.05, 0.15, 0.005)
        stand_urdf = 'stacking/stand.urdf'
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object(stand_urdf, stand_pose, category='fixed')

        # Add cylinders in descending size order
        cylinder_urdf_template = 'cylinder/cylinder-template.urdf'
        cylinder_colors = ['red', 'green', 'blue']  # Colors for the cylinders
        cylinder_poses = []  # Store initial poses to use as target poses later
        cylinders = []  # Store cylinder object IDs

        for i, size in enumerate(cylinder_sizes):
            # Generate a random pose for the cylinder
            pose = self.get_random_pose(env, size)
            cylinder_poses.append(pose)

            # Fill in the URDF template with size and color
            replace = {
                'SIZE': size,
                'COLOR': utils.COLORS[cylinder_colors[i]]
            }
            urdf = self.fill_template(cylinder_urdf_template, replace)

            # Add the cylinder to the environment
            cylinder_id = env.add_object(urdf, pose)
            cylinders.append(cylinder_id)

        # Define the target poses for the cylinders on the stand
        # The cylinders should be stacked in size-descending order
        targ_poses = [
            (stand_pose[0], stand_pose[1]),  # Base pose for the largest cylinder
            (utils.apply(stand_pose, (0, 0, cylinder_sizes[0][2])), stand_pose[1]),  # On top of the largest
            (utils.apply(stand_pose, (0, 0, cylinder_sizes[0][2] + cylinder_sizes[1][2])), stand_pose[1])  # On top of the medium
        ]

        # Add goals for each cylinder
        for i, cylinder_id in enumerate(cylinders):
            language_goal = self.lang_template.format(color=cylinder_colors[i], target="stand")
            self.add_goal(
                objs=[cylinder_id],
                matches=np.ones((1, 1)),  # Each cylinder has a unique place
                targ_poses=[targ_poses[i]],
                replace=False,  # Each target pose is unique
                rotations=True,  # Allow rotation since cylinders are symmetrical
                metric='pose',
                params=None,
                step_max_reward=1 / len(cylinders),  # Reward is split across cylinders
                language_goal=language_goal
            )