import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderPrecisionStack(Task):
    """Sequentially stack three differently colored cylinders on top of each other on a stand, in a specified color order without knocking them over."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice that number
        self.lang_template = "stack the {color} cylinder"
        self.task_completed_desc = "done stacking cylinders."
        self.ee = Suction  # Using Suction end-effector as we need to move objects on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the size and color of the cylinders
        cylinder_size = (0.04, 0.04, 0.12)  # Diameter, Diameter, Height
        cylinder_colors = ['red', 'green', 'blue']  # Specified color order
        cylinder_urdf_template = 'cylinder/cylinder-template.urdf'

        # Add the stand to the environment
        stand_size = (0.05, 0.05, 0.005)  # Length, Width, Height
        stand_pose = self.get_random_pose(env, stand_size)
        stand_urdf = 'stacking/stand.urdf'
        env.add_object(stand_urdf, stand_pose, category='fixed')

        # Initialize list to keep track of cylinder IDs
        cylinder_ids = []

        # Add cylinders to the environment
        for color_name in cylinder_colors:
            # Generate the color RGB values
            color_rgb = utils.COLORS[color_name]

            # Get a random pose for the cylinder
            cylinder_pose = self.get_random_pose(env, cylinder_size)

            # Fill in the URDF template with the cylinder properties
            replace = {
                'DIM': cylinder_size,
                'COLOR': color_rgb,
            }
            cylinder_urdf = self.fill_template(cylinder_urdf_template, replace)

            # Add the cylinder to the environment and store its ID
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            cylinder_ids.append(cylinder_id)

        # Define the target poses for the cylinders on the stand
        # The cylinders will be stacked on top of each other, so we adjust the z-coordinate accordingly
        z_offset = stand_size[2]  # Start with the height of the stand
        targ_poses = []
        for i in range(len(cylinder_colors)):
            # The x, y coordinates are the same as the stand's, and the z coordinate increases with each cylinder
            targ_pose = (stand_pose[0], (0, 0, z_offset))
            targ_poses.append(targ_pose)
            z_offset += cylinder_size[2]  # Increase the z_offset by the height of a cylinder for the next one

        # Add goals for each cylinder
        for i, cylinder_id in enumerate(cylinder_ids):
            # Define the language goal for the current cylinder
            language_goal = self.lang_template.format(color=cylinder_colors[i])

            # Add the goal for the current cylinder
            self.add_goal(
                objs=[cylinder_id],
                matches=np.ones((1, 1)),  # Each cylinder has a unique target pose
                targ_poses=[targ_poses[i]],
                replace=False,  # Each cylinder has a fixed target pose
                rotations=False,  # Rotation is not considered in this task
                metric='pose',  # We use pose matching to evaluate the task
                params=None,  # No additional parameters needed
                step_max_reward=1,  # Full reward for completing this subtask
                language_goal=language_goal
            )

# Instantiate the task
task = CylinderPrecisionStack()