import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class DiagonalBlockSequence(Task):
    """Create a diagonal sequence of blocks from one corner of the table to the opposite, alternating colors between red and green."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to have 5 blocks, so max_steps is set to twice the number of blocks
        self.lang_template = "place the {color} block at the {position} position in the sequence"
        self.task_completed_desc = "completed the diagonal block sequence."
        self.ee = Suction  # We need to move blocks on the Z axis, so we use the Suction end-effector

    def reset(self, env):
        super().reset(env)

        # Define the number of blocks and their size
        n_blocks = 5
        block_size = (0.04, 0.04, 0.04)  # Size of each block

        # Define the starting corner and the step size for the diagonal placement
        start_corner = (0.25, -0.5, 0.01)  # Starting from the bottom left corner of the table
        step_size = (0.1, 0.2, 0.04)  # Step size for x, y, and z coordinates

        # Define the colors for the blocks
        red_color = utils.COLORS['red']
        green_color = utils.COLORS['green']

        # Load the block URDF
        block_urdf = 'stacking/block.urdf'

        # Initialize a list to store the target poses
        target_poses = []

        # Add blocks to the environment
        for i in range(n_blocks):
            # Alternate colors between red and green
            color = red_color if i % 2 == 0 else green_color
            color_name = 'red' if i % 2 == 0 else 'green'

            # Calculate the position for this block in the sequence
            position = (start_corner[0] + i * step_size[0],
                        start_corner[1] + i * step_size[1],
                        start_corner[2] + i * step_size[2])

            # Get a random pose for the block
            pose = self.get_random_pose(env, block_size)

            # Add the block to the environment
            block_id = env.add_object(block_urdf, pose, color=color)

            # Define the target pose for this block
            target_pose = (position, (0, 0, 0, 1))  # No rotation needed, keep the default orientation
            target_poses.append(target_pose)

            # Define the language goal for this block
            language_goal = self.lang_template.format(color=color_name, position=utils.ordinal(i + 1))

            # Add the goal for this block
            self.add_goal(objs=[block_id],
                          matches=np.ones((1, 1)),
                          targ_poses=[target_pose],
                          replace=False,
                          rotations=False,
                          metric='pose',
                          params=None,
                          step_max_reward=1 / n_blocks,
                          language_goal=language_goal)

        # Add a corner template to mark the starting corner (optional, for visual aid)
        corner_template = 'corner/corner-template.urdf'
        replace = {}  # No replacement needed for the corner template
        corner_urdf = self.fill_template(corner_template, replace)
        env.add_object(corner_urdf, (start_corner, (0, 0, 0, 1)), 'fixed')

# Note: The code assumes that the utils.ordinal function exists to convert numbers to their ordinal representation (e.g., 1 -> 'first').
# If such a function does not exist, you will need to create a mapping or a small utility function for that purpose.