import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderStackMatching(Task):
    """
    Stack a specific number of colored cylinders into a pyramid arrangement on a designated zone,
    matching the color order provided in a template picture.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We expect to call self.add_goal three times, so max_steps is twice that
        self.lang_template = "stack the {color} cylinder on the {location} location"
        self.task_completed_desc = "done stacking cylinders."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector

    def reset(self, env):
        super().reset(env)

        # Define the number of cylinders and their colors
        n_cylinders = 3  # Total number of cylinders to stack
        cylinder_colors = ['red', 'green', 'blue']  # Colors of the cylinders in the order to be stacked

        # Add the zone where the cylinders will be stacked
        zone_size = (0.1, 0.1, 0)  # Size of the zone
        zone_pose = self.get_random_pose(env, zone_size)  # Random pose for the zone
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')  # Add the zone to the environment

        # Add cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_size = (0.04, 0.04, 0.12)  # Size of the cylinders (diameter, diameter, height)
        cylinders = []  # List to store cylinder IDs

        for i in range(n_cylinders):
            # Get a random pose for the cylinder
            pose = self.get_random_pose(env, cylinder_size)
            # Get the color for the cylinder
            color = utils.COLORS[cylinder_colors[i]]
            # Replace the placeholders in the URDF template
            replace = {'SIZE': cylinder_size, 'COLOR': color}
            # Fill in the template and get the URDF
            urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder to the environment and store its ID
            cylinder_id = env.add_object(urdf, pose)
            cylinders.append(cylinder_id)

        # Define the target poses for the cylinders to form a pyramid
        # The base of the pyramid will have two cylinders and the top will have one
        base_height = cylinder_size[2] / 2  # Half the height of the cylinder
        top_height = cylinder_size[2] * 1.5  # One and a half times the height of the cylinder
        # Target poses for the base cylinders
        base_poses = [
            (zone_pose[0][0] - 0.02, zone_pose[0][1], base_height),
            (zone_pose[0][0] + 0.02, zone_pose[0][1], base_height)
        ]
        # Target pose for the top cylinder
        top_pose = (zone_pose[0][0], zone_pose[0][1], top_height)

        # Add goals for each cylinder
        # Bottom layer
        for i in range(2):
            language_goal = self.lang_template.format(color=cylinder_colors[i], location="bottom")
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[(base_poses[i], (0, 0, 0, 1))],
                          replace=False, rotations=True, metric='pose', params=None, step_max_reward=1 / n_cylinders,
                          language_goal=language_goal)

        # Top layer
        language_goal = self.lang_template.format(color=cylinder_colors[2], location="top")
        self.add_goal(objs=[cylinders[2]], matches=np.ones((1, 1)), targ_poses=[(top_pose, (0, 0, 0, 1))],
                      replace=False, rotations=True, metric='pose', params=None, step_max_reward=1 / n_cylinders,
                      language_goal=language_goal)