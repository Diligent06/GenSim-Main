import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderSortingTower(Task):
    """Build a tower by stacking cylinders of different colors on top of each other in a specified color order on a pallet."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to stack 5 cylinders, so 10 steps should be sufficient
        self.ee = Suction  # We need to move objects on the Z axis, so Suction is appropriate
        self.lang_template = "stack the {color} cylinder"
        self.task_completed_desc = "done building the cylinder tower."

    def reset(self, env):
        super().reset(env)

        # Define the color order for the cylinders
        color_order = ['red', 'green', 'blue', 'yellow', 'purple']
        n_cylinders = len(color_order)

        # Add pallet
        pallet_size = (0.3, 0.3, 0.02)  # x, y, z dimensions for the pallet
        pallet_pose = self.get_random_pose(env, pallet_size)
        pallet_urdf = 'pallet/pallet.urdf'
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Add cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_size = (0.05, 0.05, 0.1)  # x, y, z dimensions for the cylinder
        cylinder_urdfs = []
        cylinder_poses = []
        for i, color_name in enumerate(color_order):
            # Generate a random pose for the cylinder
            pose = self.get_random_pose(env, cylinder_size)
            cylinder_poses.append(pose)

            # Set the color of the cylinder
            color = utils.COLORS[color_name]

            # Replace the template URDF with the specific color and size
            replace = {'COLOR': color, 'SIZE': cylinder_size}
            urdf = self.fill_template(cylinder_template, replace)
            cylinder_urdfs.append(urdf)

            # Add the cylinder to the environment
            env.add_object(urdf, pose)

        # Define the target poses for the cylinders on the pallet
        # The cylinders should be stacked on top of each other, so we increment the z-coordinate
        targ_poses = []
        for i in range(n_cylinders):
            x, y, _ = pallet_pose[0]
            z = pallet_pose[0][2] + (i + 1) * cylinder_size[2]
            targ_poses.append([(x, y, z), (0, 0, 0, 1)])  # We don't need to specify rotation for cylinders

        # Add goals for each cylinder
        for i in range(n_cylinders):
            language_goal = self.lang_template.format(color=color_order[i])
            self.add_goal(objs=[i],  # Object index corresponds to the order they were added
                          matches=np.ones((1, 1)),  # Each cylinder has one unique target pose
                          targ_poses=[targ_poses[i]],  # Target pose for this cylinder
                          replace=False,  # Cylinders should not be replaced once placed
                          rotations=False,  # Rotation is not considered for this task
                          metric='pose',  # We use pose metric for precise placement
                          params=None,  # No additional parameters needed
                          step_max_reward=1 / n_cylinders,  # Reward is evenly distributed across cylinders
                          language_goal=language_goal)  # Language goal for this step