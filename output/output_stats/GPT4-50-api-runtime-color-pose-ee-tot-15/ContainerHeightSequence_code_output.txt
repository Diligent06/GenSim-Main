import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ContainerHeightSequence(Task):
    """
    Arrange a set of containers by height, placing them in a line on the tabletop
    from shortest to tallest.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we have 5 containers, 2 steps per container
        self.ee = Suction  # Use Suction end-effector to pick and place containers
        self.lang_template = "place the {color} container in the {position} position"
        self.task_completed_desc = "done arranging containers by height."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Number of containers to arrange
        n_containers = 5

        # Generate random heights for the containers
        heights = np.linspace(0.05, 0.15, n_containers)
        np.random.shuffle(heights)  # Shuffle to randomize initial order

        # Container template and initial positions
        container_template = 'container/container-template.urdf'
        container_positions = []

        # Add containers to the environment
        containers = []
        for i in range(n_containers):
            # Define the size of the container based on the height
            size = (0.05, 0.05, heights[i])  # Width and length are fixed; height varies
            color = utils.COLORS[np.random.choice(list(utils.COLORS.keys()))]  # Random color for each container
            pose = self.get_random_pose(env, size)  # Get a random initial pose
            replace = {'DIM': size, 'HALF': (size[0] / 2, size[1] / 2, size[2] / 2), 'COLOR': color}

            # Fill the container URDF template with size and color
            container_urdf = self.fill_template(container_template, replace)
            container_id = env.add_object(container_urdf, pose)
            containers.append((container_id, size[2]))  # Store container ID and height

            # Store the initial position for later reference
            container_positions.append(pose[0])

        # Sort containers by height (shortest to tallest)
        containers.sort(key=lambda x: x[1])

        # Define target positions for the containers in a line
        start_x = 0.25
        x_spacing = 0.1  # Space between containers
        for idx, (container_id, _) in enumerate(containers):
            # Target position for each container
            target_x = start_x + idx * x_spacing
            target_pose = [(target_x, 0, 0), (0, 0, 0, 1)]  # No rotation needed, quaternions for identity rotation

            # Language goal for each container
            color_name = [name for name, color in utils.COLORS.items() if color == replace['COLOR']][0]
            position_name = ['first', 'second', 'third', 'fourth', 'fifth'][idx]
            language_goal = self.lang_template.format(color=color_name, position=position_name)

            # Add goal for each container
            self.add_goal(objs=[container_id], matches=np.ones((1, 1)), targ_poses=[target_pose], replace=True,
                          rotations=False, metric='pose', params=None, step_max_reward=1 / n_containers,
                          language_goal=language_goal)