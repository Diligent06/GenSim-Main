import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BuildingABridge(Task):
    """Stack red blocks to form two pillars and place a green plank across them to create a bridge structure."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice that number
        self.lang_template = "build a bridge using {num_blocks} red blocks and a green plank"
        self.task_completed_desc = "done building the bridge."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the number of blocks for the pillars and the plank
        n_blocks = 4  # Two blocks for each pillar
        plank_length = 0.3  # Length of the plank

        # Define the size of the blocks and the plank
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks
        plank_size = (plank_length, 0.1, 0.02)  # Size of the plank

        # Define colors using the utils.COLORS dictionary
        red_color = utils.COLORS['red']
        green_color = utils.COLORS['green']

        # Add red blocks to the environment
        block_urdf = 'stacking/block.urdf'
        blocks = []
        for _ in range(n_blocks):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=red_color)
            blocks.append(block_id)

        # Add a green plank to the environment
        plank_template = 'box/box-template.urdf'
        plank_pose = self.get_random_pose(env, plank_size)
        replace = {'DIM': plank_size, 'HALF': (plank_size[0] / 2, plank_size[1] / 2, plank_size[2] / 2)}
        plank_urdf = self.fill_template(plank_template, replace)
        plank_id = env.add_object(plank_urdf, plank_pose, color=green_color)

        # Define the target poses for the two pillars and the plank
        # We will place the blocks at fixed x coordinates and use the y coordinate from the random poses
        pillar1_poses = [(0.3, blocks[0][0][1], 0.02), (0.3, blocks[1][0][1], 0.06)]
        pillar2_poses = [(0.6, blocks[2][0][1], 0.02), (0.6, blocks[3][0][1], 0.06)]
        plank_target_pose = [(0.45, (pillar1_poses[0][1] + pillar2_poses[0][1]) / 2, 0.1), (0, 0, 0, 1)]  # Plank on top of pillars

        # Add goals for the blocks to form the two pillars
        for i in range(2):
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[pillar1_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/3,
                          language_goal=self.lang_template.format(num_blocks=n_blocks))
            self.add_goal(objs=[blocks[i+2]], matches=np.ones((1, 1)), targ_poses=[pillar2_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/3,
                          language_goal=self.lang_template.format(num_blocks=n_blocks))

        # Add goal for the plank to be placed across the two pillars
        self.add_goal(objs=[plank_id], matches=np.ones((1, 1)), targ_poses=[plank_target_pose], replace=False,
                      rotations=False, metric='pose', params=None, step_max_reward=1/3,
                      language_goal=self.lang_template.format(num_blocks=n_blocks))