import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ColorGradientTower(Task):
    """Build a tower with blocks of gradient colors from darkest to lightest shade on a stand."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to add 5 goals, so max_steps is set to twice that number
        self.lang_template = "place the {color} block on the {place}"
        self.task_completed_desc = "done building the color gradient tower."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors in gradient order from darkest to lightest
        gradient_colors = ['indigo', 'blue', 'cyan', 'green', 'yellow']

        # Add the stand where the blocks will be placed
        stand_size = (0.05, 0.15, 0.005)  # x, y, z dimensions for the stand size
        stand_urdf = 'stacking/stand.urdf'
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object(stand_urdf, stand_pose, category='fixed')

        # Add blocks with gradient colors
        block_size = (0.04, 0.04, 0.04)  # x, y, z dimensions for the block size
        block_urdf = 'stacking/block.urdf'
        block_poses = []
        blocks = []

        for i, color_name in enumerate(gradient_colors):
            # Get the color RGB values
            color = utils.COLORS[color_name]

            # Get a random pose for the block
            block_pose = self.get_random_pose(env, block_size)
            block_poses.append(block_pose)

            # Add the block to the environment
            block_id = env.add_object(block_urdf, block_pose, color=color)
            blocks.append(block_id)

        # Define the target poses for the blocks on the stand
        # The blocks should be stacked on top of each other in the order of the gradient
        targ_poses = []
        for i in range(len(gradient_colors)):
            # The x and y coordinates are the same as the stand's, and z increases with each block
            targ_pose = (stand_pose[0], (0, 0, stand_pose[0][2] + (i + 1) * block_size[2]))
            targ_poses.append(targ_pose)

        # Add goals for each block
        for i, block_id in enumerate(blocks):
            # Language goal describes the action to be performed with the block
            language_goal = self.lang_template.format(color=gradient_colors[i], place="top of the previous block")

            # Add the goal with the corresponding target pose
            self.add_goal(objs=[block_id], matches=np.ones((1, 1)), targ_poses=[targ_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / len(blocks),
                          language_goal=language_goal)

# Instantiate the task
task = ColorGradientTower()