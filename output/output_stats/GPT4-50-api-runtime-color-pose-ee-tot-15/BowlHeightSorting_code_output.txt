import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BowlHeightSorting(Task):
    """
    Sort bowls by size by stacking them inside each other from largest at the bottom to smallest at the top in a designated zone.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 4  # We expect to call self.add_goal twice, so we set max_steps to twice that number
        self.lang_template = "stack the {size} bowl inside the {place} bowl in the designated zone"
        self.task_completed_desc = "done sorting bowls by height."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the number of bowls and their sizes
        n_bowls = 3
        bowl_sizes = sorted([np.random.uniform(0.06, 0.12) for _ in range(n_bowls)], reverse=True)

        # Add goal zone
        zone_size = (0.15, 0.15, 0)  # Size of the zone where we want to stack the bowls
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add bowls and keep track of their IDs and poses for goal specification
        bowl_urdf = 'bowl/bowl.urdf'
        bowls = []
        for size in bowl_sizes:
            # Generate a random pose for the bowl
            bowl_pose = self.get_random_pose(env, (size, size, 0))
            # Set the color of the bowl based on its size for visual distinction
            color = utils.COLORS['red'] if size == bowl_sizes[0] else \
                    utils.COLORS['green'] if size == bowl_sizes[1] else \
                    utils.COLORS['blue']
            # Add the bowl to the environment
            bowl_id = env.add_object(bowl_urdf, bowl_pose, color=color)
            bowls.append((bowl_id, bowl_pose))

        # Define the goals for stacking the bowls
        # The largest bowl should be at the bottom, so we start with the second largest
        for i in range(1, n_bowls):
            # The target pose for the current bowl is the pose of the next larger bowl
            # We only need to adjust the z-coordinate to stack them
            target_pose = list(bowls[i-1][1])
            target_pose[0][2] += 0.01  # Slightly above the previous bowl to avoid collision

            # Define the language goal for the current bowl
            size_desc = "smallest" if i == n_bowls - 1 else "smaller"
            place_desc = "largest" if i == 1 else "larger"
            language_goal = self.lang_template.format(size=size_desc, place=place_desc)

            # Add the goal for the current bowl
            self.add_goal(
                objs=[bowls[i][0]],  # Current bowl ID
                matches=np.ones((1, 1)),  # One-to-one correspondence
                targ_poses=[tuple(target_pose)],  # Target pose with adjusted z-coordinate
                replace=False,  # Each bowl has a unique target
                rotations=False,  # Rotation is not necessary for this task
                metric='pose',  # We are using pose-based evaluation
                params=None,  # No additional parameters needed
                step_max_reward=1 / (n_bowls - 1),  # Reward is divided among the goals
                language_goal=language_goal  # Language goal for the current action
            )