import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ZoneBallArrangement(Task):
    """Place differently colored balls within their matching colored zones on the tabletop, without the balls touching each other."""

    def __init__(self):
        super().__init__()
        self.max_steps = 4  # Assuming we will have two goals, one for placing and one for not touching
        self.lang_template = "put the {color} ball in the matching {color} zone"
        self.task_completed_desc = "done arranging the balls in zones."
        self.ee = Suction  # Using Suction since we need to move balls on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the number of balls and zones
        n_balls = 3

        # Define the size of the balls and zones
        ball_size = (0.04, 0.04, 0.04)  # Diameter of the ball
        zone_size = (0.15, 0.15, 0)  # Size of the zone

        # Define colors for the balls and zones
        colors = ['red', 'green', 'blue']
        ball_colors = [utils.COLORS[color] for color in colors]

        # Add zones with matching colors
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for i, color in enumerate(colors):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[color])
            zone_poses.append(zone_pose)

        # Add balls with matching colors
        ball_template = 'ball/ball-template.urdf'
        ball_poses = []
        for i, color in enumerate(ball_colors):
            ball_pose = self.get_random_pose(env, ball_size)
            replace = {'COLOR': color}
            ball_urdf = self.fill_template(ball_template, replace)
            ball_id = env.add_object(ball_urdf, ball_pose)
            ball_poses.append(ball_pose)

            # Add language goal for placing the ball in the matching zone
            language_goal = self.lang_template.format(color=colors[i])
            self.add_goal(objs=[ball_id], matches=np.int32([[1]]), targ_poses=[zone_poses[i]], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/n_balls,
                          language_goal=language_goal)

        # Add a goal for ensuring the balls do not touch each other
        # This is a conceptual goal, no specific target pose is needed, hence using the initial ball poses
        # The reward function will need to handle the logic for balls not touching
        self.add_goal(objs=ball_poses, matches=np.zeros((n_balls, n_balls)), targ_poses=ball_poses, replace=True,
                      rotations=False, metric='pose', params=None, step_max_reward=1,
                      language_goal="make sure the balls do not touch each other.")

    def reward(self):
        # Custom reward function to ensure balls do not touch each other
        # This function would need access to the current state of the environment to calculate distances between balls
        # For simplicity, we assume a function `calculate_min_distance` exists within the environment
        # which calculates the minimum distance between all pairs of balls
        min_distance = self.env.calculate_min_distance()
        touching_penalty = 0 if min_distance >= 2 * 0.04 else -1  # Penalize if balls are closer than twice the diameter
        return super().reward() + touching_penalty