import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ColoredCylinderTower(Task):
    """Sequentially stack four differently colored cylinders onto a stand, creating a tower with the order of colors specified in advance."""

    def __init__(self):
        super().__init__()
        self.max_steps = 8  # We have 4 cylinders to stack, so we set max_steps to twice the number of cylinders
        self.lang_template = "stack the {color} cylinder"
        self.task_completed_desc = "done stacking the colored cylinder tower."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the order of colors for the cylinders in the tower
        color_order = ['red', 'green', 'blue', 'yellow']
        # Define the size of the cylinders
        cylinder_size = (0.05, 0.05, 0.1)  # (radius, radius, height)

        # Add the stand
        stand_size = (0.15, 0.15, 0.005)  # (x, y, z) dimensions
        stand_urdf = 'stacking/stand.urdf'
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object(stand_urdf, stand_pose, category='fixed')

        # Add cylinders
        cylinder_urdf_template = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []
        cylinder_ids = []
        for i, color_name in enumerate(color_order):
            # Get the color RGB values
            color = utils.COLORS[color_name]
            # Generate a random pose for the cylinder
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            # Keep track of the initial poses to use as target poses later
            cylinder_poses.append(cylinder_pose)
            # Fill in the URDF template with the specific color and size
            replace = {'COLOR': color, 'SIZE': cylinder_size}
            cylinder_urdf = self.fill_template(cylinder_urdf_template, replace)
            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            cylinder_ids.append(cylinder_id)

        # Define the target poses for the cylinders on the stand
        # The z-coordinate is incremented by the height of each cylinder
        z_offset = stand_pose[0][2] + stand_size[2] + cylinder_size[2] / 2
        for i, cylinder_id in enumerate(cylinder_ids):
            # The target pose is directly above the stand, with the appropriate z-offset
            target_pose = ((stand_pose[0][0], stand_pose[0][1], z_offset), (0, 0, 0, 1))
            z_offset += cylinder_size[2]  # Increment the z-offset for the next cylinder
            # Define the language goal
            language_goal = self.lang_template.format(color=color_order[i])
            # Add the goal for the current cylinder
            self.add_goal(objs=[cylinder_id], matches=np.ones((1, 1)), targ_poses=[target_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / len(cylinder_ids),
                          language_goal=language_goal)

# Note: The rotation part of the target pose is set to (0, 0, 0, 1) which represents no rotation since the cylinders are symmetrical about their vertical axis.