import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BowlTowerBalancing(Task):
    """
    Build a tower with three differently colored bowls by inverting and stacking them on top of each other,
    ensuring the tower stands without support for at least 5 seconds.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice the number of goals
        self.lang_template = "stack the {color} bowl on top of the {lower_color} one"
        self.task_completed_desc = "done building the bowl tower."
        self.ee = Suction  # Using Suction end-effector to lift bowls in Z axis

    def reset(self, env):
        super().reset(env)

        # Define bowl size and URDF path
        bowl_size = (0.15, 0.15, 0.07)  # Approximate size of the bowl
        bowl_urdf = 'bowl/bowl.urdf'

        # Define colors for the bowls
        colors = ['red', 'green', 'blue']
        color_names = ['red', 'green', 'blue']
        np.random.shuffle(colors)  # Shuffle colors to randomize bowl order

        # Add bowls with random poses and colors
        bowls = []
        for color_name in colors:
            color = utils.COLORS[color_name]
            pose = self.get_random_pose(env, bowl_size)
            bowl_id = env.add_object(bowl_urdf, pose, color=color)
            bowls.append((bowl_id, pose, color_name))

        # Define target poses for the bowls to be stacked
        # The target pose for the bottom bowl is its initial pose
        # The target poses for the middle and top bowls are above the lower bowls
        bottom_bowl_id, bottom_bowl_pose, bottom_color = bowls[0]
        middle_bowl_id, _, middle_color = bowls[1]
        top_bowl_id, _, top_color = bowls[2]

        # Invert the bowls for stacking by rotating 180 degrees around the X-axis
        invert_rotation = p.getQuaternionFromEuler([np.pi, 0, 0])

        # Middle bowl target pose is on top of the bottom bowl
        middle_bowl_target_pose = (bottom_bowl_pose[0], invert_rotation)
        # Top bowl target pose is on top of the middle bowl (which is on the bottom bowl)
        top_bowl_target_pose = ((bottom_bowl_pose[0][0], bottom_bowl_pose[0][1], bottom_bowl_pose[0][2] + 2 * bowl_size[2]), invert_rotation)

        # Add goals for stacking the bowls
        # Bottom bowl goal (no need to move, just for language goal)
        self.add_goal(objs=[bottom_bowl_id], matches=np.ones((1, 1)), targ_poses=[bottom_bowl_pose], replace=True,
                      rotations=False, metric='pose', params=None, step_max_reward=1/3,
                      language_goal=self.lang_template.format(color=bottom_color, lower_color='table'))

        # Middle bowl goal
        self.add_goal(objs=[middle_bowl_id], matches=np.ones((1, 1)), targ_poses=[middle_bowl_target_pose], replace=True,
                      rotations=False, metric='pose', params=None, step_max_reward=1/3,
                      language_goal=self.lang_template.format(color=middle_color, lower_color=bottom_color))

        # Top bowl goal
        self.add_goal(objs=[top_bowl_id], matches=np.ones((1, 1)), targ_poses=[top_bowl_target_pose], replace=True,
                      rotations=False, metric='pose', params=None, step_max_reward=1/3,
                      language_goal=self.lang_template.format(color=top_color, lower_color=middle_color))