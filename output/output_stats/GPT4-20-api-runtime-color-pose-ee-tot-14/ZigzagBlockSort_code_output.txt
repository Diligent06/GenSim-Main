import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Spatula

class ZigzagBlockSort(Task):
    """
    Arrange colored blocks along a zigzag path created by alternating single green lines
    and corner markers, matching the block colors with the line and corner marker sequence
    without misalignment.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we will have 5 goals, so max_steps is twice the number of goals
        self.lang_template = "place the {color} block on the {shape} marker"
        self.task_completed_desc = "done sorting blocks along the zigzag path."
        self.primitive = primitives.push  # Using push primitive with spatula end-effector
        self.ee = Spatula  # End-effector is a spatula for pushing objects
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors and shapes used in the task
        colors = ['red', 'blue', 'green', 'orange', 'yellow']
        shapes = ['line', 'corner']

        # Add green lines and corner markers to create a zigzag path
        line_urdf = 'line/single-green-line-template.urdf'
        corner_urdf = 'corner/corner-template.urdf'
        markers = []
        for i in range(5):
            if i % 2 == 0:  # Even index, add line
                marker_pose = self.get_random_pose(env, (0.1, 0.02, 0.001))
                env.add_object(line_urdf, marker_pose, 'fixed')
            else:  # Odd index, add corner
                marker_pose = self.get_random_pose(env, (0.02, 0.02, 0.001))
                env.add_object(corner_urdf, marker_pose, 'fixed')
            markers.append(marker_pose)

        # Add colored blocks
        block_urdf = 'stacking/block.urdf'
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks
        blocks = []
        for i, color in enumerate(colors):
            block_color = utils.COLORS[color]  # Get the RGB values for the block color
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_color)
            blocks.append(block_id)

            # Define the language goal for placing each block
            shape = shapes[i % len(shapes)]  # Alternate between line and corner
            language_goal = self.lang_template.format(color=color, shape=shape)

            # Add goal for each block to be placed on the corresponding marker
            self.add_goal(objs=[block_id], matches=np.ones((1, 1)), targ_poses=[markers[i]],
                          replace=False, rotations=True, metric='pose', params=None,
                          step_max_reward=1/5, language_goal=language_goal)

        # Set the task description
        self.lang_goals = [self.lang_template.format(color=color, shape=shape) for color, shape in zip(colors, shapes)]