import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BowlBallBalancing(Task):
    """Balance a specified number of balls on top of an inverted bowl without letting them roll off."""

    def __init__(self):
        super().__init__()
        self.max_steps = 4  # We expect to have 2 goals, so max_steps is twice that
        self.lang_template = "balance the {color} ball on the inverted bowl"
        self.task_completed_desc = "done balancing balls on the bowl."
        self.ee = Suction  # Using Suction since we need to move balls on the Z axis
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the bowl and ball sizes
        bowl_size = (0.18, 0.18, 0.06)  # x, y, z dimensions for the bowl
        ball_size = (0.04, 0.04, 0.04)  # x, y, z dimensions for the ball

        # Add an inverted bowl to the environment
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_pose = self.get_random_pose(env, bowl_size)
        # Invert the bowl by rotating it 180 degrees around the x-axis
        bowl_pose = (bowl_pose[0], p.getQuaternionFromEuler([np.pi, 0, 0]))
        env.add_object(bowl_urdf, bowl_pose, 'fixed')

        # Add balls to the environment
        balls = []
        ball_urdf_template = 'ball/ball-template.urdf'
        n_balls = np.random.randint(1, 4)  # Randomly choose between 1 to 3 balls
        for _ in range(n_balls):
            ball_pose = self.get_random_pose(env, ball_size)
            color_name = np.random.choice(['red', 'green', 'blue', 'yellow', 'purple'])  # Randomly choose a color
            color = utils.COLORS[color_name]
            replace = {'COLOR': color}
            ball_urdf = self.fill_template(ball_urdf_template, replace)
            ball_id = env.add_object(ball_urdf, ball_pose)
            balls.append((ball_id, color_name))

        # Define the goal for each ball
        for ball_id, color_name in balls:
            # The target pose is on top of the inverted bowl, with some z-offset to account for the ball radius
            target_pose = (bowl_pose[0], bowl_pose[1])
            target_pose[0][2] += bowl_size[2] / 2 + ball_size[2] / 2  # z-offset

            # Add the goal for the current ball
            language_goal = self.lang_template.format(color=color_name)
            self.add_goal(objs=[ball_id], matches=np.int32([[1]]), targ_poses=[target_pose], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1 / n_balls,
                          language_goal=language_goal)

        # Set the primitive to be used for this task
        self.primitive = primitives.push  # Although we use Suction, we might need to push the balls to balance them