import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class SequentialBowlStacking(Task):
    """Stack a series of three differently colored bowls within a marked zone on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice the number of goals
        self.lang_template = "stack the {color} bowl {position} in the marked zone"
        self.task_completed_desc = "done stacking the bowls."
        self.ee = Suction  # Use Suction end-effector to lift the bowls on the Z axis
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors for the bowls
        bowl_colors = ['red', 'green', 'blue']
        np.random.shuffle(bowl_colors)  # Shuffle the colors to randomize the order

        # Define the sizes for the bowls (large, medium, small)
        bowl_sizes = [(0.18, 0.18, 0.08), (0.15, 0.15, 0.06), (0.12, 0.12, 0.04)]
        
        # Add zone where the bowls should be stacked
        zone_size = (0.24, 0.24, 0)  # Define the size of the zone
        zone_pose = self.get_random_pose(env, zone_size)  # Get a random pose for the zone
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')  # Add the zone to the environment

        # Add bowls to the environment
        bowl_urdf = 'bowl/bowl.urdf'
        bowls = []
        for i in range(3):
            # Get a random pose for the bowl
            bowl_pose = self.get_random_pose(env, bowl_sizes[i])
            # Add the bowl to the environment with the corresponding color
            bowl_id = env.add_object(bowl_urdf, bowl_pose, color=utils.COLORS[bowl_colors[i]])
            bowls.append(bowl_id)

        # Define the language goals for each bowl
        positions = ['on the bottom', 'in the middle', 'on the top']
        for i in range(3):
            # Define the target pose for the bowl, which is the zone pose with an adjusted Z coordinate
            targ_pose = (zone_pose[0], zone_pose[1])
            # Adjust the Z coordinate based on the bowl's position in the stack
            targ_pose[0][2] += sum(bowl_sizes[j][2] for j in range(i))
            # Add the goal for the current bowl
            self.add_goal(
                objs=[bowls[i]],  # The current bowl
                matches=np.ones((1, 1)),  # The bowl matches the target pose
                targ_poses=[targ_pose],  # The target pose
                replace=False,  # Each bowl has a unique target pose
                rotations=False,  # Rotation is not considered for this task
                metric='pose',  # The metric is based on the pose
                params=None,  # No additional parameters are needed
                step_max_reward=1 / 3,  # The max reward for each step is 1/3 since there are 3 bowls
                language_goal=self.lang_template.format(color=bowl_colors[i], position=positions[i])
            )

# Note: The code assumes that the bowls are added to the environment in the order of their size,
# with the largest bowl added first and the smallest bowl added last.