import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ColorSequenceContainerFilling(Task):
    """Fill a container with a sequence of blocks and balls, alternating between them, each following a pre-defined color order pattern."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we will have 5 calls to self.add_goal
        self.lang_template = "put the {object} in the {container_color} container"
        self.task_completed_desc = "done filling the container."
        self.ee = Suction  # Use Suction end-effector to move objects on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the color sequence for the blocks and balls
        color_sequence = ['red', 'green', 'blue', 'yellow', 'purple']
        color_names = ['red block', 'green ball', 'blue block', 'yellow ball', 'purple block']

        # Add container
        container_size = (0.15, 0.15, 0.15)  # Define the container size
        container_pose = self.get_random_pose(env, container_size)  # Get a random pose for the container
        container_template = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, container_pose, 'fixed')

        # Add blocks and balls in alternating order
        block_size = (0.04, 0.04, 0.04)  # Define the block size
        ball_radius = 0.02  # Define the ball radius
        block_urdf = 'stacking/block.urdf'
        ball_template = 'ball/ball-template.urdf'
        objects = []

        for i, color in enumerate(color_sequence):
            # Alternate between block and ball
            if i % 2 == 0:  # Even index, add block
                obj_pose = self.get_random_pose(env, block_size)
                obj_color = utils.COLORS[color]
                obj_urdf = block_urdf
                obj_size = block_size
            else:  # Odd index, add ball
                obj_pose = self.get_random_pose(env, (ball_radius * 2, ball_radius * 2, ball_radius * 2))
                replace = {'COLOR': utils.COLORS[color], 'SIZE': ball_radius}
                obj_urdf = self.fill_template(ball_template, replace)
                obj_size = (ball_radius * 2, ball_radius * 2, ball_radius * 2)

            # Add the object to the environment
            obj_id = env.add_object(obj_urdf, obj_pose, 'rigid', color=obj_color)
            objects.append(obj_id)

            # Define the language goal
            language_goal = self.lang_template.format(object=color_names[i], container_color='brown')

            # Add the goal for the current object
            self.add_goal(objs=[obj_id],
                          matches=np.ones((1, 1)),  # Single object, single target
                          targ_poses=[container_pose],  # Target pose is the container pose
                          replace=False,  # Object should not match with multiple targets
                          rotations=False,  # Rotation is not considered in this task
                          metric='zone',  # We are placing objects in a zone (the container)
                          params=[(container_pose, container_size)],  # Parameters for the zone
                          step_max_reward=1 / len(color_sequence),  # Reward for placing this object
                          language_goal=language_goal)  # Language goal for this step