import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ColorCodedCylinderBallArrangement(Task):
    """
    Arrange colored cylinders and balls in alternating order by color in a designated zone on the tabletop.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Set to twice the expected number of add_goal calls
        self.ee = Suction  # Use Suction end-effector to pick and place objects in 3D space
        self.lang_template = "arrange the {color1} cylinder and {color2} ball in alternating order in the designated zone"
        self.task_completed_desc = "done arranging the cylinders and balls."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the number of cylinders and balls
        n_objects = 4  # Total number of objects (cylinders + balls)

        # Define colors for cylinders and balls
        cylinder_colors = [utils.COLORS['red'], utils.COLORS['green'], utils.COLORS['blue'], utils.COLORS['yellow']]
        ball_colors = [utils.COLORS['orange'], utils.COLORS['purple'], utils.COLORS['cyan'], utils.COLORS['pink']]

        # Add a zone where objects will be arranged
        zone_size = (0.24, 0.24, 0)  # Define the size of the zone
        zone_pose = self.get_random_pose(env, zone_size)  # Get a random pose for the zone within workspace bounds
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')  # Add the zone to the environment

        # Add cylinders and balls to the environment
        objects = []
        for i in range(n_objects // 2):
            # Add cylinder
            cylinder_size = (0.04, 0.04, 0.08)  # Define the size of the cylinder
            cylinder_pose = self.get_random_pose(env, cylinder_size)  # Get a random pose for the cylinder
            cylinder_template = 'cylinder/cylinder-template.urdf'
            replace = {'COLOR': cylinder_colors[i]}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            objects.append(cylinder_id)

            # Add ball
            ball_size = (0.04, 0.04, 0.04)  # Define the size of the ball
            ball_pose = self.get_random_pose(env, ball_size)  # Get a random pose for the ball
            ball_template = 'ball/ball-template.urdf'
            replace = {'COLOR': ball_colors[i]}
            ball_urdf = self.fill_template(ball_template, replace)
            ball_id = env.add_object(ball_urdf, ball_pose)
            objects.append(ball_id)

        # Define the target poses for the objects in the zone
        # Objects should be placed in alternating order by color in the zone
        targ_poses = []
        for i in range(n_objects):
            x_offset = (i % 2) * 0.08 - 0.04  # Alternate x position for cylinder and ball
            y_offset = (i // 2) * 0.08 - 0.08  # Row position based on pair index
            targ_pose = utils.apply(zone_pose, (x_offset, y_offset, 0.04))  # Apply offset to zone pose
            targ_poses.append(targ_pose)

        # Add goal for each object
        for i in range(n_objects):
            color_name = 'cylinder' if i % 2 == 0 else 'ball'
            color1 = cylinder_colors[i // 2] if i % 2 == 0 else ball_colors[i // 2]
            color2 = ball_colors[i // 2] if i % 2 == 0 else cylinder_colors[i // 2]
            language_goal = self.lang_template.format(color1=color_name, color2=color_name)
            self.add_goal(objs=[objects[i]], matches=np.ones((1, 1)), targ_poses=[targ_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / n_objects,
                          language_goal=language_goal)

        # Note: The task assumes that the cylinders and balls are placed in an alternating pattern.
        # The language goal is set for each object, but it could be adjusted to describe the entire arrangement.