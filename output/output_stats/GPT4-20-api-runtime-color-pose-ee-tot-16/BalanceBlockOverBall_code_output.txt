import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BalanceBlockOverBall(Task):
    """Balance a block flat atop a ball without the block falling off."""

    def __init__(self):
        super().__init__()
        self.max_steps = 2  # We have one main goal, so max_steps is set to twice the number of goals
        self.ee = Suction  # Using Suction end-effector as we need to move the block in the Z axis
        self.lang_template = "balance the block on top of the ball"
        self.task_completed_desc = "done balancing the block over the ball."

    def reset(self, env):
        super().reset(env)

        # Define the size of the block and ball
        block_size = (0.04, 0.04, 0.04)  # Size of the block (x, y, z)
        ball_size = (0.06, 0.06, 0.06)  # Size of the ball (x, y, z)

        # Add the block
        block_urdf = 'stacking/block.urdf'
        block_color = utils.COLORS['blue']  # Color of the block
        block_pose = self.get_random_pose(env, block_size)  # Get a random initial pose for the block
        block_id = env.add_object(block_urdf, block_pose, color=block_color)  # Add block to the environment

        # Add the ball
        ball_template = 'ball/ball-template.urdf'
        ball_color = utils.COLORS['red']  # Color of the ball
        ball_pose = self.get_random_pose(env, ball_size)  # Get a random initial pose for the ball
        replace = {'DIM': ball_size}  # Replacement dictionary for the ball URDF template
        ball_urdf = self.fill_template(ball_template, replace)  # Fill the ball URDF template
        ball_id = env.add_object(ball_urdf, ball_pose, 'fixed')  # Add ball to the environment

        # Define the target pose for the block, which is directly above the center of the ball
        target_pose = (ball_pose[0], (0, 0, 0, 1))  # Target pose with the same position as the ball and no rotation

        # Add the goal
        self.add_goal(
            objs=[block_id],  # Object to move
            matches=np.ones((1, 1)),  # One-to-one correspondence between objects and targets
            targ_poses=[target_pose],  # Target pose for the block
            replace=False,  # No replacement of objects
            rotations=False,  # No rotation required for the block
            metric='pose',  # Use pose metric for evaluation
            params=None,  # No additional parameters
            step_max_reward=1,  # Maximum reward for completing this step
            language_goal=self.lang_template  # Language goal description
        )

# Instantiate the task
task = BalanceBlockOverBall()