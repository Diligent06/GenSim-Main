import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BowlOnBoxStacking(Task):
    """Stack a specified number of bowls on top of a box without the bowls falling off."""

    def __init__(self):
        super().__init__()
        self.max_steps = 4  # We expect to call self.add_goal twice, so we set this to twice that number
        self.lang_template = "stack {num_bowls} bowls on the {color} box"
        self.task_completed_desc = "done stacking bowls on box."
        self.ee = Suction  # Use Suction end-effector to lift bowls in Z axis

    def reset(self, env):
        super().reset(env)

        # Define the number of bowls to stack and the box size
        n_bowls = np.random.randint(1, 4)  # Random number of bowls between 1 and 3
        box_size = self.get_random_size(0.15, 0.2, 0.15, 0.2, 0.05, 0.1)  # Random box size within given ranges

        # Add box to the environment
        box_pose = self.get_random_pose(env, box_size)
        box_template = 'box/box-template.urdf'
        box_color = utils.COLORS['brown']  # Set box color to brown
        replace = {'DIM': box_size, 'HALF': (box_size[0] / 2, box_size[1] / 2, box_size[2] / 2), 'COLOR': box_color}
        box_urdf = self.fill_template(box_template, replace)
        env.add_object(box_urdf, box_pose, 'fixed')

        # Add bowls to the environment
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_size = (0.1, 0.1, 0.04)  # Fixed bowl size
        bowl_color = utils.COLORS['blue']  # Set bowl color to blue
        bowls = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, bowl_size)
            bowl_id = env.add_object(bowl_urdf, bowl_pose, color=bowl_color)
            bowls.append(bowl_id)

        # Define target poses for the bowls on top of the box
        targ_poses = []
        for i in range(n_bowls):
            # Calculate the z-offset for each bowl to stack them on top of each other
            z_offset = box_size[2] + (i * bowl_size[2])
            # Target pose is directly above the center of the box with the calculated z-offset
            targ_pose = (box_pose[0], (0, 0, z_offset), box_pose[1])
            targ_poses.append(targ_pose)

        # Add goal for stacking bowls
        language_goal = self.lang_template.format(num_bowls=n_bowls, color='brown')
        self.add_goal(objs=bowls, matches=np.ones((n_bowls, 1)), targ_poses=targ_poses, replace=False,
                      rotations=False, metric='pose', params=None, step_max_reward=1, language_goal=language_goal)

# Instantiate the task
task = BowlOnBoxStacking()