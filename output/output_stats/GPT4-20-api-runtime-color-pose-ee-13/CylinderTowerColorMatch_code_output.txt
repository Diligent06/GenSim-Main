import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderTowerColorMatch(Task):
    """Build a tower by stacking five cylinders of different colors on top of the matching colored circle."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to stack 5 cylinders, so 10 steps should be sufficient
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.lang_template = "stack the {color} cylinder on the {color} circle"
        self.task_completed_desc = "done building the cylinder tower."

    def reset(self, env):
        super().reset(env)

        # Define the colors for the cylinders
        colors = ['red', 'blue', 'green', 'yellow', 'purple']
        color_names = [utils.COLORS[c] for c in colors]  # Get the RGB values for the colors

        # Add target circles on the table for each cylinder to match
        circle_size = (0.05, 0.05, 0.001)  # Size of the circles
        circle_urdf_template = 'line/single-green-line-template.urdf'
        circle_poses = []  # Store the poses of the circles

        for i, color in enumerate(colors):
            # Generate a random pose for the circle within the workspace bounds
            circle_pose = self.get_random_pose(env, circle_size)
            circle_poses.append(circle_pose)

            # Fill in the template URDF for the circle with the specific color
            replace = {'COLOR': color_names[i]}
            circle_urdf = self.fill_template(circle_urdf_template, replace)

            # Add the circle to the environment
            env.add_object(circle_urdf, circle_pose, 'fixed')

        # Add cylinders
        cylinder_size = (0.04, 0.04, 0.08)  # Size of the cylinders
        cylinder_urdf_template = 'cylinder/cylinder-template.urdf'
        cylinders = []  # Store the IDs of the cylinders

        for i, color in enumerate(colors):
            # Generate a random pose for the cylinder within the workspace bounds
            cylinder_pose = self.get_random_pose(env, cylinder_size)

            # Fill in the template URDF for the cylinder with the specific color
            replace = {'COLOR': color_names[i]}
            cylinder_urdf = self.fill_template(cylinder_urdf_template, replace)

            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            cylinders.append(cylinder_id)

            # Define the language goal for stacking this cylinder
            language_goal = self.lang_template.format(color=color)

            # Add the goal for this cylinder to be stacked on the matching circle
            self.add_goal(objs=[cylinder_id], matches=np.int32([[1]]),
                          targ_poses=[circle_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None,
                          step_max_reward=1 / len(colors),  # Reward is evenly distributed across cylinders
                          language_goal=language_goal)

        # The task is to stack the cylinders in the correct order on their matching circles