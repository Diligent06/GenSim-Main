import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BalancedBoxPlacement(Task):
    """Pick up three differently colored boxes and place them on a flat surface in a balanced stack."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We have 3 goals, so max_steps is set to twice the number of goals
        self.lang_template = "place the {color} box {position} without touching the zone boundary"
        self.task_completed_desc = "done placing the boxes in a balanced stack."
        self.ee = Suction  # Use Suction end-effector to pick and place boxes
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors for the boxes
        colors = ['red', 'green', 'blue']
        color_names = ['red', 'green', 'blue']
        box_sizes = [(0.07, 0.07, 0.07), (0.06, 0.06, 0.06), (0.05, 0.05, 0.05)]  # Define sizes for large, medium, small boxes

        # Add zone where boxes should not touch
        zone_size = (0.3, 0.3, 0)  # Define the size of the zone
        zone_pose = self.get_random_pose(env, zone_size)  # Get a random pose for the zone
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')  # Add the zone to the environment

        # Add boxes
        boxes = []
        for i in range(3):
            # Get a random pose for the box
            box_pose = self.get_random_pose(env, box_sizes[i])
            # Define the color of the box using utils.COLORS
            color = utils.COLORS[color_names[i]]
            # Define the template and replacements for the box URDF
            box_template = 'box/box-template.urdf'
            replace = {'SIZE': box_sizes[i], 'COLOR': color}
            # Fill the template with the specific box properties
            box_urdf = self.fill_template(box_template, replace)
            # Add the box to the environment
            box_id = env.add_object(box_urdf, box_pose)
            boxes.append(box_id)

        # Define the target poses for the boxes
        # The target pose for each box is on top of the previous one, forming a stack
        targ_poses = [
            (zone_pose[0], zone_pose[1]),  # Bottom box uses the zone pose for placement
            utils.apply(boxes[0], (0, 0, box_sizes[0][2])),  # Middle box is placed on top of the bottom box
            utils.apply(boxes[1], (0, 0, box_sizes[1][2]))   # Top box is placed on top of the middle box
        ]

        # Add goals for each box
        for i in range(3):
            position = 'on the bottom' if i == 0 else 'in the middle' if i == 1 else 'on the top'
            language_goal = self.lang_template.format(color=color_names[i], position=position)
            self.add_goal(
                objs=[boxes[i]],  # Object to place
                matches=np.ones((1, 1)),  # One-to-one correspondence between objects and target poses
                targ_poses=[targ_poses[i]],  # Target pose for the box
                replace=False,  # Each box has a unique target pose
                rotations=True,  # Allow rotations for the box placement
                metric='pose',  # Use pose metric for evaluation
                params=None,  # No additional parameters needed
                step_max_reward=1,  # Full reward for placing each box correctly
                language_goal=language_goal  # Language goal for the current step
            )