import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class GradientCylinderArrangement(Task):
    """Arrange cylinders by height to create a gradient effect from shortest to tallest."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to arrange 5 cylinders, so 10 steps should be sufficient
        self.ee = Suction  # Suction is needed to pick and place objects in the Z axis
        self.lang_template = "arrange the cylinders from shortest to tallest"
        self.task_completed_desc = "done arranging the gradient of cylinders."

    def reset(self, env):
        super().reset(env)

        # Define the number of cylinders and their colors
        n_cylinders = 5
        cylinder_colors = ['red', 'green', 'blue', 'yellow', 'purple']

        # Add cylinders with varying heights
        cylinders = []
        for i in range(n_cylinders):
            # Define the size of the cylinder, with height varying from 0.05 to 0.25
            height = 0.05 + i * 0.05  # Incremental height for gradient effect
            radius = 0.04  # Constant radius for all cylinders
            size = (2 * radius, 2 * radius, height)

            # Get a random pose for the cylinder
            pose = self.get_random_pose(env, size)

            # Define the color of the cylinder
            color = utils.COLORS[cylinder_colors[i]]

            # Define the URDF template and replacements
            template = 'cylinder/cylinder-template.urdf'
            replace = {
                'DIM': size,
                'HALF': (radius, radius, height / 2),
                'COLOR': color,
            }

            # Fill the URDF template and add the object to the environment
            urdf = self.fill_template(template, replace)
            cylinder_id = env.add_object(urdf, pose)
            cylinders.append((cylinder_id, height))

        # Sort cylinders by height
        cylinders.sort(key=lambda x: x[1])

        # Define the target positions for the cylinders, spaced along the x-axis
        x_positions = np.linspace(0.25, 0.75, n_cylinders)
        y_position = 0  # Constant y-position for all cylinders
        z_position = 0.01  # Slightly above the table to avoid collision

        # Add goals for each cylinder
        for i, (cylinder_id, _) in enumerate(cylinders):
            # Target pose is directly on the table with no rotation
            target_pose = [(x_positions[i], y_position, z_position), (0, 0, 0, 1)]

            # Add the goal for the current cylinder
            self.add_goal(
                objs=[cylinder_id],
                matches=np.ones((1, 1)),  # Single object, single goal
                targ_poses=[target_pose],
                replace=False,  # Object should not be replaced after placement
                rotations=False,  # Rotation is not considered in this task
                metric='pose',  # We use pose metric to evaluate placement
                params=None,  # No additional parameters needed for pose metric
                step_max_reward=1 / n_cylinders,  # Reward is split across cylinders
                language_goal=self.lang_template  # Language goal for the task
            )