import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ColorOrderedCylinderBarrier(Task):
    """Arrange different colored cylinders in a stable vertical barrier on the tabletop, with each column composed of identically colored cylinders ordered from left to right by their color sequence."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to have 5 goals, so max_steps is set to twice the number of goals
        self.lang_template = "build a column of {color} cylinders"
        self.task_completed_desc = "done arranging the cylinders."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors and their order for the cylinders
        color_sequence = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']
        n_cylinders_per_color = 3  # Number of cylinders per color

        # Define cylinder size and template
        cylinder_size = (0.04, 0.04, 0.12)  # (radius, radius, height)
        cylinder_template = 'cylinder/cylinder-template.urdf'

        # Initialize list to keep track of cylinder objects
        cylinders = []

        # Add cylinders to the environment
        for color_name in color_sequence:
            for _ in range(n_cylinders_per_color):
                # Get a random pose for the cylinder
                pose = self.get_random_pose(env, cylinder_size)
                # Get the color RGB values
                color = utils.COLORS[color_name]
                # Fill in the template URDF with the specific color and size
                replace = {'COLOR': color, 'SIZE': cylinder_size}
                urdf = self.fill_template(cylinder_template, replace)
                # Add the cylinder object to the environment
                cylinder_id = env.add_object(urdf, pose)
                cylinders.append((cylinder_id, color_name))

        # Define the x-coordinates for the columns, evenly spaced and ordered
        x_positions = np.linspace(0.25, 0.75, len(color_sequence))

        # Add goals for each color
        for idx, color_name in enumerate(color_sequence):
            # Filter cylinders of the current color
            color_cylinders = [cid for cid, cname in cylinders if cname == color_name]
            # Define the target poses for the cylinders in a column
            z_offset = cylinder_size[2] / 2  # Half the height of the cylinder
            targ_poses = [([x_positions[idx], 0, z_offset + i * cylinder_size[2]], (0, 0, 0, 1)) for i in range(n_cylinders_per_color)]
            # Add the goal for the current color
            language_goal = self.lang_template.format(color=color_name)
            self.add_goal(objs=color_cylinders, matches=np.ones((n_cylinders_per_color, 1)), targ_poses=targ_poses, replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1 / len(color_sequence),
                          language_goal=language_goal)

        # Set the task description
        self.lang_goals = [self.lang_template.format(color=c) for c in color_sequence]