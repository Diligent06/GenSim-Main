import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PyramidPalletSorting(Task):
    """Build a color-sorted pyramid on a pallet, with each level's blocks placed on designated colored outlines,
    from the darkest at the base to the lightest at the top."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is set to twice the number of goals
        self.lang_template = "build a {color} level of the pyramid on the pallet"
        self.task_completed_desc = "done building the pyramid."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors for the blocks, sorted from darkest to lightest
        block_colors = ['purple', 'blue', 'green', 'yellow', 'orange', 'red']
        block_colors_rgb = [utils.COLORS[color] for color in block_colors]

        # Add the pallet
        pallet_size = (0.3, 0.3, 0.02)  # Size of the pallet
        pallet_pose = self.get_random_pose(env, pallet_size)
        pallet_urdf = 'pallet/pallet.urdf'
        env.add_object(pallet_urdf, pallet_pose, category='fixed')

        # Add blocks and zones for each color
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks
        block_urdf = 'stacking/block.urdf'
        zone_urdf = 'zone/zone.urdf'
        zone_size = (0.05, 0.05, 0)  # Size of the zones

        # Initialize lists to store block IDs and target poses
        block_ids = []
        target_poses = []

        # Create blocks and zones for each color
        for i, color in enumerate(block_colors):
            # Add the block
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_colors_rgb[i])
            block_ids.append(block_id)

            # Add the zone
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, color=block_colors_rgb[i], category='zone')

            # Store the target pose for the block, which is the pose of the zone
            target_poses.append(zone_pose)

        # Define the goals for each level of the pyramid
        for level in range(3):
            # Define the language goal for the current level
            language_goal = self.lang_template.format(color=block_colors[level * 2])

            # Define the objects and matches for the current level
            # Each level has two blocks, so we create a 2x2 identity matrix for matches
            objs = block_ids[level * 2: (level + 1) * 2]
            matches = np.eye(2)

            # Define the target poses for the current level
            targ_poses = target_poses[level * 2: (level + 1) * 2]

            # Add the goal for the current level
            self.add_goal(objs=objs, matches=matches, targ_poses=targ_poses, replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/3,
                          language_goal=language_goal)