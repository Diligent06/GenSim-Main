import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class GradientTowerPlacement(Task):
    """Build two separate towers each made of three differently colored cylinders,
    placing them on a patterned zone marked with two distinct areas, one for each tower,
    while ensuring that the cylinders in each tower are arranged in a color gradient sequence
    from the lightest on top to the darkest at the base."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 steps per tower, so 6 in total
        self.lang_template = "build a tower with the {colors} cylinders"
        self.task_completed_desc = "done building gradient towers."
        self.ee = Suction  # We need to move objects on the Z axis, so we use Suction

    def reset(self, env):
        super().reset(env)

        # Define the colors for the cylinders in gradient order (lightest to darkest)
        gradient_colors = ['silver', 'gray', 'black']

        # Define the size of the cylinders
        cylinder_size = (0.04, 0.04, 0.12)  # (radius, radius, height)

        # Add the patterned zone with two distinct areas for the towers
        zone_size = (0.24, 0.12, 0)  # Size of the entire zone
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Split the zone into two areas, one for each tower
        tower_zone_poses = [
            (zone_pose[0][0] - 0.08, zone_pose[0][1], zone_pose[0][2]),
            (zone_pose[0][0] + 0.08, zone_pose[0][1], zone_pose[0][2])
        ]

        # Add cylinders and define their target poses within the zone
        cylinders = []
        target_poses = []
        for i in range(2):  # Two towers
            for j, color_name in enumerate(gradient_colors):
                # Get the color RGB values
                color = utils.COLORS[color_name]

                # Generate a random pose for the cylinder
                pose = self.get_random_pose(env, cylinder_size)

                # Create the cylinder URDF using the template
                cylinder_urdf = self.fill_template('cylinder/cylinder-template.urdf', {'COLOR': color})

                # Add the cylinder to the environment
                cylinder_id = env.add_object(cylinder_urdf, pose)
                cylinders.append(cylinder_id)

                # Define the target pose for the cylinder in the tower
                # The Z coordinate is offset by the cylinder height times the index
                target_pose = (tower_zone_poses[i][0], tower_zone_poses[i][1], zone_pose[0][2] + cylinder_size[2] * j)
                target_poses.append((target_pose, (0, 0, 0, 1)))  # No rotation needed

        # Add goals for each cylinder
        for i in range(len(cylinders)):
            # Define the language goal for the current step
            if i < 3:
                colors_text = ', '.join(gradient_colors[:i+1])
                language_goal = self.lang_template.format(colors=colors_text)
            else:
                colors_text = ', '.join(gradient_colors[:i-2])
                language_goal = self.lang_template.format(colors=colors_text)

            # Add the goal for the current cylinder
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[target_poses[i]],
                          replace=False, rotations=False, metric='pose', params=None,
                          step_max_reward=1/len(cylinders), language_goal=language_goal)