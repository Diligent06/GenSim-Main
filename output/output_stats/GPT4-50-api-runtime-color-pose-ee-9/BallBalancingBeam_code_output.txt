import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Spatula

class BallBalancingBeam(Task):
    """
    Balance three balls of different colors on top of a horizontal cylinder,
    ensuring that each ball remains stationary on the cylinder for a set duration without falling off.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We have 3 balls to balance, so 6 steps give us two attempts per ball.
        self.lang_template = "balance the {color} ball on the beam"
        self.task_completed_desc = "done balancing balls on beam."
        self.primitive = primitives.push  # We use the push primitive to roll the balls.
        self.ee = Spatula  # Spatula is suitable for pushing balls in a 2D plane.
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors for the three balls.
        ball_colors = [utils.COLORS['red'], utils.COLORS['green'], utils.COLORS['blue']]

        # Define the size of the cylinder (beam) and balls.
        cylinder_size = (0.05, 0.05, 0.3)  # (radius, height, length)
        ball_size = (0.04, 0.04, 0.04)  # (radius, height, length) - balls are spheres, so all dimensions are equal.

        # Add the horizontal cylinder (beam) to the environment.
        cylinder_pose = self.get_random_pose(env, cylinder_size)
        cylinder_template = 'cylinder/cylinder-template.urdf'
        replace = {'DIM': cylinder_size}
        cylinder_urdf = self.fill_template(cylinder_template, replace)
        env.add_object(cylinder_urdf, cylinder_pose, 'fixed')

        # Add the three balls to the environment.
        ball_template = 'ball/ball-template.urdf'
        for color in ball_colors:
            # Get a random pose for the ball.
            ball_pose = self.get_random_pose(env, ball_size)
            replace = {'COLOR': color, 'SIZE': ball_size}
            ball_urdf = self.fill_template(ball_template, replace)
            ball_id = env.add_object(ball_urdf, ball_pose)

            # Define the language goal for balancing the ball.
            color_name = [name for name, rgb in utils.COLORS.items() if rgb == color][0]
            language_goal = self.lang_template.format(color=color_name)

            # Add the goal for the ball to be balanced on the beam.
            # The target pose is the top center of the cylinder with the same orientation as the ball's initial pose.
            target_pose = (cylinder_pose[0], ball_pose[1])
            self.add_goal(objs=[ball_id], matches=np.int32([[1]]), targ_poses=[target_pose], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/3,
                          language_goal=language_goal)

        # Set the end-effector to Spatula for pushing actions.
        self.ee = Spatula