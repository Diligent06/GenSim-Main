import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ColoredBlockPathway(Task):
    """Create an unbroken pathway from a start zone to a target bowl using a sequence of differently colored blocks, ensuring each block is touching the next."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we will call self.add_goal 5 times
        self.lang_template = "create a pathway from the {start_zone} to the {target_bowl} using {block_color} blocks"
        self.task_completed_desc = "completed the colored block pathway."
        self.ee = Suction  # Using Suction since blocks may need to be lifted and placed

    def reset(self, env):
        super().reset(env)

        # Define the size of the zone and the bowl
        zone_size = (0.15, 0.15, 0)  # x, y, z dimensions for the zone size
        bowl_size = (0.12, 0.12, 0)  # x, y, z dimensions for the bowl size

        # Add start zone
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add target bowl
        bowl_pose = self.get_random_pose(env, bowl_size)
        env.add_object('bowl/bowl.urdf', bowl_pose, 'fixed')

        # Define block size and colors
        block_size = (0.04, 0.04, 0.04)  # x, y, z dimensions for the block size
        block_colors = ['red', 'green', 'blue', 'yellow', 'purple']
        block_urdf = 'stacking/block.urdf'

        # Add blocks and set their goals
        prev_block_pose = None
        for i, color in enumerate(block_colors):
            # Generate a random pose for the block
            block_pose = self.get_random_pose(env, block_size)

            # Add the block to the environment
            block_color = utils.COLORS[color]
            block_id = env.add_object(block_urdf, block_pose, color=block_color)

            # Define the language goal for this step
            language_goal = self.lang_template.format(
                start_zone="green zone",
                target_bowl="green bowl",
                block_color=color
            )

            # If it's the first block, the goal is to be in the start zone
            if i == 0:
                self.add_goal(
                    objs=[block_id],
                    matches=np.ones((1, 1)),
                    targ_poses=[zone_pose],
                    replace=False,
                    rotations=True,
                    metric='zone',
                    params=[(zone_pose, zone_size)],
                    step_max_reward=1,
                    language_goal=language_goal
                )
            else:
                # For subsequent blocks, the goal is to be touching the previous block
                self.add_goal(
                    objs=[block_id],
                    matches=np.ones((1, 1)),
                    targ_poses=[prev_block_pose],
                    replace=False,
                    rotations=True,
                    metric='pose',
                    params=None,
                    step_max_reward=1,
                    language_goal=language_goal
                )

            # Store the current block's pose to use as the target for the next block
            prev_block_pose = block_pose

        # The last block's goal is to be in the target bowl
        self.add_goal(
            objs=[block_id],
            matches=np.ones((1, 1)),
            targ_poses=[bowl_pose],
            replace=False,
            rotations=True,
            metric='zone',
            params=[(bowl_pose, bowl_size)],
            step_max_reward=1,
            language_goal=language_goal
        )