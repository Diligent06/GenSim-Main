import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BalancedBowlTower(Task):
    """
    Stack three differently colored bowls of the same size upside down,
    one on top of the other, to form a tower on a single stand,
    ensuring the tower remains balanced and does not topple.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice that
        self.lang_template = "stack the {color} bowl on the {location} of the stand"
        self.task_completed_desc = "done stacking the bowls."
        self.ee = Suction  # Use Suction end-effector to lift the bowls

    def reset(self, env):
        super().reset(env)

        # Define the size of the bowls and the stand
        bowl_size = (0.12, 0.12, 0.06)  # x, y, z dimensions
        stand_size = (0.05, 0.05, 0.15)  # x, y, z dimensions

        # Add the stand to the environment
        stand_urdf = 'stacking/stand.urdf'
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object(stand_urdf, stand_pose, category='fixed')

        # Define the colors for the bowls
        bowl_colors = ['red', 'green', 'blue']
        bowl_urdf = 'bowl/bowl.urdf'

        # Initialize a list to store the bowl object IDs
        bowl_ids = []

        # Add the bowls to the environment
        for color in bowl_colors:
            # Get a random pose for the bowl
            bowl_pose = self.get_random_pose(env, bowl_size)
            # Add the bowl object to the environment with the specified color
            bowl_id = env.add_object(bowl_urdf, bowl_pose, color=utils.COLORS[color])
            bowl_ids.append(bowl_id)

        # Define the target poses for the bowls on the stand
        # The bowls are stacked upside down, so we adjust the z-coordinate accordingly
        z_offset = bowl_size[2]  # Height of the bowl
        targ_poses = [
            (stand_pose[0], stand_pose[1]),  # Base bowl directly on the stand
            (stand_pose[0], stand_pose[1] + np.array([0, 0, z_offset])),  # Second bowl
            (stand_pose[0], stand_pose[1] + np.array([0, 0, 2 * z_offset])),  # Top bowl
        ]

        # Add goals for each bowl to be stacked on the stand
        for i, bowl_id in enumerate(bowl_ids):
            # Define the language goal for the current step
            location = "top" if i > 0 else "base"
            language_goal = self.lang_template.format(color=bowl_colors[i], location=location)
            # Add the goal for the current bowl
            self.add_goal(
                objs=[bowl_id],
                matches=np.ones((1, 1)),  # Each bowl has a unique target pose
                targ_poses=[targ_poses[i]],  # Target pose for the current bowl
                replace=False,  # Bowls should not be replaced once placed
                rotations=False,  # Rotation is not considered for this task
                metric='pose',  # We use pose metric to evaluate the placement
                params=None,  # No additional parameters needed
                step_max_reward=1 / 3,  # Equal reward for each step, summing to 1
                language_goal=language_goal  # Language goal for the current step
            )