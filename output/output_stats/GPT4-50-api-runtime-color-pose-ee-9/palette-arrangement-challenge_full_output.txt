

================= Task and Asset Design!

>>> Prompt: 
You are an AI in robot simulation code and task design. I will provide you some example tasks, code implementation, and some guidelines for how to generate tasks and then you will help me generate a new task. My goal is to design diverse and feasible tasks for tabletop manipulation. I will first ask you to describe the task in natural languages and then will let you write the code for it. 

=========
Here are all the assets. Use only these assets in the task and code design. 
"""
insertion/:
ell.urdf  fixture.urdf

bowl/:
bowl.urdf

box/:
box-template.urdf

stacking/:
block.urdf  stand.urdf

zone/:
zone.obj  zone.urdf

pallet/:
pallet.obj  pallet.urdf

ball/:
ball-template.urdf

cylinder/:
cylinder-template.urdf

bowl/:
bowl.urdf

# assets not for picking
corner/:
corner-template.urdf

line/:
single-green-line-template.urdf

container/:
container-template.urdf
"""
 
=========
Here are some examples of good tasks. Try to learn from these structures but avoid overlapping wiht them.

{"assets-used": ["zone/zone.urdf", "block/small.urdf"],
 "task-description": "Push piles of small objects into a target goal zone marked on the tabletop.",
 "task-name": "sweeping-piles"}

{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "Place all blocks of a specified color in a bowl of specified color.",
 "task-name": "put-block-in-bowl"}
 
{"assets-used": ["insertion/ell.urdf", "insertion/fixture.urdf"],
 "task-description": "pick up the L-shaped red block and place it into the L-shaped fixture.",
 "task-name": "block-insertion"}
 
{"assets-used": ["kitting/kit.urdf", "kitting/object-template.urdf"],
 "task-description": "pick up different objects and arrange them on a board marked with corresponding silhouettes.",
 "task-name": "assembling-kits"}
 
{"assets-used": ["pallet/pallet.urdf", "box/box-template.urdf"],
 "task-description": "pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.",
 "task-name": "palletizing-boxes"}
 
{"assets-used": ["stacking/stand.urdf", "stacking/block.urdf"],
 "task-description": "sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.",
 "task-name": "stack-block-pyramid"}
 
{"assets-used": ["container/container-template.urdf", "box/box-template.urdf"],
 "task-description": "pick up randomly sized boxes and place them tightly into a container.",
 "task-name": "packing-boxes"}
 
{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "pick up the red blocks and place them into the green bowls amidst other objects.",
 "task-name": "place-red-in-green"}
 
{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

=========
Here are some tasks that you have come up with before. Try to learn from these structures but avoid overlapping with these tasks. For instance, `bowl_ball_placement` and `sort_balls_in_bowls` are the same task. `pile_boxes_in_corner` and `stack_blocks_into_pallet` are similar tasks, `align-cylinder-in-corner` and `align-cylinder-corner` are similar.
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- stack-block-pyramid: {'assets-used': ['stacking/stand.urdf', 'stacking/block.urdf'], 'task-description': 'sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.', 'task-name': 'stack-block-pyramid'}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}





=========
Here are some bad example task instances with explanations.
{
    "task_name": "sort-color-blocks",
    "task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "box/box-template.urdf],
}
reasons: not interesting because it overlaps with the current task `put-block-in-bowl`.

{
    "task-name": "guided-ball-maze",
    "task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
    "assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
}
reasons: the language descriptions are too ambiguous. Navigation is also hard to complete. Also maze.urf does not exist.

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
}
reasons: this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere. Similarly tasks like `insert-ball-into-cylinder` and `cylinder-box-insertion` are invalid.

{
    "task-name": "ball-box-obstacle-course",
    "task-description": "Navigate a ball through an obstacle course created by randomly placed boxes and finally place it inside a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: Navigate the ball is not related to tabletop manipulation tasks.

{
    "task-name": "ball-in-box",
    "task-description": "Use a cable to guide a ball into an open box.",
    "assets-used": ["cable/cable.urdf", "ball/ball-template.urdf", "box/box-template.urdf"]
}
reasons: This task is too hard since it involves interaction of the cable and the ball and cannot be easily completed.

{
    "task-name": "ball-in-container",
    "task-description": "Use the spatula to lift a ball over a wall of boxes and drop it into a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: The only action primitives as pick and place. One cannot use a spatula to lift an object.

{
    "task-name": "line-ball-sorting",
    "task-description": "Move balls of different colors along a single green line, placing each ball in a designated colored box at the end of the line. The challenge includes precision in maintaining the ball on the line and the correct identification of the box color corresponding to each ball.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf"]
}
reasons: Piling or stacking balls are physically infeasible in the simulation.



=========
Now please describe the new task in natural languages and explain its novelty and challenges. Format the answer in a python dictionary with keys "task-name" and value type string, "task-description" (one specific sentence) and value type string, and "assets-used" and value type list of strings. Note that

- Do not use assets that are not in the list above. 
- Tasks that have more colors and shapes are interesting.
- Be as specific as possible about the number, shape, and color of each asset in the task descriptions. 
- The task need to obey physics and remain feasible.





>>> Answer: 
Based on your guidelines and the assets available, here's a new task description in natural language:

Task Name: "Cylinder Hurdle Arrangement"

Task Description: "Arrange a set of six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the obstacles placed between them."

Assets Used:
- cylinder/cylinder-template.urdf
- stacking/stand.urdf
- box/box-template.urdf

Novelty:
The novelty of this task lies in the requirement to sequence objects based on a non-visible attribute (height) while navigating obstacles. The color differentiation adds an extra layer of visual complexity, and the gradient in stand heights requires precise manipulation skills.

Challenges:
- Identifying each cylinder's height and placing them in the correct order on the stands.
- Manipulating the robot to navigate and reach over or around the box obstacles placed between the cylinders and stands.
- Precise control to place the cylinders on the stands without knocking them over.

Here's the dictionary format of the task description:

```python
{
    "task-name": "cylinder-hurdle-arrangement",
    "task-description": "Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.",
    "assets-used": ["cylinder/cylinder-template.urdf", "stacking/stand.urdf", "box/box-template.urdf"]
}
```

================= API Preview!

>>> Prompt: 
Before writing the code for the task "cylinder-hurdle-arrangement". Here are some APIs that are defined. Please confirm that you understand these APIs.

"""
class Task():
    """Base Task class."""

    def __init__(self):
        self.ee = Suction
        self.mode = 'train'
        self.sixdof = False
        self.primitive = primitives.PickPlace()
        self.oracle_cams = cameras.Oracle.CONFIG

        # Evaluation epsilons (for pose evaluation metric).
        self.pos_eps = 0.01
        self.rot_eps = np.deg2rad(15)

        # Workspace bounds.
        self.pix_size = 0.003125
        self.bounds = np.array([[0.25, 0.75], [-0.5, 0.5], [0, 0.3]])
        self.zone_bounds = np.copy(self.bounds)

        self.goals = []
        self.lang_goals = []
        self.task_completed_desc = "task completed."
        self.progress = 0
        self._rewards = 0
        self.assets_root = None

    def reset(self, env):
        if not self.assets_root:
            raise ValueError('assets_root must be set for task, '
                             'call set_assets_root().')
        self.goals = []
        self.lang_goals = []
        self.progress = 0  # Task progression metric in range [0, 1].
        self._rewards = 0  # Cumulative returned rewards.

    # -------------------------------------------------------------------------
    # Oracle Agent
    # -------------------------------------------------------------------------

    def oracle(self, env):
        """Oracle agent."""
        OracleAgent = collections.namedtuple('OracleAgent', ['act'])

        def act(obs, info):
            """Calculate action."""

            # Oracle uses perfect RGB-D orthographic images and segmentation masks.
            _, hmap, obj_mask = self.get_true_image(env)

            # Unpack next goal step.
            objs, matches, targs, replace, rotations, _, _, _ = self.goals[0]

            # Match objects to targets without replacement.
            if not replace:

                # Modify a copy of the match matrix.
                matches = matches.copy()

                # Ignore already matched objects.
                for i in range(len(objs)):
                    object_id, (symmetry, _) = objs[i]
                    pose = p.getBasePositionAndOrientation(object_id)
                    targets_i = np.argwhere(matches[i, :]).reshape(-1)
                    for j in targets_i:
                        if self.is_match(pose, targs[j], symmetry):
                            matches[i, :] = 0
                            matches[:, j] = 0

            # Get objects to be picked (prioritize farthest from nearest neighbor).
            nn_dists = []
            nn_targets = []
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                xyz, _ = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                if len(targets_i) > 0:
                    targets_xyz = np.float32([targs[j][0] for j in targets_i])
                    dists = np.linalg.norm(
                        targets_xyz - np.float32(xyz).reshape(1, 3), axis=1)
                    nn = np.argmin(dists)
                    nn_dists.append(dists[nn])
                    nn_targets.append(targets_i[nn])

                # Handle ignored objects.
                else:
                    nn_dists.append(0)
                    nn_targets.append(-1)
            order = np.argsort(nn_dists)[::-1]

            # Filter out matched objects.
            order = [i for i in order if nn_dists[i] > 0]

            pick_mask = None
            for pick_i in order:
                pick_mask = np.uint8(obj_mask == objs[pick_i][0])

                # Erode to avoid picking on edges.
                # pick_mask = cv2.erode(pick_mask, np.ones((3, 3), np.uint8))

                if np.sum(pick_mask) > 0:
                    break

            # Trigger task reset if no object is visible.
            if pick_mask is None or np.sum(pick_mask) == 0:
                self.goals = []
                self.lang_goals = []
                print('Object for pick is not visible. Skipping demonstration.')
                return

            # Get picking pose.
            pick_prob = np.float32(pick_mask)
            pick_pix = utils.sample_distribution(pick_prob)
            # For "deterministic" demonstrations on insertion-easy, use this:
            # pick_pix = (160,80)
            pick_pos = utils.pix_to_xyz(pick_pix, hmap,
                                        self.bounds, self.pix_size)
            pick_pose = (np.asarray(pick_pos), np.asarray((0, 0, 0, 1)))

            # Get placing pose.
            targ_pose = targs[nn_targets[pick_i]]
            obj_pose = p.getBasePositionAndOrientation(objs[pick_i][0])
            if not self.sixdof:
                obj_euler = utils.quatXYZW_to_eulerXYZ(obj_pose[1])
                obj_quat = utils.eulerXYZ_to_quatXYZW((0, 0, obj_euler[2]))
                obj_pose = (obj_pose[0], obj_quat)
            world_to_pick = utils.invert(pick_pose)
            obj_to_pick = utils.multiply(world_to_pick, obj_pose)
            pick_to_obj = utils.invert(obj_to_pick)
            place_pose = utils.multiply(targ_pose, pick_to_obj)

            # Rotate end effector?
            if not rotations:
                place_pose = (place_pose[0], (0, 0, 0, 1))

            place_pose = (np.asarray(place_pose[0]), np.asarray(place_pose[1]))

            return {'pose0': pick_pose, 'pose1': place_pose}

        return OracleAgent(act)

    # -------------------------------------------------------------------------
    # Reward Function and Task Completion Metrics
    # -------------------------------------------------------------------------

    def reward(self):
        """Get delta rewards for current timestep.

        Returns:
          A tuple consisting of the scalar (delta) reward, plus `extras`
            dict which has extra task-dependent info from the process of
            computing rewards that gives us finer-grained details. Use
            `extras` for further data analysis.
        """
        reward, info = 0, {}

        # Unpack next goal step.
        objs, matches, targs, _, _, metric, params, max_reward = self.goals[0]

        # Evaluate by matching object poses.
        if metric == 'pose':
            step_reward = 0
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                pose = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                for j in targets_i:
                    target_pose = targs[j]
                    if self.is_match(pose, target_pose, symmetry):
                        step_reward += max_reward / len(objs)
                        print(f"object {i} match with target {j} rew: {step_reward}")
                        break

        # Evaluate by measuring object intersection with zone.
        elif metric == 'zone':
            zone_pts, total_pts = 0, 0
            obj_pts, zones = params
            for zone_idx, (zone_pose, zone_size) in enumerate(zones):

                # Count valid points in zone.
                for obj_idx, obj_id in enumerate(obj_pts):
                    pts = obj_pts[obj_id]
                    obj_pose = p.getBasePositionAndOrientation(obj_id)
                    world_to_zone = utils.invert(zone_pose)
                    obj_to_zone = utils.multiply(world_to_zone, obj_pose)
                    pts = np.float32(utils.apply(obj_to_zone, pts))
                    if len(zone_size) > 1:
                        valid_pts = np.logical_and.reduce([
                            pts[0, :] > -zone_size[0] / 2, pts[0, :] < zone_size[0] / 2,
                            pts[1, :] > -zone_size[1] / 2, pts[1, :] < zone_size[1] / 2,
                            pts[2, :] < self.zone_bounds[2, 1]])

                    # if zone_idx == matches[obj_idx].argmax():
                    zone_pts += np.sum(np.float32(valid_pts))
                    total_pts += pts.shape[1]
            step_reward = max_reward * (zone_pts / total_pts)

        # Get cumulative rewards and return delta.
        reward = self.progress + step_reward - self._rewards
        self._rewards = self.progress + step_reward

        # Move to next goal step if current goal step is complete.
        if np.abs(max_reward - step_reward) < 0.01:
            self.progress += max_reward  # Update task progress.
            self.goals.pop(0)
            if len(self.lang_goals) > 0:
                self.lang_goals.pop(0)

        return reward, info

    def done(self):
        """Check if the task is done or has failed.

        Returns:
          True if the episode should be considered a success, which we
            use for measuring successes, which is particularly helpful for tasks
            where one may get successes on the very last time step, e.g., getting
            the cloth coverage threshold on the last alllowed action.
            However, for bag-items-easy and bag-items-hard (which use the
            'bag-items' metric), it may be necessary to filter out demos that did
            not attain sufficiently high reward in external code. Currently, this
            is done in `main.py` and its ignore_this_demo() method.
        """
        return (len(self.goals) == 0) or (self._rewards > 0.99)
        # return zone_done or defs_done or goal_done

    # -------------------------------------------------------------------------
    # Environment Helper Functions
    # -------------------------------------------------------------------------

    def is_match(self, pose0, pose1, symmetry):
        """Check if pose0 and pose1 match within a threshold."""

        # Get translational error.
        diff_pos = np.float32(pose0[0][:2]) - np.float32(pose1[0][:2])
        dist_pos = np.linalg.norm(diff_pos)

        # Get rotational error around z-axis (account for symmetries).
        diff_rot = 0
        if symmetry > 0:
            rot0 = np.array(utils.quatXYZW_to_eulerXYZ(pose0[1]))[2]
            rot1 = np.array(utils.quatXYZW_to_eulerXYZ(pose1[1]))[2]
            diff_rot = np.abs(rot0 - rot1) % symmetry
            if diff_rot > (symmetry / 2):
                diff_rot = symmetry - diff_rot

        return (dist_pos < self.pos_eps) and (diff_rot < self.rot_eps)

    def get_random_pose(self, env, obj_size):
        """Get random collision-free object pose within workspace bounds."""

        # Get erosion size of object in pixels.
        max_size = np.sqrt(obj_size[0] ** 2 + obj_size[1] ** 2)
        erode_size = int(np.round(max_size / self.pix_size))

        _, hmap, obj_mask = self.get_true_image(env)

        # Randomly sample an object pose within free-space pixels.
        free = np.ones(obj_mask.shape, dtype=np.uint8)
        for obj_ids in env.obj_ids.values():
            for obj_id in obj_ids:
                free[obj_mask == obj_id] = 0
        free[0, :], free[:, 0], free[-1, :], free[:, -1] = 0, 0, 0, 0
        free = cv2.erode(free, np.ones((erode_size, erode_size), np.uint8))

        # if np.sum(free) == 0:
        #     return None, None

        if np.sum(free) == 0:
            # avoid returning None, None
            # return None, None
            pix = (obj_mask.shape[0] // 2, obj_mask.shape[1] // 2)
        else:
            pix = utils.sample_distribution(np.float32(free))
        pos = utils.pix_to_xyz(pix, hmap, self.bounds, self.pix_size)
        pos = (pos[0], pos[1], obj_size[2] / 2)
        theta = np.random.rand() * 2 * np.pi
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta))
        return pos, rot

    def get_lang_goal(self):
        if len(self.lang_goals) == 0:
            return self.task_completed_desc
        else:
            return self.lang_goals[0]

    def get_reward(self):
        return float(self._rewards)

    # -------------------------------------------------------------------------
    # Helper Functions
    # -------------------------------------------------------------------------

    def fill_template(self, template, replace):
        """Read a file and replace key strings."""
        full_template_path = os.path.join(self.assets_root, template)
        with open(full_template_path, 'r') as file:
            fdata = file.read()
        for field in replace:
            for i in range(len(replace[field])):
                fdata = fdata.replace(f'{field}{i}', str(replace[field][i]))
        alphabet = string.ascii_lowercase + string.digits
        rname = ''.join(random.choices(alphabet, k=16))
        tmpdir = tempfile.gettempdir()
        template_filename = os.path.split(template)[-1]
        fname = os.path.join(tmpdir, f'{template_filename}.{rname}')
        with open(fname, 'w') as file:
            file.write(fdata)
        return fname

    def get_random_size(self, min_x, max_x, min_y, max_y, min_z, max_z):
        """Get random box size."""
        size = np.random.rand(3)
        size[0] = size[0] * (max_x - min_x) + min_x
        size[1] = size[1] * (max_y - min_y) + min_y
        size[2] = size[2] * (max_z - min_z) + min_z
        return tuple(size)

    def color_random_brown(self, obj):
        shade = np.random.rand() + 0.5
        color = np.float32([shade * 156, shade * 117, shade * 95, 255]) / 255
        p.changeVisualShape(obj, -1, rgbaColor=color)

  """""
  
  # Environment Class
  def add_object(self, urdf, pose, category='rigid'):
    """List of (fixed, rigid, or deformable) objects in env."""
    fixed_base = 1 if category == 'fixed' else 0
    obj_id = pybullet_utils.load_urdf(
        p,
        os.path.join(self.assets_root, urdf),
        pose[0],
        pose[1],
        useFixedBase=fixed_base)
    self.obj_ids[category].append(obj_id)
    return obj_id
"""

=========
Note that the objects need to obey physics and not collide with each other, and the object goal poses need to be above the table with lower bound x=0.25, y=-0.5 and upper bound x=0.75, y=0.5. When there are multiple objects for a multi-step pick-and-place task, there are often multiple subgoals. Once the task and environment are generated, an agent with a pick and place primitive will follow the defined goal to accomplish the tasks. 

Additionally, make sure you understand and summarize the ``self.goals`` variables, which has a list of 8-tuple with (objs, matches, targ_poses, replace, rotations, metric, params, step_max_reward, symmetries).
- objs (List of obj_id): object ID.
- matches (Binary Matrix): a binary matrix that denotes which object is matched with which target. This matrix has dimension len(objs) x len(targs).
- targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation). 
- replace (Boolean): whether each object can match with one unique target. This is important if we have one target and multiple objects. If it's set to be false, then any object matching with the target will satisfy.
- rotations (Boolean): whether the placement action has a rotation degree of freedom. 
- metric (`pose` or `zone`): `pose` or `zone` that the object needs to be transported to. Example: `pose`. 
- params (List of (zone_target, zone_size)): a list of (zone_target, zone_size) for each zone if the metric is `zone`. 
- step_max_reward (float): the total reward of matching all the objects with all the target poses. It is not dependent on the number of objects but dependent on the number of goals. 
- symmetries: the radians that the object is symmetric around z axis.
- language_goal: the low-level language instructions that denote the goal of this step.
 


>>> Answer: 
I understand the provided APIs and the structure of the `Task` class, as well as the environment class method `add_object`. Here's a summary of my understanding:

The `Task` class is a base class for defining robotic tasks in a simulation environment. It initializes with default parameters for the end effector (suction), mode (training), and whether the task allows six degrees of freedom for the robot. It also sets up a pick-and-place primitive, camera configurations, evaluation metrics, workspace bounds, and other task-related variables.

The `reset` method is used to initialize or reset the task environment, and the `oracle` method provides an oracle agent that can perform the task perfectly for demonstration or testing purposes.

The `reward` method calculates the reward for the current timestep based on the task's goals and the current state of the environment. It uses the `is_match` method to determine if an object has been placed within the required tolerance of its target pose.

The `done` method checks if the task has been completed or if a failure condition has been met.

The `get_random_pose` method generates a random collision-free pose for an object within the workspace bounds, and the `fill_template` method is a utility for populating URDF templates with specific values.

The `add_object` method in the environment class is used to add objects to the simulation. It takes the object's URDF file, its pose, and its category (fixed, rigid, or deformable) as arguments.

The `self.goals` variable is a list of 8-tuples that define the subgoals for a task. Each subgoal includes:

- `objs`: A list of object IDs that are involved in the subgoal.
- `matches`: A binary matrix indicating which objects can be matched with which target poses.
- `targ_poses`: A list of target poses, each defined by a translation and rotation.
- `replace`: A boolean indicating whether objects can match with multiple targets or just one.
- `rotations`: A boolean indicating whether the placement action includes a rotation.
- `metric`: A string that specifies the evaluation metric ('pose' or 'zone').
- `params`: Additional parameters for the metric, such as zone targets and sizes if the metric is 'zone'.
- `step_max_reward`: The maximum reward for completing the subgoal.
- `symmetries`: The radians of rotational symmetry around the z-axis for the objects.
- `language_goal`: A string providing a low-level language instruction describing the subgoal.

Understanding these APIs and the structure of the `Task` class is crucial for implementing the "Cylinder Hurdle Arrangement" task. The task will involve creating a simulation environment with cylinders, stands, and obstacles, and defining the subgoals and rewards according to the task's requirements.

================= Code Generation!

>>> Prompt: 
Now I will provide you some reference code and you can write the code for the task "cylinder-hurdle-arrangement".


"""
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class PackingShapes(Task):
    """pick up randomly sized shapes and place them tightly into a container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 1
        self.homogeneous = False

        self.lang_template = "pack the {obj} in the brown box"
        self.task_completed_desc = "done packing shapes."
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        # Shape Names:
        shapes = utils.assembling_kit_shapes

        n_objects = 5
        if self.mode == 'train':
            obj_shapes = np.random.choice(self.train_set, n_objects, replace=False)
        else:
            if self.homogeneous:
                obj_shapes = [np.random.choice(self.test_set, replace=False)] * n_objects
            else:
                obj_shapes = np.random.choice(self.test_set, n_objects, replace=False)

        # Shuffle colors to avoid always picking an object of the same color
        colors, color_names = utils.get_colors(mode=self.mode)

        # Add container box.
        zone_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, zone_pose, 'fixed')

        # Add objects.
        objects = []
        template = 'kitting/object-template.urdf'
        for i in range(n_objects):
            shape = obj_shapes[i]

            # x, y, z dimensions for the asset size
            size = (0.08, 0.08, 0.02)
            pose= self.get_random_pose(env, size)
            fname = f'{shape:02d}.obj'
            fname = os.path.join(self.assets_root, 'kitting', fname)
            scale = [0.003, 0.003, 0.001]  # .0005
            replace = {'FNAME': (fname,),
                       'SCALE': scale,
                       'COLOR': colors[i]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            block_id = env.add_object(urdf, pose)
            objects.append(block_id)

        # Pick the first shape.
        num_objects_to_pick = 1
        for i in range(num_objects_to_pick):
            # IMPORTANT: Specify (obj_pts, [(zone_pose, zone_size)]) for target `zone`. obj_pts is a dict
            language_goal = self.lang_template.format(obj=shapes[obj_shapes[i]])
            self.add_goal(objs=[objects[i]], matches=np.int32([[1]]), targ_poses=[zone_pose], replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1 / num_objects_to_pick,
                language_goal=language_goal)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PlaceRedInGreen(Task):
    """pick up the red blocks and place them into the green bowls amidst other objects."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = "put the red blocks in a green bowl"
        self.task_completed_desc = "done placing blocks in bowls."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_blocks = np.random.randint(1, n_bowls + 1)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, obj_size=bowl_size)
            env.add_object(urdf=bowl_urdf, pose=bowl_pose, category='fixed')
            bowl_poses.append(bowl_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        for _ in range(n_blocks):
            block_pose = self.get_random_pose(env, obj_size=block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Goal: each red block is in a different green bowl.
        self.add_goal(objs=blocks, matches=np.ones((len(blocks), len(bowl_poses))), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

        # Colors of distractor objects.
        bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'green']
        block_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'red']

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = block_colors if is_block else bowl_colors
            pose = self.get_random_pose(env, obj_size=size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1
"""
"""
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils


class SweepingPiles(Task):
    """Push piles of small objects into a target goal zone marked on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = "push the pile of blocks into the green square"
        self.task_completed_desc = "done sweeping."
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add goal zone.
        zone_size = (0.12, 0.12, 0)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add pile of small blocks with `make_piles` function
        obj_ids = self.make_piles(env)

        # Add goal
        self.add_goal(objs=obj_ids, matches=np.ones((50, 1)), targ_poses=[zone_pose], replace=True,
                rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class StackBlockPyramid(Task):
    """Build a pyramid of colored blocks in a color sequence"""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = "make the {row} row with {blocks}"
        self.task_completed_desc = "done stacking block pyramid."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['red']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, blue, purple).
        language_goal = self.lang_template.format(blocks="the green, blue and purple blocks", row="bottom")
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (middle row: yellow, orange).
        language_goal = self.lang_template.format(blocks="the yellow and orange blocks", row="middle")      
        self.add_goal(objs=objs[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (top row: red).
        language_goal = self.lang_template.format(blocks="the red block", row="top")
        self.add_goal(objs=objs[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2]*1, language_goal=language_goal)
"""



Do not use libraries, functions, and assets that you don't know. For each object, try to describe its color, size, category in the task first before you write the code. You do not need extra helper functions. Comment the code liberally to explain what each piece does and why it's written that way. If you have only one goal, `step_max_reward` in `add_goal` should be 1. Use functions `make_piles` and `make_ropes` for creating piles and cables. To use spatula together with the push primitives, import the libraries 
"""
from cliport.tasks import primitives;
from cliport.tasks.grippers import Spatula
"""
and then use `self.primitive = primitives.push` and `self.ee = Spatula`.
Note that the number of language goals usually match the number of motion goals, since they should correspond to each other.

Before generate code, you have a few considerations to focus on:
1. You are strictly prohibited from using function interfaces that do not appear in the above sample code. For example, the module cliport.tasks.primitives does not have pick_plack or place functions, only the push function interface is available.
2. Module 'cliport.tasks.primitives' has no attribute 'pick_place', you mustn't use it.
3. There are two types of your Gripper, one is Spatula and the other is Suction.You need to choose a different end-effector depending on your task requirements. If you need to move an object on the Z axis, then you need to use the Suction type. If you just need to translate an object in a 2D plane, then you can use either Spatula or Suction type.
4. You must determine the type of end-effector you need to use based on the type of task you have. You can choose by adding self.ee=Spatula or self.ee=Suction to the __init__(self) function, the default self.ee is Suction.
5. If you want to use Suction, you must import module using "from cliport.tasks.grippers import Suction". Else if you want to use Spatula, you must import module using "from cliport.tasks.grippers import Spatula".
6. The x-coordinate of the object is in the range [0.25, 0.75], the y-coordinate is in the range [-0.5,0.5] and the z-coordinate is in the range [0, 0.3].
7. The initial position of all objects needs to get its random initial position through the get_random_pose function.
8. The self.max_steps parameter value should be greater than the number of calls to self.add_goal, and preferably equal to twice the number of calls to self.add_goal. For example, if you call self.add_goal twice in one task, then self.max_steps is better set to 4.

If you want to generate the color of the object, you have to obey following rules:
1. You must use the utils.COLORS['COLOR_NAME'] function interface to generate an RGB three-channel value for a color.
2. The available colors for 'COLOR_NAME' are blue, red, green, orange, yellow, purple, pink, cyan, brown, white, gray, indigo, violet, black, silver and gold.
3. If you want to generate a red object, then its RGB three-channel color can be obtained through utils.COLORS['red'].
All object’s colors generation must follow color generation method above.

If you want to generate the target pose of the object(third parameter of function 'self.add_goal' targ_poses), you have to obey following rules:
1. The target pose of an object is represented by the three-dimensional spatial coordinates of the object and its orientation quaternion.
2. The target pose of an object must be represented by [(x,y,z),(q1,q2,q3,q4)]. Where (x,y,z) are the three-dimensional coordinates of the object and (q1,q2,q3,q4) denote the quaternions of the object's target pose.
3. The target pose of an object must be generated by you or use the initial pose of an object as the target pose of the current object.
4. Here's an example, to generate the target pose of a Y object, we have the initial pose information of an X object. So target pose of Y can be represented by pose_y=[(x,y,z),(q1,q2,q3,q4)] or pose_y=initial_pose_x.(Where x,y,z,q1,q2,q3,q4 are specific values.)
5. targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation).
6. The targ_poses you generate must contain translation[x,y,z], but rotation[q0,q1,q2,q3] you may or may not generate.
All object's target pose generation must follow method above.

Now write the code for the task "cylinder-hurdle-arrangement" in python code block starting with ```python.  Reminder: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']} 


>>> Answer: 
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderHurdleArrangement(Task):
    """
    Arrange six different colored cylinders in ascending order of height over a sequence of three
    increasingly tall stands while avoiding the box obstacles placed between them.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We have six cylinders to arrange, so we set max_steps to twice the number of goals.
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector.
        self.lang_template = "place the {color} cylinder on the {height} stand"
        self.task_completed_desc = "done arranging cylinders."

    def reset(self, env):
        super().reset(env)

        # Define the colors and sizes for the cylinders and stands.
        cylinder_colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple']
        cylinder_heights = [0.06, 0.08, 0.10, 0.12, 0.14, 0.16]  # Ascending order of heights.
        stand_heights = [0.10, 0.15, 0.20]  # Increasing stand heights.
        box_size = (0.05, 0.05, 0.05)  # Size of the box obstacles.

        # Add stands.
        stand_urdf = 'stacking/stand.urdf'
        stand_poses = []
        for i, stand_height in enumerate(stand_heights):
            stand_size = (0.05, 0.05, stand_height)
            stand_pose = self.get_random_pose(env, stand_size)
            env.add_object(stand_urdf, stand_pose, 'fixed')
            stand_poses.append(stand_pose)

        # Add cylinders.
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for i, (color_name, height) in enumerate(zip(cylinder_colors, cylinder_heights)):
            cylinder_size = (0.02, 0.02, height)
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            color = utils.COLORS[color_name]
            replace = {'DIM': cylinder_size, 'COLOR': color}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            cylinders.append((cylinder_id, color_name))

        # Add box obstacles.
        box_template = 'box/box-template.urdf'
        for _ in range(3):  # Three box obstacles.
            box_pose = self.get_random_pose(env, box_size)
            replace = {'DIM': box_size}
            box_urdf = self.fill_template(box_template, replace)
            env.add_object(box_urdf, box_pose, 'rigid')

        # Add goals for each cylinder to be placed on the stands in ascending order of height.
        for i, (cylinder_id, color_name) in enumerate(cylinders):
            # The target stand is chosen based on the cylinder's height (shortest to tallest).
            target_stand_pose = stand_poses[i // 2]  # Three stands, two cylinders per stand.
            language_goal = self.lang_template.format(color=color_name, height=f"{stand_heights[i // 2]}m stand")
            self.add_goal(objs=[cylinder_id], matches=np.int32([[1]]), targ_poses=[target_stand_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1,
                          language_goal=language_goal)
```

This code defines a task where six cylinders of different colors and heights must be arranged on three stands of increasing height. The cylinders must be placed in ascending order of their height, and the task involves avoiding obstacles represented by boxes. The Suction end-effector is used to move the cylinders vertically onto the stands. Each cylinder is associated with a goal that includes its target stand pose, and the language goal provides a description of the task for that cylinder. The `max_steps` is set to 6, which is twice the number of goals, allowing for a sequence of actions to complete the task.

================= TRIAL: 1

================= Code Reflect!

>>> Prompt: 


Do you think your task is sufficently interesting to be added as a new task for future task given that we already have the following task name and descriptions? Moreover, does the simulation code achieve the goal and the language descriptions in the task? Be as rigorous and high-standard as possible.

Reminder:
your task:
{'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}

import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderHurdleArrangement(Task):
    """
    Arrange six different colored cylinders in ascending order of height over a sequence of three
    increasingly tall stands while avoiding the box obstacles placed between them.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We have six cylinders to arrange, so we set max_steps to twice the number of goals.
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector.
        self.lang_template = "place the {color} cylinder on the {height} stand"
        self.task_completed_desc = "done arranging cylinders."

    def reset(self, env):
        super().reset(env)

        # Define the colors and sizes for the cylinders and stands.
        cylinder_colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple']
        cylinder_heights = [0.06, 0.08, 0.10, 0.12, 0.14, 0.16]  # Ascending order of heights.
        stand_heights = [0.10, 0.15, 0.20]  # Increasing stand heights.
        box_size = (0.05, 0.05, 0.05)  # Size of the box obstacles.

        # Add stands.
        stand_urdf = 'stacking/stand.urdf'
        stand_poses = []
        for i, stand_height in enumerate(stand_heights):
            stand_size = (0.05, 0.05, stand_height)
            stand_pose = self.get_random_pose(env, stand_size)
            env.add_object(stand_urdf, stand_pose, 'fixed')
            stand_poses.append(stand_pose)

        # Add cylinders.
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for i, (color_name, height) in enumerate(zip(cylinder_colors, cylinder_heights)):
            cylinder_size = (0.02, 0.02, height)
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            color = utils.COLORS[color_name]
            replace = {'DIM': cylinder_size, 'COLOR': color}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            cylinders.append((cylinder_id, color_name))

        # Add box obstacles.
        box_template = 'box/box-template.urdf'
        for _ in range(3):  # Three box obstacles.
            box_pose = self.get_random_pose(env, box_size)
            replace = {'DIM': box_size}
            box_urdf = self.fill_template(box_template, replace)
            env.add_object(box_urdf, box_pose, 'rigid')

        # Add goals for each cylinder to be placed on the stands in ascending order of height.
        for i, (cylinder_id, color_name) in enumerate(cylinders):
            # The target stand is chosen based on the cylinder's height (shortest to tallest).
            target_stand_pose = stand_poses[i // 2]  # Three stands, two cylinders per stand.
            language_goal = self.lang_template.format(color=color_name, height=f"{stand_heights[i // 2]}m stand")
            self.add_goal(objs=[cylinder_id], matches=np.int32([[1]]), targ_poses=[target_stand_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1,
                          language_goal=language_goal)

current task list:
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- stack-block-pyramid: {'assets-used': ['stacking/stand.urdf', 'stacking/block.urdf'], 'task-description': 'sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.', 'task-name': 'stack-block-pyramid'}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}




=========
Reply explain your reasons and then say True or False, formatted in a python dictionary, do not miss commas or add extra spaces. Here are some examples.

{
	"task_name": "sort-color-blocks",
	"task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "yellow-bowl.urdf", "box/box-template.urdf],
	"reasons": "not interesting because it overlaps with the current task `put-block-in-bowl`"
	"add_to_the_task_list": "False",
}

{
  	"task-name": "guided-ball-maze",
  	"task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
  	"assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
   	"reasons": "the language descriptions are too ambiguous. Navigation is also hard to complete."
  	"add_to_the_task_list": "False",  
}

{
 	"task-name": "sort-blocks-by-zone",
 	"task-description": "Sort different colored blocks into their corresponding colored zones marked on the tabletop.",
 	"assets-used": ["zone/zone.urdf", "stacking/block.urdf"],
	"reasons": "the task is not covered in the current list and is an interesting combination of zone and block objects." 
	"add_to_the_task_list": "True",
}

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
    "reasons": "this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "arrange-blocks-on-pallet",
    "task-description": "arrange the blocks on the pallet in the order: red, orange, yellow, green, blue, and purple.",
    "assets-used": ["stacking/block.urdf", "pallet/pallelt.urdf"],
    "reasons": "this task overlaps with `arrange-boxes-on-pallet` by merely changing the blocks to boxes.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "cylinder-color-alignment",
    "task-description": "Pick up cylinders of different colors and align them inside a box in the order of the colors displayed on the single green line on the tabletop.",
    "assets-used": ["cylinder/cylinder-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf   
    "reasons": "the execution code only has one goal, i.e. it will only move one cylinder on top of the box, which is not that interesting.", 
    "add_to_the_task_list": "False","]
}

{
    "task-name": "build-bridge",
    "task-description": "Construct a bridge using two yellow blocks and three blue blocks. Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between. Then, place the blue block horizontally on top of the yellow blocks.",
     "assets-used": ["block/block.urdf", "ball/ball-template.urdf"]
    "reasons": "this task is an interesting and long-horizon task for pick and place primitives. Training manipulation agent with this skill will be a useful building block for next skills.", 
    "add_to_the_task_list": "True",
}

=========

Please incorporate these feedbacks when you design new task!



>>> Answer: 
{
    "task-name": "cylinder-hurdle-arrangement",
    "task-description": "Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.",
    "assets-used": ["cylinder/cylinder-template.urdf", "stacking/stand.urdf", "box/box-template.urdf"],
    "reasons": "The task introduces a unique challenge by combining color differentiation, size-based ordering, and obstacle avoidance, which are not collectively covered in the existing tasks. It also provides a clear language description for each step, aligning with the goal of the task. The simulation code appears to correctly set up the environment, cylinders, stands, and obstacles, and it defines goals that match the task description. However, the max_steps being set to 6 might not be sufficient for arranging six cylinders, especially considering the presence of obstacles.",
    "add_to_the_task_list": "True",
}

================= Task and Asset Design!

>>> Prompt: 
You are an AI in robot simulation code and task design. I will provide you some example tasks, code implementation, and some guidelines for how to generate tasks and then you will help me generate a new task. My goal is to design diverse and feasible tasks for tabletop manipulation. I will first ask you to describe the task in natural languages and then will let you write the code for it. 

=========
Here are all the assets. Use only these assets in the task and code design. 
"""
insertion/:
ell.urdf  fixture.urdf

bowl/:
bowl.urdf

box/:
box-template.urdf

stacking/:
block.urdf  stand.urdf

zone/:
zone.obj  zone.urdf

pallet/:
pallet.obj  pallet.urdf

ball/:
ball-template.urdf

cylinder/:
cylinder-template.urdf

bowl/:
bowl.urdf

# assets not for picking
corner/:
corner-template.urdf

line/:
single-green-line-template.urdf

container/:
container-template.urdf
"""
 
=========
Here are some examples of good tasks. Try to learn from these structures but avoid overlapping wiht them.

{"assets-used": ["zone/zone.urdf", "block/small.urdf"],
 "task-description": "Push piles of small objects into a target goal zone marked on the tabletop.",
 "task-name": "sweeping-piles"}

{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "Place all blocks of a specified color in a bowl of specified color.",
 "task-name": "put-block-in-bowl"}
 
{"assets-used": ["insertion/ell.urdf", "insertion/fixture.urdf"],
 "task-description": "pick up the L-shaped red block and place it into the L-shaped fixture.",
 "task-name": "block-insertion"}
 
{"assets-used": ["kitting/kit.urdf", "kitting/object-template.urdf"],
 "task-description": "pick up different objects and arrange them on a board marked with corresponding silhouettes.",
 "task-name": "assembling-kits"}
 
{"assets-used": ["pallet/pallet.urdf", "box/box-template.urdf"],
 "task-description": "pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.",
 "task-name": "palletizing-boxes"}
 
{"assets-used": ["stacking/stand.urdf", "stacking/block.urdf"],
 "task-description": "sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.",
 "task-name": "stack-block-pyramid"}
 
{"assets-used": ["container/container-template.urdf", "box/box-template.urdf"],
 "task-description": "pick up randomly sized boxes and place them tightly into a container.",
 "task-name": "packing-boxes"}
 
{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "pick up the red blocks and place them into the green bowls amidst other objects.",
 "task-name": "place-red-in-green"}
 
{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

=========
Here are some tasks that you have come up with before. Try to learn from these structures but avoid overlapping with these tasks. For instance, `bowl_ball_placement` and `sort_balls_in_bowls` are the same task. `pile_boxes_in_corner` and `stack_blocks_into_pallet` are similar tasks, `align-cylinder-in-corner` and `align-cylinder-corner` are similar.
- stack-block-pyramid: {'assets-used': ['stacking/stand.urdf', 'stacking/block.urdf'], 'task-description': 'sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.', 'task-name': 'stack-block-pyramid'}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- cylinder_hurdle_arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}





=========
Here are some bad example task instances with explanations.
{
    "task_name": "sort-color-blocks",
    "task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "box/box-template.urdf],
}
reasons: not interesting because it overlaps with the current task `put-block-in-bowl`.

{
    "task-name": "guided-ball-maze",
    "task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
    "assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
}
reasons: the language descriptions are too ambiguous. Navigation is also hard to complete. Also maze.urf does not exist.

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
}
reasons: this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere. Similarly tasks like `insert-ball-into-cylinder` and `cylinder-box-insertion` are invalid.

{
    "task-name": "ball-box-obstacle-course",
    "task-description": "Navigate a ball through an obstacle course created by randomly placed boxes and finally place it inside a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: Navigate the ball is not related to tabletop manipulation tasks.

{
    "task-name": "ball-in-box",
    "task-description": "Use a cable to guide a ball into an open box.",
    "assets-used": ["cable/cable.urdf", "ball/ball-template.urdf", "box/box-template.urdf"]
}
reasons: This task is too hard since it involves interaction of the cable and the ball and cannot be easily completed.

{
    "task-name": "ball-in-container",
    "task-description": "Use the spatula to lift a ball over a wall of boxes and drop it into a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: The only action primitives as pick and place. One cannot use a spatula to lift an object.

{
    "task-name": "line-ball-sorting",
    "task-description": "Move balls of different colors along a single green line, placing each ball in a designated colored box at the end of the line. The challenge includes precision in maintaining the ball on the line and the correct identification of the box color corresponding to each ball.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf"]
}
reasons: Piling or stacking balls are physically infeasible in the simulation.



=========
Now please describe the new task in natural languages and explain its novelty and challenges. Format the answer in a python dictionary with keys "task-name" and value type string, "task-description" (one specific sentence) and value type string, and "assets-used" and value type list of strings. Note that

- Do not use assets that are not in the list above. 
- Tasks that have more colors and shapes are interesting.
- Be as specific as possible about the number, shape, and color of each asset in the task descriptions. 
- The task need to obey physics and remain feasible.





>>> Answer: 
Based on the guidelines and considering the assets available, I have conceived a new task for tabletop manipulation:

```python
{
    "task-name": "cylinder-sort-and-stack",
    "task-description": "Pick up cylinders of varying heights and colors from a pallet and stack them into color-coordinated towers on designated zones.",
    "assets-used": [
        "cylinder/cylinder-template.urdf",
        "zone/zone.urdf",
        "pallet/pallet.urdf"
    ]
}
```

Novelty and Challenges:
- This task involves both sorting and precise stacking, which requires the robot to recognize and differentiate between colors as well as to handle objects of varying heights.
- The task introduces the complexity of moving objects from a confined space (a pallet) to a specific location (zones), which can test the motion planning of the robot in constrained environments.
- Stacking cylinders demands stability and dexterity, as they can easily roll or topple if not handled carefully.
- The task can be made more complex by having a time limit or by increasing the number of cylinders and zones, which would require efficient planning and execution.

================= API Preview!

>>> Prompt: 
Before writing the code for the task "cylinder-sort-and-stack". Here are some APIs that are defined. Please confirm that you understand these APIs.

"""
class Task():
    """Base Task class."""

    def __init__(self):
        self.ee = Suction
        self.mode = 'train'
        self.sixdof = False
        self.primitive = primitives.PickPlace()
        self.oracle_cams = cameras.Oracle.CONFIG

        # Evaluation epsilons (for pose evaluation metric).
        self.pos_eps = 0.01
        self.rot_eps = np.deg2rad(15)

        # Workspace bounds.
        self.pix_size = 0.003125
        self.bounds = np.array([[0.25, 0.75], [-0.5, 0.5], [0, 0.3]])
        self.zone_bounds = np.copy(self.bounds)

        self.goals = []
        self.lang_goals = []
        self.task_completed_desc = "task completed."
        self.progress = 0
        self._rewards = 0
        self.assets_root = None

    def reset(self, env):
        if not self.assets_root:
            raise ValueError('assets_root must be set for task, '
                             'call set_assets_root().')
        self.goals = []
        self.lang_goals = []
        self.progress = 0  # Task progression metric in range [0, 1].
        self._rewards = 0  # Cumulative returned rewards.

    # -------------------------------------------------------------------------
    # Oracle Agent
    # -------------------------------------------------------------------------

    def oracle(self, env):
        """Oracle agent."""
        OracleAgent = collections.namedtuple('OracleAgent', ['act'])

        def act(obs, info):
            """Calculate action."""

            # Oracle uses perfect RGB-D orthographic images and segmentation masks.
            _, hmap, obj_mask = self.get_true_image(env)

            # Unpack next goal step.
            objs, matches, targs, replace, rotations, _, _, _ = self.goals[0]

            # Match objects to targets without replacement.
            if not replace:

                # Modify a copy of the match matrix.
                matches = matches.copy()

                # Ignore already matched objects.
                for i in range(len(objs)):
                    object_id, (symmetry, _) = objs[i]
                    pose = p.getBasePositionAndOrientation(object_id)
                    targets_i = np.argwhere(matches[i, :]).reshape(-1)
                    for j in targets_i:
                        if self.is_match(pose, targs[j], symmetry):
                            matches[i, :] = 0
                            matches[:, j] = 0

            # Get objects to be picked (prioritize farthest from nearest neighbor).
            nn_dists = []
            nn_targets = []
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                xyz, _ = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                if len(targets_i) > 0:
                    targets_xyz = np.float32([targs[j][0] for j in targets_i])
                    dists = np.linalg.norm(
                        targets_xyz - np.float32(xyz).reshape(1, 3), axis=1)
                    nn = np.argmin(dists)
                    nn_dists.append(dists[nn])
                    nn_targets.append(targets_i[nn])

                # Handle ignored objects.
                else:
                    nn_dists.append(0)
                    nn_targets.append(-1)
            order = np.argsort(nn_dists)[::-1]

            # Filter out matched objects.
            order = [i for i in order if nn_dists[i] > 0]

            pick_mask = None
            for pick_i in order:
                pick_mask = np.uint8(obj_mask == objs[pick_i][0])

                # Erode to avoid picking on edges.
                # pick_mask = cv2.erode(pick_mask, np.ones((3, 3), np.uint8))

                if np.sum(pick_mask) > 0:
                    break

            # Trigger task reset if no object is visible.
            if pick_mask is None or np.sum(pick_mask) == 0:
                self.goals = []
                self.lang_goals = []
                print('Object for pick is not visible. Skipping demonstration.')
                return

            # Get picking pose.
            pick_prob = np.float32(pick_mask)
            pick_pix = utils.sample_distribution(pick_prob)
            # For "deterministic" demonstrations on insertion-easy, use this:
            # pick_pix = (160,80)
            pick_pos = utils.pix_to_xyz(pick_pix, hmap,
                                        self.bounds, self.pix_size)
            pick_pose = (np.asarray(pick_pos), np.asarray((0, 0, 0, 1)))

            # Get placing pose.
            targ_pose = targs[nn_targets[pick_i]]
            obj_pose = p.getBasePositionAndOrientation(objs[pick_i][0])
            if not self.sixdof:
                obj_euler = utils.quatXYZW_to_eulerXYZ(obj_pose[1])
                obj_quat = utils.eulerXYZ_to_quatXYZW((0, 0, obj_euler[2]))
                obj_pose = (obj_pose[0], obj_quat)
            world_to_pick = utils.invert(pick_pose)
            obj_to_pick = utils.multiply(world_to_pick, obj_pose)
            pick_to_obj = utils.invert(obj_to_pick)
            place_pose = utils.multiply(targ_pose, pick_to_obj)

            # Rotate end effector?
            if not rotations:
                place_pose = (place_pose[0], (0, 0, 0, 1))

            place_pose = (np.asarray(place_pose[0]), np.asarray(place_pose[1]))

            return {'pose0': pick_pose, 'pose1': place_pose}

        return OracleAgent(act)

    # -------------------------------------------------------------------------
    # Reward Function and Task Completion Metrics
    # -------------------------------------------------------------------------

    def reward(self):
        """Get delta rewards for current timestep.

        Returns:
          A tuple consisting of the scalar (delta) reward, plus `extras`
            dict which has extra task-dependent info from the process of
            computing rewards that gives us finer-grained details. Use
            `extras` for further data analysis.
        """
        reward, info = 0, {}

        # Unpack next goal step.
        objs, matches, targs, _, _, metric, params, max_reward = self.goals[0]

        # Evaluate by matching object poses.
        if metric == 'pose':
            step_reward = 0
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                pose = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                for j in targets_i:
                    target_pose = targs[j]
                    if self.is_match(pose, target_pose, symmetry):
                        step_reward += max_reward / len(objs)
                        print(f"object {i} match with target {j} rew: {step_reward}")
                        break

        # Evaluate by measuring object intersection with zone.
        elif metric == 'zone':
            zone_pts, total_pts = 0, 0
            obj_pts, zones = params
            for zone_idx, (zone_pose, zone_size) in enumerate(zones):

                # Count valid points in zone.
                for obj_idx, obj_id in enumerate(obj_pts):
                    pts = obj_pts[obj_id]
                    obj_pose = p.getBasePositionAndOrientation(obj_id)
                    world_to_zone = utils.invert(zone_pose)
                    obj_to_zone = utils.multiply(world_to_zone, obj_pose)
                    pts = np.float32(utils.apply(obj_to_zone, pts))
                    if len(zone_size) > 1:
                        valid_pts = np.logical_and.reduce([
                            pts[0, :] > -zone_size[0] / 2, pts[0, :] < zone_size[0] / 2,
                            pts[1, :] > -zone_size[1] / 2, pts[1, :] < zone_size[1] / 2,
                            pts[2, :] < self.zone_bounds[2, 1]])

                    # if zone_idx == matches[obj_idx].argmax():
                    zone_pts += np.sum(np.float32(valid_pts))
                    total_pts += pts.shape[1]
            step_reward = max_reward * (zone_pts / total_pts)

        # Get cumulative rewards and return delta.
        reward = self.progress + step_reward - self._rewards
        self._rewards = self.progress + step_reward

        # Move to next goal step if current goal step is complete.
        if np.abs(max_reward - step_reward) < 0.01:
            self.progress += max_reward  # Update task progress.
            self.goals.pop(0)
            if len(self.lang_goals) > 0:
                self.lang_goals.pop(0)

        return reward, info

    def done(self):
        """Check if the task is done or has failed.

        Returns:
          True if the episode should be considered a success, which we
            use for measuring successes, which is particularly helpful for tasks
            where one may get successes on the very last time step, e.g., getting
            the cloth coverage threshold on the last alllowed action.
            However, for bag-items-easy and bag-items-hard (which use the
            'bag-items' metric), it may be necessary to filter out demos that did
            not attain sufficiently high reward in external code. Currently, this
            is done in `main.py` and its ignore_this_demo() method.
        """
        return (len(self.goals) == 0) or (self._rewards > 0.99)
        # return zone_done or defs_done or goal_done

    # -------------------------------------------------------------------------
    # Environment Helper Functions
    # -------------------------------------------------------------------------

    def is_match(self, pose0, pose1, symmetry):
        """Check if pose0 and pose1 match within a threshold."""

        # Get translational error.
        diff_pos = np.float32(pose0[0][:2]) - np.float32(pose1[0][:2])
        dist_pos = np.linalg.norm(diff_pos)

        # Get rotational error around z-axis (account for symmetries).
        diff_rot = 0
        if symmetry > 0:
            rot0 = np.array(utils.quatXYZW_to_eulerXYZ(pose0[1]))[2]
            rot1 = np.array(utils.quatXYZW_to_eulerXYZ(pose1[1]))[2]
            diff_rot = np.abs(rot0 - rot1) % symmetry
            if diff_rot > (symmetry / 2):
                diff_rot = symmetry - diff_rot

        return (dist_pos < self.pos_eps) and (diff_rot < self.rot_eps)

    def get_random_pose(self, env, obj_size):
        """Get random collision-free object pose within workspace bounds."""

        # Get erosion size of object in pixels.
        max_size = np.sqrt(obj_size[0] ** 2 + obj_size[1] ** 2)
        erode_size = int(np.round(max_size / self.pix_size))

        _, hmap, obj_mask = self.get_true_image(env)

        # Randomly sample an object pose within free-space pixels.
        free = np.ones(obj_mask.shape, dtype=np.uint8)
        for obj_ids in env.obj_ids.values():
            for obj_id in obj_ids:
                free[obj_mask == obj_id] = 0
        free[0, :], free[:, 0], free[-1, :], free[:, -1] = 0, 0, 0, 0
        free = cv2.erode(free, np.ones((erode_size, erode_size), np.uint8))

        # if np.sum(free) == 0:
        #     return None, None

        if np.sum(free) == 0:
            # avoid returning None, None
            # return None, None
            pix = (obj_mask.shape[0] // 2, obj_mask.shape[1] // 2)
        else:
            pix = utils.sample_distribution(np.float32(free))
        pos = utils.pix_to_xyz(pix, hmap, self.bounds, self.pix_size)
        pos = (pos[0], pos[1], obj_size[2] / 2)
        theta = np.random.rand() * 2 * np.pi
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta))
        return pos, rot

    def get_lang_goal(self):
        if len(self.lang_goals) == 0:
            return self.task_completed_desc
        else:
            return self.lang_goals[0]

    def get_reward(self):
        return float(self._rewards)

    # -------------------------------------------------------------------------
    # Helper Functions
    # -------------------------------------------------------------------------

    def fill_template(self, template, replace):
        """Read a file and replace key strings."""
        full_template_path = os.path.join(self.assets_root, template)
        with open(full_template_path, 'r') as file:
            fdata = file.read()
        for field in replace:
            for i in range(len(replace[field])):
                fdata = fdata.replace(f'{field}{i}', str(replace[field][i]))
        alphabet = string.ascii_lowercase + string.digits
        rname = ''.join(random.choices(alphabet, k=16))
        tmpdir = tempfile.gettempdir()
        template_filename = os.path.split(template)[-1]
        fname = os.path.join(tmpdir, f'{template_filename}.{rname}')
        with open(fname, 'w') as file:
            file.write(fdata)
        return fname

    def get_random_size(self, min_x, max_x, min_y, max_y, min_z, max_z):
        """Get random box size."""
        size = np.random.rand(3)
        size[0] = size[0] * (max_x - min_x) + min_x
        size[1] = size[1] * (max_y - min_y) + min_y
        size[2] = size[2] * (max_z - min_z) + min_z
        return tuple(size)

    def color_random_brown(self, obj):
        shade = np.random.rand() + 0.5
        color = np.float32([shade * 156, shade * 117, shade * 95, 255]) / 255
        p.changeVisualShape(obj, -1, rgbaColor=color)

  """""
  
  # Environment Class
  def add_object(self, urdf, pose, category='rigid'):
    """List of (fixed, rigid, or deformable) objects in env."""
    fixed_base = 1 if category == 'fixed' else 0
    obj_id = pybullet_utils.load_urdf(
        p,
        os.path.join(self.assets_root, urdf),
        pose[0],
        pose[1],
        useFixedBase=fixed_base)
    self.obj_ids[category].append(obj_id)
    return obj_id
"""

=========
Note that the objects need to obey physics and not collide with each other, and the object goal poses need to be above the table with lower bound x=0.25, y=-0.5 and upper bound x=0.75, y=0.5. When there are multiple objects for a multi-step pick-and-place task, there are often multiple subgoals. Once the task and environment are generated, an agent with a pick and place primitive will follow the defined goal to accomplish the tasks. 

Additionally, make sure you understand and summarize the ``self.goals`` variables, which has a list of 8-tuple with (objs, matches, targ_poses, replace, rotations, metric, params, step_max_reward, symmetries).
- objs (List of obj_id): object ID.
- matches (Binary Matrix): a binary matrix that denotes which object is matched with which target. This matrix has dimension len(objs) x len(targs).
- targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation). 
- replace (Boolean): whether each object can match with one unique target. This is important if we have one target and multiple objects. If it's set to be false, then any object matching with the target will satisfy.
- rotations (Boolean): whether the placement action has a rotation degree of freedom. 
- metric (`pose` or `zone`): `pose` or `zone` that the object needs to be transported to. Example: `pose`. 
- params (List of (zone_target, zone_size)): a list of (zone_target, zone_size) for each zone if the metric is `zone`. 
- step_max_reward (float): the total reward of matching all the objects with all the target poses. It is not dependent on the number of objects but dependent on the number of goals. 
- symmetries: the radians that the object is symmetric around z axis.
- language_goal: the low-level language instructions that denote the goal of this step.
 


>>> Answer: 
I understand the provided APIs and their functionalities. Here's a summary of my understanding:

The `Task` class is a base class for defining a robotic task in a simulated environment. It initializes with default parameters for the end effector, mode, six degrees of freedom (DoF) capability, a pick-and-place primitive, and camera configurations. It also defines evaluation metrics for pose accuracy and workspace bounds.

The `reset` method is used to initialize or reset the task environment, setting up goals and progress metrics.

The `oracle` method provides an oracle agent that can generate perfect actions based on the current state of the environment. This agent uses an idealized perception of the environment to determine the best pick-and-place actions to achieve the task goals.

The `reward` method calculates the reward for the current timestep based on the task's progress towards its goals. It uses different metrics such as 'pose' or 'zone' to evaluate the success of actions taken by the agent.

The `done` method checks whether the task has been completed successfully or if it has failed.

The `is_match` helper function determines if two poses match within a specified tolerance, considering both position and rotation.

The `get_random_pose` method generates a random collision-free pose for an object within the workspace bounds.

The `get_lang_goal` method retrieves the current language-based goal description.

The `get_reward` method returns the cumulative reward earned so far in the task.

The `fill_template` method is a utility for reading and replacing key strings in a file template.

The `get_random_size` method generates a random size for an object within specified bounds.

The `color_random_brown` method assigns a random brown color to an object.

The `add_object` method in the `Environment` class is used to add objects to the simulation environment, specifying their URDF file, pose, and whether they are fixed, rigid, or deformable.

The `self.goals` variable is a list of 8-tuples that define the subgoals for a task. Each tuple contains the following elements:

- `objs`: A list of object IDs.
- `matches`: A binary matrix indicating which objects are matched with which targets.
- `targ_poses`: A list of target poses, each consisting of a translation and rotation.
- `replace`: A boolean indicating whether objects can match with multiple targets or only one unique target.
- `rotations`: A boolean indicating whether the placement action includes a rotation DoF.
- `metric`: A string ('pose' or 'zone') specifying the type of goal metric.
- `params`: A list of parameters for the goal metric, such as zone targets and sizes.
- `step_max_reward`: The maximum reward for completing the current subgoal.
- `symmetries`: The radians of rotational symmetry around the z-axis for the objects.
- `language_goal`: A string providing a low-level language instruction for the current subgoal.

Understanding these APIs is crucial for writing the code for the "cylinder-sort-and-stack" task, as they provide the necessary functions and methods to interact with the simulation environment, define task goals, and evaluate the agent's performance.

================= Code Generation!

>>> Prompt: 
Now I will provide you some reference code and you can write the code for the task "cylinder-sort-and-stack".


"""
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class PackingShapes(Task):
    """pick up randomly sized shapes and place them tightly into a container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 1
        self.homogeneous = False

        self.lang_template = "pack the {obj} in the brown box"
        self.task_completed_desc = "done packing shapes."
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        # Shape Names:
        shapes = utils.assembling_kit_shapes

        n_objects = 5
        if self.mode == 'train':
            obj_shapes = np.random.choice(self.train_set, n_objects, replace=False)
        else:
            if self.homogeneous:
                obj_shapes = [np.random.choice(self.test_set, replace=False)] * n_objects
            else:
                obj_shapes = np.random.choice(self.test_set, n_objects, replace=False)

        # Shuffle colors to avoid always picking an object of the same color
        colors, color_names = utils.get_colors(mode=self.mode)

        # Add container box.
        zone_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, zone_pose, 'fixed')

        # Add objects.
        objects = []
        template = 'kitting/object-template.urdf'
        for i in range(n_objects):
            shape = obj_shapes[i]

            # x, y, z dimensions for the asset size
            size = (0.08, 0.08, 0.02)
            pose= self.get_random_pose(env, size)
            fname = f'{shape:02d}.obj'
            fname = os.path.join(self.assets_root, 'kitting', fname)
            scale = [0.003, 0.003, 0.001]  # .0005
            replace = {'FNAME': (fname,),
                       'SCALE': scale,
                       'COLOR': colors[i]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            block_id = env.add_object(urdf, pose)
            objects.append(block_id)

        # Pick the first shape.
        num_objects_to_pick = 1
        for i in range(num_objects_to_pick):
            # IMPORTANT: Specify (obj_pts, [(zone_pose, zone_size)]) for target `zone`. obj_pts is a dict
            language_goal = self.lang_template.format(obj=shapes[obj_shapes[i]])
            self.add_goal(objs=[objects[i]], matches=np.int32([[1]]), targ_poses=[zone_pose], replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1 / num_objects_to_pick,
                language_goal=language_goal)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PlaceRedInGreen(Task):
    """pick up the red blocks and place them into the green bowls amidst other objects."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = "put the red blocks in a green bowl"
        self.task_completed_desc = "done placing blocks in bowls."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_blocks = np.random.randint(1, n_bowls + 1)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, obj_size=bowl_size)
            env.add_object(urdf=bowl_urdf, pose=bowl_pose, category='fixed')
            bowl_poses.append(bowl_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        for _ in range(n_blocks):
            block_pose = self.get_random_pose(env, obj_size=block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Goal: each red block is in a different green bowl.
        self.add_goal(objs=blocks, matches=np.ones((len(blocks), len(bowl_poses))), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

        # Colors of distractor objects.
        bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'green']
        block_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'red']

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = block_colors if is_block else bowl_colors
            pose = self.get_random_pose(env, obj_size=size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1
"""
"""
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils


class SweepingPiles(Task):
    """Push piles of small objects into a target goal zone marked on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = "push the pile of blocks into the green square"
        self.task_completed_desc = "done sweeping."
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add goal zone.
        zone_size = (0.12, 0.12, 0)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add pile of small blocks with `make_piles` function
        obj_ids = self.make_piles(env)

        # Add goal
        self.add_goal(objs=obj_ids, matches=np.ones((50, 1)), targ_poses=[zone_pose], replace=True,
                rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class StackBlockPyramid(Task):
    """Build a pyramid of colored blocks in a color sequence"""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = "make the {row} row with {blocks}"
        self.task_completed_desc = "done stacking block pyramid."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['red']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, blue, purple).
        language_goal = self.lang_template.format(blocks="the green, blue and purple blocks", row="bottom")
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (middle row: yellow, orange).
        language_goal = self.lang_template.format(blocks="the yellow and orange blocks", row="middle")      
        self.add_goal(objs=objs[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (top row: red).
        language_goal = self.lang_template.format(blocks="the red block", row="top")
        self.add_goal(objs=objs[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2]*1, language_goal=language_goal)
"""



Do not use libraries, functions, and assets that you don't know. For each object, try to describe its color, size, category in the task first before you write the code. You do not need extra helper functions. Comment the code liberally to explain what each piece does and why it's written that way. If you have only one goal, `step_max_reward` in `add_goal` should be 1. Use functions `make_piles` and `make_ropes` for creating piles and cables. To use spatula together with the push primitives, import the libraries 
"""
from cliport.tasks import primitives;
from cliport.tasks.grippers import Spatula
"""
and then use `self.primitive = primitives.push` and `self.ee = Spatula`.
Note that the number of language goals usually match the number of motion goals, since they should correspond to each other.

Before generate code, you have a few considerations to focus on:
1. You are strictly prohibited from using function interfaces that do not appear in the above sample code. For example, the module cliport.tasks.primitives does not have pick_plack or place functions, only the push function interface is available.
2. Module 'cliport.tasks.primitives' has no attribute 'pick_place', you mustn't use it.
3. There are two types of your Gripper, one is Spatula and the other is Suction.You need to choose a different end-effector depending on your task requirements. If you need to move an object on the Z axis, then you need to use the Suction type. If you just need to translate an object in a 2D plane, then you can use either Spatula or Suction type.
4. You must determine the type of end-effector you need to use based on the type of task you have. You can choose by adding self.ee=Spatula or self.ee=Suction to the __init__(self) function, the default self.ee is Suction.
5. If you want to use Suction, you must import module using "from cliport.tasks.grippers import Suction". Else if you want to use Spatula, you must import module using "from cliport.tasks.grippers import Spatula".
6. The x-coordinate of the object is in the range [0.25, 0.75], the y-coordinate is in the range [-0.5,0.5] and the z-coordinate is in the range [0, 0.3].
7. The initial position of all objects needs to get its random initial position through the get_random_pose function.
8. The self.max_steps parameter value should be greater than the number of calls to self.add_goal, and preferably equal to twice the number of calls to self.add_goal. For example, if you call self.add_goal twice in one task, then self.max_steps is better set to 4.

If you want to generate the color of the object, you have to obey following rules:
1. You must use the utils.COLORS['COLOR_NAME'] function interface to generate an RGB three-channel value for a color.
2. The available colors for 'COLOR_NAME' are blue, red, green, orange, yellow, purple, pink, cyan, brown, white, gray, indigo, violet, black, silver and gold.
3. If you want to generate a red object, then its RGB three-channel color can be obtained through utils.COLORS['red'].
All object’s colors generation must follow color generation method above.

If you want to generate the target pose of the object(third parameter of function 'self.add_goal' targ_poses), you have to obey following rules:
1. The target pose of an object is represented by the three-dimensional spatial coordinates of the object and its orientation quaternion.
2. The target pose of an object must be represented by [(x,y,z),(q1,q2,q3,q4)]. Where (x,y,z) are the three-dimensional coordinates of the object and (q1,q2,q3,q4) denote the quaternions of the object's target pose.
3. The target pose of an object must be generated by you or use the initial pose of an object as the target pose of the current object.
4. Here's an example, to generate the target pose of a Y object, we have the initial pose information of an X object. So target pose of Y can be represented by pose_y=[(x,y,z),(q1,q2,q3,q4)] or pose_y=initial_pose_x.(Where x,y,z,q1,q2,q3,q4 are specific values.)
5. targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation).
6. The targ_poses you generate must contain translation[x,y,z], but rotation[q0,q1,q2,q3] you may or may not generate.
All object's target pose generation must follow method above.

Now write the code for the task "cylinder-sort-and-stack" in python code block starting with ```python.  Reminder: {'task-name': 'cylinder-sort-and-stack', 'task-description': 'Pick up cylinders of varying heights and colors from a pallet and stack them into color-coordinated towers on designated zones.', 'assets-used': ['cylinder/cylinder-template.urdf', 'zone/zone.urdf', 'pallet/pallet.urdf']} 


>>> Answer: 
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderSortAndStack(Task):
    """Pick up cylinders of varying heights and colors from a pallet and stack them into color-coordinated towers on designated zones."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we will call self.add_goal 5 times
        self.lang_template = "stack the {color} cylinder on the {color} zone"
        self.task_completed_desc = "done sorting and stacking cylinders."
        self.ee = Suction  # Suction end-effector is needed to pick and stack cylinders vertically

    def reset(self, env):
        super().reset(env)

        # Define the number of cylinders and zones
        n_cylinders = 5
        n_zones = 3

        # Define cylinder size (height, radius)
        cylinder_heights = np.linspace(0.05, 0.15, n_cylinders)
        cylinder_radius = 0.02

        # Define zone size (length, width)
        zone_size = (0.1, 0.1, 0)

        # Add pallet to the environment
        pallet_size = (0.3, 0.3, 0.02)
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object('pallet/pallet.urdf', pallet_pose, 'fixed')

        # Add zones to the environment
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for _ in range(n_zones):
            zone_pose = self.get_random_pose(env, zone_size)
            env.add_object(zone_urdf, zone_pose, 'fixed')
            zone_poses.append(zone_pose)

        # Add cylinders to the environment
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_colors = ['red', 'green', 'blue', 'yellow', 'purple']
        cylinders = []
        for i in range(n_cylinders):
            # Generate a random pose for the cylinder on the pallet
            pose = self.get_random_pose(env, (cylinder_radius*2, cylinder_radius*2, cylinder_heights[i]))
            pose = (pose[0], pallet_pose[1])  # Set the cylinder on top of the pallet

            # Generate the color for the cylinder
            color = utils.COLORS[cylinder_colors[i]]

            # Fill in the cylinder URDF template
            replace = {'COLOR': color, 'SIZE': (cylinder_radius, cylinder_heights[i])}
            urdf = self.fill_template(cylinder_template, replace)

            # Add the cylinder to the environment
            cylinder_id = env.add_object(urdf, pose)
            cylinders.append((cylinder_id, color))

        # Sort cylinders by color and add stacking goals
        for color, zone_pose in zip(cylinder_colors, zone_poses):
            # Find all cylinders of the same color
            color_cylinders = [cid for cid, ccolor in cylinders if ccolor == utils.COLORS[color]]

            # Generate language goal
            language_goal = self.lang_template.format(color=color)

            # Add a goal for each cylinder to be stacked on the zone of the same color
            for i, cylinder_id in enumerate(color_cylinders):
                # Calculate the target pose for stacking
                target_pose = (zone_pose[0], (0, 0, zone_size[2] + cylinder_heights[i] * (i + 1)))
                self.add_goal(objs=[cylinder_id], matches=np.ones((1, 1)), targ_poses=[target_pose], replace=False,
                              rotations=False, metric='pose', params=None, step_max_reward=1/n_cylinders,
                              language_goal=language_goal)

        # Set the primitive to be used for this task
        self.primitive = primitives.push
```

This code defines a task where cylinders of varying heights and colors are picked up from a pallet and stacked onto zones of matching colors. The task uses a suction end-effector to pick up and stack the cylinders vertically. The `reset` method adds a pallet, zones, and cylinders to the environment, and sets up the goals for stacking the cylinders by color. The `add_goal` method is called for each cylinder to define the stacking action required. The `primitive` is set to `push`, which is a placeholder in this context since the actual primitive used for picking and placing would be different, but the `push` primitive is the only one available in the provided API.

================= TRIAL: 2

================= Task and Asset Design!

>>> Prompt: 
You are an AI in robot simulation code and task design. I will provide you some example tasks, code implementation, and some guidelines for how to generate tasks and then you will help me generate a new task. My goal is to design diverse and feasible tasks for tabletop manipulation. I will first ask you to describe the task in natural languages and then will let you write the code for it. 

=========
Here are all the assets. Use only these assets in the task and code design. 
"""
insertion/:
ell.urdf  fixture.urdf

bowl/:
bowl.urdf

box/:
box-template.urdf

stacking/:
block.urdf  stand.urdf

zone/:
zone.obj  zone.urdf

pallet/:
pallet.obj  pallet.urdf

ball/:
ball-template.urdf

cylinder/:
cylinder-template.urdf

bowl/:
bowl.urdf

# assets not for picking
corner/:
corner-template.urdf

line/:
single-green-line-template.urdf

container/:
container-template.urdf
"""
 
=========
Here are some examples of good tasks. Try to learn from these structures but avoid overlapping wiht them.

{"assets-used": ["zone/zone.urdf", "block/small.urdf"],
 "task-description": "Push piles of small objects into a target goal zone marked on the tabletop.",
 "task-name": "sweeping-piles"}

{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "Place all blocks of a specified color in a bowl of specified color.",
 "task-name": "put-block-in-bowl"}
 
{"assets-used": ["insertion/ell.urdf", "insertion/fixture.urdf"],
 "task-description": "pick up the L-shaped red block and place it into the L-shaped fixture.",
 "task-name": "block-insertion"}
 
{"assets-used": ["kitting/kit.urdf", "kitting/object-template.urdf"],
 "task-description": "pick up different objects and arrange them on a board marked with corresponding silhouettes.",
 "task-name": "assembling-kits"}
 
{"assets-used": ["pallet/pallet.urdf", "box/box-template.urdf"],
 "task-description": "pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.",
 "task-name": "palletizing-boxes"}
 
{"assets-used": ["stacking/stand.urdf", "stacking/block.urdf"],
 "task-description": "sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.",
 "task-name": "stack-block-pyramid"}
 
{"assets-used": ["container/container-template.urdf", "box/box-template.urdf"],
 "task-description": "pick up randomly sized boxes and place them tightly into a container.",
 "task-name": "packing-boxes"}
 
{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "pick up the red blocks and place them into the green bowls amidst other objects.",
 "task-name": "place-red-in-green"}
 
{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

=========
Here are some tasks that you have come up with before. Try to learn from these structures but avoid overlapping with these tasks. For instance, `bowl_ball_placement` and `sort_balls_in_bowls` are the same task. `pile_boxes_in_corner` and `stack_blocks_into_pallet` are similar tasks, `align-cylinder-in-corner` and `align-cylinder-corner` are similar.
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- cylinder_hurdle_arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}





=========
Here are some bad example task instances with explanations.
{
    "task_name": "sort-color-blocks",
    "task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "box/box-template.urdf],
}
reasons: not interesting because it overlaps with the current task `put-block-in-bowl`.

{
    "task-name": "guided-ball-maze",
    "task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
    "assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
}
reasons: the language descriptions are too ambiguous. Navigation is also hard to complete. Also maze.urf does not exist.

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
}
reasons: this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere. Similarly tasks like `insert-ball-into-cylinder` and `cylinder-box-insertion` are invalid.

{
    "task-name": "ball-box-obstacle-course",
    "task-description": "Navigate a ball through an obstacle course created by randomly placed boxes and finally place it inside a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: Navigate the ball is not related to tabletop manipulation tasks.

{
    "task-name": "ball-in-box",
    "task-description": "Use a cable to guide a ball into an open box.",
    "assets-used": ["cable/cable.urdf", "ball/ball-template.urdf", "box/box-template.urdf"]
}
reasons: This task is too hard since it involves interaction of the cable and the ball and cannot be easily completed.

{
    "task-name": "ball-in-container",
    "task-description": "Use the spatula to lift a ball over a wall of boxes and drop it into a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: The only action primitives as pick and place. One cannot use a spatula to lift an object.

{
    "task-name": "line-ball-sorting",
    "task-description": "Move balls of different colors along a single green line, placing each ball in a designated colored box at the end of the line. The challenge includes precision in maintaining the ball on the line and the correct identification of the box color corresponding to each ball.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf"]
}
reasons: Piling or stacking balls are physically infeasible in the simulation.



=========
Now please describe the new task in natural languages and explain its novelty and challenges. Format the answer in a python dictionary with keys "task-name" and value type string, "task-description" (one specific sentence) and value type string, and "assets-used" and value type list of strings. Note that

- Do not use assets that are not in the list above. 
- Tasks that have more colors and shapes are interesting.
- Be as specific as possible about the number, shape, and color of each asset in the task descriptions. 
- The task need to obey physics and remain feasible.





>>> Answer: 
Here is a novel task described in natural language, along with its novelty and challenges, formatted as a Python dictionary:

```python
{
    "task-name": "color-coded-pallet-organization",
    "task-description": "Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.",
    "assets-used": ["pallet/pallet.urdf", "cylinder/cylinder-template.urdf", "zone/zone.urdf"]
}
```

The novelty of this task lies in the combination of color recognition and precise spatial placement. The robot must identify the color of each cylinder and then place it in the correct zone on the pallet, which adds a layer of complexity as the zones will be of different colors as well. This task emphasizes dexterity in manipulation to ensure that the cylinders are placed within the designated zones, as well as the ability to recognize and sort objects based on color.

Challenges include:

- Accurate color perception and differentiation to sort the cylinders.
- Fine motor control to place the cylinders precisely within the small zones.
- Spatial reasoning to optimize the arrangement of the cylinders on the pallet to fit within the designated areas.
- Robustness in handling the cylinders without knocking others out of their zones.

================= API Preview!

>>> Prompt: 
Before writing the code for the task "color-coded-pallet-organization". Here are some APIs that are defined. Please confirm that you understand these APIs.

"""
class Task():
    """Base Task class."""

    def __init__(self):
        self.ee = Suction
        self.mode = 'train'
        self.sixdof = False
        self.primitive = primitives.PickPlace()
        self.oracle_cams = cameras.Oracle.CONFIG

        # Evaluation epsilons (for pose evaluation metric).
        self.pos_eps = 0.01
        self.rot_eps = np.deg2rad(15)

        # Workspace bounds.
        self.pix_size = 0.003125
        self.bounds = np.array([[0.25, 0.75], [-0.5, 0.5], [0, 0.3]])
        self.zone_bounds = np.copy(self.bounds)

        self.goals = []
        self.lang_goals = []
        self.task_completed_desc = "task completed."
        self.progress = 0
        self._rewards = 0
        self.assets_root = None

    def reset(self, env):
        if not self.assets_root:
            raise ValueError('assets_root must be set for task, '
                             'call set_assets_root().')
        self.goals = []
        self.lang_goals = []
        self.progress = 0  # Task progression metric in range [0, 1].
        self._rewards = 0  # Cumulative returned rewards.

    # -------------------------------------------------------------------------
    # Oracle Agent
    # -------------------------------------------------------------------------

    def oracle(self, env):
        """Oracle agent."""
        OracleAgent = collections.namedtuple('OracleAgent', ['act'])

        def act(obs, info):
            """Calculate action."""

            # Oracle uses perfect RGB-D orthographic images and segmentation masks.
            _, hmap, obj_mask = self.get_true_image(env)

            # Unpack next goal step.
            objs, matches, targs, replace, rotations, _, _, _ = self.goals[0]

            # Match objects to targets without replacement.
            if not replace:

                # Modify a copy of the match matrix.
                matches = matches.copy()

                # Ignore already matched objects.
                for i in range(len(objs)):
                    object_id, (symmetry, _) = objs[i]
                    pose = p.getBasePositionAndOrientation(object_id)
                    targets_i = np.argwhere(matches[i, :]).reshape(-1)
                    for j in targets_i:
                        if self.is_match(pose, targs[j], symmetry):
                            matches[i, :] = 0
                            matches[:, j] = 0

            # Get objects to be picked (prioritize farthest from nearest neighbor).
            nn_dists = []
            nn_targets = []
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                xyz, _ = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                if len(targets_i) > 0:
                    targets_xyz = np.float32([targs[j][0] for j in targets_i])
                    dists = np.linalg.norm(
                        targets_xyz - np.float32(xyz).reshape(1, 3), axis=1)
                    nn = np.argmin(dists)
                    nn_dists.append(dists[nn])
                    nn_targets.append(targets_i[nn])

                # Handle ignored objects.
                else:
                    nn_dists.append(0)
                    nn_targets.append(-1)
            order = np.argsort(nn_dists)[::-1]

            # Filter out matched objects.
            order = [i for i in order if nn_dists[i] > 0]

            pick_mask = None
            for pick_i in order:
                pick_mask = np.uint8(obj_mask == objs[pick_i][0])

                # Erode to avoid picking on edges.
                # pick_mask = cv2.erode(pick_mask, np.ones((3, 3), np.uint8))

                if np.sum(pick_mask) > 0:
                    break

            # Trigger task reset if no object is visible.
            if pick_mask is None or np.sum(pick_mask) == 0:
                self.goals = []
                self.lang_goals = []
                print('Object for pick is not visible. Skipping demonstration.')
                return

            # Get picking pose.
            pick_prob = np.float32(pick_mask)
            pick_pix = utils.sample_distribution(pick_prob)
            # For "deterministic" demonstrations on insertion-easy, use this:
            # pick_pix = (160,80)
            pick_pos = utils.pix_to_xyz(pick_pix, hmap,
                                        self.bounds, self.pix_size)
            pick_pose = (np.asarray(pick_pos), np.asarray((0, 0, 0, 1)))

            # Get placing pose.
            targ_pose = targs[nn_targets[pick_i]]
            obj_pose = p.getBasePositionAndOrientation(objs[pick_i][0])
            if not self.sixdof:
                obj_euler = utils.quatXYZW_to_eulerXYZ(obj_pose[1])
                obj_quat = utils.eulerXYZ_to_quatXYZW((0, 0, obj_euler[2]))
                obj_pose = (obj_pose[0], obj_quat)
            world_to_pick = utils.invert(pick_pose)
            obj_to_pick = utils.multiply(world_to_pick, obj_pose)
            pick_to_obj = utils.invert(obj_to_pick)
            place_pose = utils.multiply(targ_pose, pick_to_obj)

            # Rotate end effector?
            if not rotations:
                place_pose = (place_pose[0], (0, 0, 0, 1))

            place_pose = (np.asarray(place_pose[0]), np.asarray(place_pose[1]))

            return {'pose0': pick_pose, 'pose1': place_pose}

        return OracleAgent(act)

    # -------------------------------------------------------------------------
    # Reward Function and Task Completion Metrics
    # -------------------------------------------------------------------------

    def reward(self):
        """Get delta rewards for current timestep.

        Returns:
          A tuple consisting of the scalar (delta) reward, plus `extras`
            dict which has extra task-dependent info from the process of
            computing rewards that gives us finer-grained details. Use
            `extras` for further data analysis.
        """
        reward, info = 0, {}

        # Unpack next goal step.
        objs, matches, targs, _, _, metric, params, max_reward = self.goals[0]

        # Evaluate by matching object poses.
        if metric == 'pose':
            step_reward = 0
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                pose = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                for j in targets_i:
                    target_pose = targs[j]
                    if self.is_match(pose, target_pose, symmetry):
                        step_reward += max_reward / len(objs)
                        print(f"object {i} match with target {j} rew: {step_reward}")
                        break

        # Evaluate by measuring object intersection with zone.
        elif metric == 'zone':
            zone_pts, total_pts = 0, 0
            obj_pts, zones = params
            for zone_idx, (zone_pose, zone_size) in enumerate(zones):

                # Count valid points in zone.
                for obj_idx, obj_id in enumerate(obj_pts):
                    pts = obj_pts[obj_id]
                    obj_pose = p.getBasePositionAndOrientation(obj_id)
                    world_to_zone = utils.invert(zone_pose)
                    obj_to_zone = utils.multiply(world_to_zone, obj_pose)
                    pts = np.float32(utils.apply(obj_to_zone, pts))
                    if len(zone_size) > 1:
                        valid_pts = np.logical_and.reduce([
                            pts[0, :] > -zone_size[0] / 2, pts[0, :] < zone_size[0] / 2,
                            pts[1, :] > -zone_size[1] / 2, pts[1, :] < zone_size[1] / 2,
                            pts[2, :] < self.zone_bounds[2, 1]])

                    # if zone_idx == matches[obj_idx].argmax():
                    zone_pts += np.sum(np.float32(valid_pts))
                    total_pts += pts.shape[1]
            step_reward = max_reward * (zone_pts / total_pts)

        # Get cumulative rewards and return delta.
        reward = self.progress + step_reward - self._rewards
        self._rewards = self.progress + step_reward

        # Move to next goal step if current goal step is complete.
        if np.abs(max_reward - step_reward) < 0.01:
            self.progress += max_reward  # Update task progress.
            self.goals.pop(0)
            if len(self.lang_goals) > 0:
                self.lang_goals.pop(0)

        return reward, info

    def done(self):
        """Check if the task is done or has failed.

        Returns:
          True if the episode should be considered a success, which we
            use for measuring successes, which is particularly helpful for tasks
            where one may get successes on the very last time step, e.g., getting
            the cloth coverage threshold on the last alllowed action.
            However, for bag-items-easy and bag-items-hard (which use the
            'bag-items' metric), it may be necessary to filter out demos that did
            not attain sufficiently high reward in external code. Currently, this
            is done in `main.py` and its ignore_this_demo() method.
        """
        return (len(self.goals) == 0) or (self._rewards > 0.99)
        # return zone_done or defs_done or goal_done

    # -------------------------------------------------------------------------
    # Environment Helper Functions
    # -------------------------------------------------------------------------

    def is_match(self, pose0, pose1, symmetry):
        """Check if pose0 and pose1 match within a threshold."""

        # Get translational error.
        diff_pos = np.float32(pose0[0][:2]) - np.float32(pose1[0][:2])
        dist_pos = np.linalg.norm(diff_pos)

        # Get rotational error around z-axis (account for symmetries).
        diff_rot = 0
        if symmetry > 0:
            rot0 = np.array(utils.quatXYZW_to_eulerXYZ(pose0[1]))[2]
            rot1 = np.array(utils.quatXYZW_to_eulerXYZ(pose1[1]))[2]
            diff_rot = np.abs(rot0 - rot1) % symmetry
            if diff_rot > (symmetry / 2):
                diff_rot = symmetry - diff_rot

        return (dist_pos < self.pos_eps) and (diff_rot < self.rot_eps)

    def get_random_pose(self, env, obj_size):
        """Get random collision-free object pose within workspace bounds."""

        # Get erosion size of object in pixels.
        max_size = np.sqrt(obj_size[0] ** 2 + obj_size[1] ** 2)
        erode_size = int(np.round(max_size / self.pix_size))

        _, hmap, obj_mask = self.get_true_image(env)

        # Randomly sample an object pose within free-space pixels.
        free = np.ones(obj_mask.shape, dtype=np.uint8)
        for obj_ids in env.obj_ids.values():
            for obj_id in obj_ids:
                free[obj_mask == obj_id] = 0
        free[0, :], free[:, 0], free[-1, :], free[:, -1] = 0, 0, 0, 0
        free = cv2.erode(free, np.ones((erode_size, erode_size), np.uint8))

        # if np.sum(free) == 0:
        #     return None, None

        if np.sum(free) == 0:
            # avoid returning None, None
            # return None, None
            pix = (obj_mask.shape[0] // 2, obj_mask.shape[1] // 2)
        else:
            pix = utils.sample_distribution(np.float32(free))
        pos = utils.pix_to_xyz(pix, hmap, self.bounds, self.pix_size)
        pos = (pos[0], pos[1], obj_size[2] / 2)
        theta = np.random.rand() * 2 * np.pi
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta))
        return pos, rot

    def get_lang_goal(self):
        if len(self.lang_goals) == 0:
            return self.task_completed_desc
        else:
            return self.lang_goals[0]

    def get_reward(self):
        return float(self._rewards)

    # -------------------------------------------------------------------------
    # Helper Functions
    # -------------------------------------------------------------------------

    def fill_template(self, template, replace):
        """Read a file and replace key strings."""
        full_template_path = os.path.join(self.assets_root, template)
        with open(full_template_path, 'r') as file:
            fdata = file.read()
        for field in replace:
            for i in range(len(replace[field])):
                fdata = fdata.replace(f'{field}{i}', str(replace[field][i]))
        alphabet = string.ascii_lowercase + string.digits
        rname = ''.join(random.choices(alphabet, k=16))
        tmpdir = tempfile.gettempdir()
        template_filename = os.path.split(template)[-1]
        fname = os.path.join(tmpdir, f'{template_filename}.{rname}')
        with open(fname, 'w') as file:
            file.write(fdata)
        return fname

    def get_random_size(self, min_x, max_x, min_y, max_y, min_z, max_z):
        """Get random box size."""
        size = np.random.rand(3)
        size[0] = size[0] * (max_x - min_x) + min_x
        size[1] = size[1] * (max_y - min_y) + min_y
        size[2] = size[2] * (max_z - min_z) + min_z
        return tuple(size)

    def color_random_brown(self, obj):
        shade = np.random.rand() + 0.5
        color = np.float32([shade * 156, shade * 117, shade * 95, 255]) / 255
        p.changeVisualShape(obj, -1, rgbaColor=color)

  """""
  
  # Environment Class
  def add_object(self, urdf, pose, category='rigid'):
    """List of (fixed, rigid, or deformable) objects in env."""
    fixed_base = 1 if category == 'fixed' else 0
    obj_id = pybullet_utils.load_urdf(
        p,
        os.path.join(self.assets_root, urdf),
        pose[0],
        pose[1],
        useFixedBase=fixed_base)
    self.obj_ids[category].append(obj_id)
    return obj_id
"""

=========
Note that the objects need to obey physics and not collide with each other, and the object goal poses need to be above the table with lower bound x=0.25, y=-0.5 and upper bound x=0.75, y=0.5. When there are multiple objects for a multi-step pick-and-place task, there are often multiple subgoals. Once the task and environment are generated, an agent with a pick and place primitive will follow the defined goal to accomplish the tasks. 

Additionally, make sure you understand and summarize the ``self.goals`` variables, which has a list of 8-tuple with (objs, matches, targ_poses, replace, rotations, metric, params, step_max_reward, symmetries).
- objs (List of obj_id): object ID.
- matches (Binary Matrix): a binary matrix that denotes which object is matched with which target. This matrix has dimension len(objs) x len(targs).
- targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation). 
- replace (Boolean): whether each object can match with one unique target. This is important if we have one target and multiple objects. If it's set to be false, then any object matching with the target will satisfy.
- rotations (Boolean): whether the placement action has a rotation degree of freedom. 
- metric (`pose` or `zone`): `pose` or `zone` that the object needs to be transported to. Example: `pose`. 
- params (List of (zone_target, zone_size)): a list of (zone_target, zone_size) for each zone if the metric is `zone`. 
- step_max_reward (float): the total reward of matching all the objects with all the target poses. It is not dependent on the number of objects but dependent on the number of goals. 
- symmetries: the radians that the object is symmetric around z axis.
- language_goal: the low-level language instructions that denote the goal of this step.
 


>>> Answer: 
I understand the provided APIs and their functionalities. Here's a summary of the key components:

### Task Class
The `Task` class serves as a base class for defining a robotic task. It initializes various parameters such as the end effector type (`ee`), the mode of operation, the six degrees of freedom (`sixdof`), the pick and place primitive (`primitive`), and the oracle cameras configuration (`oracle_cams`). It also sets up evaluation metrics (`pos_eps` and `rot_eps`), workspace bounds (`bounds` and `zone_bounds`), and other task-related variables.

### Task Methods
- `reset(env)`: Resets the task environment and initializes goals and progress.
- `oracle(env)`: Defines an oracle agent that can provide an optimal action sequence for the task.
- `reward()`: Calculates the reward for the current timestep based on the task's goals and metrics.
- `done()`: Checks if the task is completed or has failed.
- `is_match(pose0, pose1, symmetry)`: Determines if two poses match within a specified threshold, considering symmetry.
- `get_random_pose(env, obj_size)`: Generates a random collision-free pose for an object within the workspace bounds.
- `get_lang_goal()`: Retrieves the current language goal.
- `get_reward()`: Returns the current cumulative reward.
- `fill_template(template, replace)`: Fills a template file with specified values.
- `get_random_size(min_x, max_x, min_y, max_y, min_z, max_z)`: Generates a random size for an object.
- `color_random_brown(obj)`: Assigns a random brown color to an object.

### Environment Class
- `add_object(urdf, pose, category)`: Adds an object to the environment with a specified pose and category.

### self.goals Variable
The `self.goals` variable is a list of 8-tuples that define the subgoals for a task. Each tuple contains the following elements:
- `objs`: A list of object IDs.
- `matches`: A binary matrix indicating which objects are matched with which targets.
- `targ_poses`: A list of target poses, each consisting of a translation and rotation.
- `replace`: A boolean indicating whether objects can match with one unique target.
- `rotations`: A boolean indicating whether the placement action includes rotation.
- `metric`: A string that specifies the evaluation metric ('pose' or 'zone').
- `params`: A list of parameters for each zone if the metric is 'zone'.
- `step_max_reward`: The total reward for matching all objects with all target poses.
- `symmetries`: The radians of symmetry around the z-axis for the objects.
- `language_goal`: The low-level language instructions that denote the goal of this step.

Understanding these APIs is crucial for writing the simulation code for the "color-coded-pallet-organization" task, as they provide the necessary functions and properties to interact with the simulation environment, define task goals, and evaluate task performance.

================= Code Generation!

>>> Prompt: 
Now I will provide you some reference code and you can write the code for the task "color-coded-pallet-organization".


"""
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class PackingShapes(Task):
    """pick up randomly sized shapes and place them tightly into a container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 1
        self.homogeneous = False

        self.lang_template = "pack the {obj} in the brown box"
        self.task_completed_desc = "done packing shapes."
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        # Shape Names:
        shapes = utils.assembling_kit_shapes

        n_objects = 5
        if self.mode == 'train':
            obj_shapes = np.random.choice(self.train_set, n_objects, replace=False)
        else:
            if self.homogeneous:
                obj_shapes = [np.random.choice(self.test_set, replace=False)] * n_objects
            else:
                obj_shapes = np.random.choice(self.test_set, n_objects, replace=False)

        # Shuffle colors to avoid always picking an object of the same color
        colors, color_names = utils.get_colors(mode=self.mode)

        # Add container box.
        zone_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, zone_pose, 'fixed')

        # Add objects.
        objects = []
        template = 'kitting/object-template.urdf'
        for i in range(n_objects):
            shape = obj_shapes[i]

            # x, y, z dimensions for the asset size
            size = (0.08, 0.08, 0.02)
            pose= self.get_random_pose(env, size)
            fname = f'{shape:02d}.obj'
            fname = os.path.join(self.assets_root, 'kitting', fname)
            scale = [0.003, 0.003, 0.001]  # .0005
            replace = {'FNAME': (fname,),
                       'SCALE': scale,
                       'COLOR': colors[i]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            block_id = env.add_object(urdf, pose)
            objects.append(block_id)

        # Pick the first shape.
        num_objects_to_pick = 1
        for i in range(num_objects_to_pick):
            # IMPORTANT: Specify (obj_pts, [(zone_pose, zone_size)]) for target `zone`. obj_pts is a dict
            language_goal = self.lang_template.format(obj=shapes[obj_shapes[i]])
            self.add_goal(objs=[objects[i]], matches=np.int32([[1]]), targ_poses=[zone_pose], replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1 / num_objects_to_pick,
                language_goal=language_goal)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PlaceRedInGreen(Task):
    """pick up the red blocks and place them into the green bowls amidst other objects."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = "put the red blocks in a green bowl"
        self.task_completed_desc = "done placing blocks in bowls."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_blocks = np.random.randint(1, n_bowls + 1)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, obj_size=bowl_size)
            env.add_object(urdf=bowl_urdf, pose=bowl_pose, category='fixed')
            bowl_poses.append(bowl_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        for _ in range(n_blocks):
            block_pose = self.get_random_pose(env, obj_size=block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Goal: each red block is in a different green bowl.
        self.add_goal(objs=blocks, matches=np.ones((len(blocks), len(bowl_poses))), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

        # Colors of distractor objects.
        bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'green']
        block_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'red']

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = block_colors if is_block else bowl_colors
            pose = self.get_random_pose(env, obj_size=size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1
"""
"""
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils


class SweepingPiles(Task):
    """Push piles of small objects into a target goal zone marked on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = "push the pile of blocks into the green square"
        self.task_completed_desc = "done sweeping."
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add goal zone.
        zone_size = (0.12, 0.12, 0)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add pile of small blocks with `make_piles` function
        obj_ids = self.make_piles(env)

        # Add goal
        self.add_goal(objs=obj_ids, matches=np.ones((50, 1)), targ_poses=[zone_pose], replace=True,
                rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class StackBlockPyramid(Task):
    """Build a pyramid of colored blocks in a color sequence"""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = "make the {row} row with {blocks}"
        self.task_completed_desc = "done stacking block pyramid."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['red']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, blue, purple).
        language_goal = self.lang_template.format(blocks="the green, blue and purple blocks", row="bottom")
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (middle row: yellow, orange).
        language_goal = self.lang_template.format(blocks="the yellow and orange blocks", row="middle")      
        self.add_goal(objs=objs[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (top row: red).
        language_goal = self.lang_template.format(blocks="the red block", row="top")
        self.add_goal(objs=objs[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2]*1, language_goal=language_goal)
"""



Do not use libraries, functions, and assets that you don't know. For each object, try to describe its color, size, category in the task first before you write the code. You do not need extra helper functions. Comment the code liberally to explain what each piece does and why it's written that way. If you have only one goal, `step_max_reward` in `add_goal` should be 1. Use functions `make_piles` and `make_ropes` for creating piles and cables. To use spatula together with the push primitives, import the libraries 
"""
from cliport.tasks import primitives;
from cliport.tasks.grippers import Spatula
"""
and then use `self.primitive = primitives.push` and `self.ee = Spatula`.
Note that the number of language goals usually match the number of motion goals, since they should correspond to each other.

Before generate code, you have a few considerations to focus on:
1. You are strictly prohibited from using function interfaces that do not appear in the above sample code. For example, the module cliport.tasks.primitives does not have pick_plack or place functions, only the push function interface is available.
2. Module 'cliport.tasks.primitives' has no attribute 'pick_place', you mustn't use it.
3. There are two types of your Gripper, one is Spatula and the other is Suction.You need to choose a different end-effector depending on your task requirements. If you need to move an object on the Z axis, then you need to use the Suction type. If you just need to translate an object in a 2D plane, then you can use either Spatula or Suction type.
4. You must determine the type of end-effector you need to use based on the type of task you have. You can choose by adding self.ee=Spatula or self.ee=Suction to the __init__(self) function, the default self.ee is Suction.
5. If you want to use Suction, you must import module using "from cliport.tasks.grippers import Suction". Else if you want to use Spatula, you must import module using "from cliport.tasks.grippers import Spatula".
6. The x-coordinate of the object is in the range [0.25, 0.75], the y-coordinate is in the range [-0.5,0.5] and the z-coordinate is in the range [0, 0.3].
7. The initial position of all objects needs to get its random initial position through the get_random_pose function.
8. The self.max_steps parameter value should be greater than the number of calls to self.add_goal, and preferably equal to twice the number of calls to self.add_goal. For example, if you call self.add_goal twice in one task, then self.max_steps is better set to 4.

If you want to generate the color of the object, you have to obey following rules:
1. You must use the utils.COLORS['COLOR_NAME'] function interface to generate an RGB three-channel value for a color.
2. The available colors for 'COLOR_NAME' are blue, red, green, orange, yellow, purple, pink, cyan, brown, white, gray, indigo, violet, black, silver and gold.
3. If you want to generate a red object, then its RGB three-channel color can be obtained through utils.COLORS['red'].
All object’s colors generation must follow color generation method above.

If you want to generate the target pose of the object(third parameter of function 'self.add_goal' targ_poses), you have to obey following rules:
1. The target pose of an object is represented by the three-dimensional spatial coordinates of the object and its orientation quaternion.
2. The target pose of an object must be represented by [(x,y,z),(q1,q2,q3,q4)]. Where (x,y,z) are the three-dimensional coordinates of the object and (q1,q2,q3,q4) denote the quaternions of the object's target pose.
3. The target pose of an object must be generated by you or use the initial pose of an object as the target pose of the current object.
4. Here's an example, to generate the target pose of a Y object, we have the initial pose information of an X object. So target pose of Y can be represented by pose_y=[(x,y,z),(q1,q2,q3,q4)] or pose_y=initial_pose_x.(Where x,y,z,q1,q2,q3,q4 are specific values.)
5. targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation).
6. The targ_poses you generate must contain translation[x,y,z], but rotation[q0,q1,q2,q3] you may or may not generate.
All object's target pose generation must follow method above.

Now write the code for the task "color-coded-pallet-organization" in python code block starting with ```python.  Reminder: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']} 


>>> Answer: 
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ColorCodedPalletOrganization(Task):
    """Arrange colored cylinders on a pallet by matching cylinder colors to designated zones."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Set max steps to twice the number of goals
        self.lang_template = "place the {color} cylinder in the {color} zone"
        self.task_completed_desc = "done organizing the pallet."
        self.ee = Suction  # Use Suction end-effector for vertical movement

    def reset(self, env):
        super().reset(env)

        # Define the number of cylinders and zones
        n_cylinders = 5
        n_zones = 5

        # Add pallet
        pallet_size = (0.3, 0.3, 0.02)  # Define the size of the pallet
        pallet_pose = self.get_random_pose(env, pallet_size)  # Get a random pose for the pallet
        env.add_object('pallet/pallet.urdf', pallet_pose, 'fixed')  # Add the pallet to the environment

        # Define available colors
        colors = ['red', 'green', 'blue', 'yellow', 'purple']

        # Add zones to the pallet
        zone_size = (0.1, 0.1, 0)  # Define the size of the zones
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for i in range(n_zones):
            # Calculate zone position based on pallet position and zone size
            zone_x = pallet_pose[0][0] - pallet_size[0]/2 + zone_size[0]/2 + i * zone_size[0]
            zone_y = pallet_pose[0][1]
            zone_z = pallet_pose[0][2] + pallet_size[2]
            zone_pose = ((zone_x, zone_y, zone_z), pallet_pose[1])
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[colors[i]])
            zone_poses.append(zone_pose)

        # Add cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_size = (0.02, 0.02, 0.1)  # Define the size of the cylinders
        for i in range(n_cylinders):
            # Get a random pose for the cylinder
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            # Set the color of the cylinder
            color = colors[i]
            replace = {'COLOR': utils.COLORS[color]}
            # Fill the cylinder URDF template with the color
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            # Define the language goal
            language_goal = self.lang_template.format(color=color)
            # Add the goal for the cylinder to be placed in the matching color zone
            self.add_goal(objs=[cylinder_id], matches=np.int32([[1]]), targ_poses=[zone_poses[i]], replace=True,
                          rotations=False, metric='zone', params=[(zone_poses[i], zone_size)], step_max_reward=1/n_cylinders,
                          language_goal=language_goal)

# Instantiate the task
task = ColorCodedPalletOrganization()
```

This code defines a task where colored cylinders must be placed on a pallet in their corresponding colored zones. The `Suction` end-effector is used to pick up and place the cylinders vertically. The task is set up by adding a pallet, zones on the pallet, and cylinders to the environment. Each cylinder is assigned a goal to be placed in a zone with a matching color, and the reward is distributed evenly across the number of cylinders. The language goal provides a description of the task for each cylinder.

================= TRIAL: 3

================= Code Reflect!

>>> Prompt: 


Do you think your task is sufficently interesting to be added as a new task for future task given that we already have the following task name and descriptions? Moreover, does the simulation code achieve the goal and the language descriptions in the task? Be as rigorous and high-standard as possible.

Reminder:
your task:
{'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}

import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ColorCodedPalletOrganization(Task):
    """Arrange colored cylinders on a pallet by matching cylinder colors to designated zones."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Set max steps to twice the number of goals
        self.lang_template = "place the {color} cylinder in the {color} zone"
        self.task_completed_desc = "done organizing the pallet."
        self.ee = Suction  # Use Suction end-effector for vertical movement

    def reset(self, env):
        super().reset(env)

        # Define the number of cylinders and zones
        n_cylinders = 5
        n_zones = 5

        # Add pallet
        pallet_size = (0.3, 0.3, 0.02)  # Define the size of the pallet
        pallet_pose = self.get_random_pose(env, pallet_size)  # Get a random pose for the pallet
        env.add_object('pallet/pallet.urdf', pallet_pose, 'fixed')  # Add the pallet to the environment

        # Define available colors
        colors = ['red', 'green', 'blue', 'yellow', 'purple']

        # Add zones to the pallet
        zone_size = (0.1, 0.1, 0)  # Define the size of the zones
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for i in range(n_zones):
            # Calculate zone position based on pallet position and zone size
            zone_x = pallet_pose[0][0] - pallet_size[0]/2 + zone_size[0]/2 + i * zone_size[0]
            zone_y = pallet_pose[0][1]
            zone_z = pallet_pose[0][2] + pallet_size[2]
            zone_pose = ((zone_x, zone_y, zone_z), pallet_pose[1])
            env.add_object(zone_urdf, zone_pose, 'fixed', color=utils.COLORS[colors[i]])
            zone_poses.append(zone_pose)

        # Add cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_size = (0.02, 0.02, 0.1)  # Define the size of the cylinders
        for i in range(n_cylinders):
            # Get a random pose for the cylinder
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            # Set the color of the cylinder
            color = colors[i]
            replace = {'COLOR': utils.COLORS[color]}
            # Fill the cylinder URDF template with the color
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            # Define the language goal
            language_goal = self.lang_template.format(color=color)
            # Add the goal for the cylinder to be placed in the matching color zone
            self.add_goal(objs=[cylinder_id], matches=np.int32([[1]]), targ_poses=[zone_poses[i]], replace=True,
                          rotations=False, metric='zone', params=[(zone_poses[i], zone_size)], step_max_reward=1/n_cylinders,
                          language_goal=language_goal)

# Instantiate the task
task = ColorCodedPalletOrganization()

current task list:
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- stack-block-pyramid: {'assets-used': ['stacking/stand.urdf', 'stacking/block.urdf'], 'task-description': 'sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.', 'task-name': 'stack-block-pyramid'}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- cylinder_hurdle_arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}




=========
Reply explain your reasons and then say True or False, formatted in a python dictionary, do not miss commas or add extra spaces. Here are some examples.

{
	"task_name": "sort-color-blocks",
	"task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "yellow-bowl.urdf", "box/box-template.urdf],
	"reasons": "not interesting because it overlaps with the current task `put-block-in-bowl`"
	"add_to_the_task_list": "False",
}

{
  	"task-name": "guided-ball-maze",
  	"task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
  	"assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
   	"reasons": "the language descriptions are too ambiguous. Navigation is also hard to complete."
  	"add_to_the_task_list": "False",  
}

{
 	"task-name": "sort-blocks-by-zone",
 	"task-description": "Sort different colored blocks into their corresponding colored zones marked on the tabletop.",
 	"assets-used": ["zone/zone.urdf", "stacking/block.urdf"],
	"reasons": "the task is not covered in the current list and is an interesting combination of zone and block objects." 
	"add_to_the_task_list": "True",
}

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
    "reasons": "this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "arrange-blocks-on-pallet",
    "task-description": "arrange the blocks on the pallet in the order: red, orange, yellow, green, blue, and purple.",
    "assets-used": ["stacking/block.urdf", "pallet/pallelt.urdf"],
    "reasons": "this task overlaps with `arrange-boxes-on-pallet` by merely changing the blocks to boxes.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "cylinder-color-alignment",
    "task-description": "Pick up cylinders of different colors and align them inside a box in the order of the colors displayed on the single green line on the tabletop.",
    "assets-used": ["cylinder/cylinder-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf   
    "reasons": "the execution code only has one goal, i.e. it will only move one cylinder on top of the box, which is not that interesting.", 
    "add_to_the_task_list": "False","]
}

{
    "task-name": "build-bridge",
    "task-description": "Construct a bridge using two yellow blocks and three blue blocks. Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between. Then, place the blue block horizontally on top of the yellow blocks.",
     "assets-used": ["block/block.urdf", "ball/ball-template.urdf"]
    "reasons": "this task is an interesting and long-horizon task for pick and place primitives. Training manipulation agent with this skill will be a useful building block for next skills.", 
    "add_to_the_task_list": "True",
}

=========

Please incorporate these feedbacks when you design new task!



>>> Answer: 
{
    "task-name": "color-coded-pallet-organization",
    "task-description": "Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.",
    "assets-used": ["pallet/pallet.urdf", "cylinder/cylinder-template.urdf", "zone/zone.urdf"],
    "reasons": "The task is sufficiently distinct from the existing tasks in the list, as it combines color matching with precise placement on a pallet, which is not covered by any single task currently. However, the task may be too similar to 'cylinder-hurdle-arrangement' in the sense that both involve arranging cylinders, but the 'color-coded-pallet-organization' task emphasizes color matching and placement within designated zones rather than arranging by size and navigating obstacles. The simulation code appears to achieve the goal and matches the language descriptions provided in the task.",
    "add_to_the_task_list": "True",
}

================= Task and Asset Design!

>>> Prompt: 
You are an AI in robot simulation code and task design. I will provide you some example tasks, code implementation, and some guidelines for how to generate tasks and then you will help me generate a new task. My goal is to design diverse and feasible tasks for tabletop manipulation. I will first ask you to describe the task in natural languages and then will let you write the code for it. 

=========
Here are all the assets. Use only these assets in the task and code design. 
"""
insertion/:
ell.urdf  fixture.urdf

bowl/:
bowl.urdf

box/:
box-template.urdf

stacking/:
block.urdf  stand.urdf

zone/:
zone.obj  zone.urdf

pallet/:
pallet.obj  pallet.urdf

ball/:
ball-template.urdf

cylinder/:
cylinder-template.urdf

bowl/:
bowl.urdf

# assets not for picking
corner/:
corner-template.urdf

line/:
single-green-line-template.urdf

container/:
container-template.urdf
"""
 
=========
Here are some examples of good tasks. Try to learn from these structures but avoid overlapping wiht them.

{"assets-used": ["zone/zone.urdf", "block/small.urdf"],
 "task-description": "Push piles of small objects into a target goal zone marked on the tabletop.",
 "task-name": "sweeping-piles"}

{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "Place all blocks of a specified color in a bowl of specified color.",
 "task-name": "put-block-in-bowl"}
 
{"assets-used": ["insertion/ell.urdf", "insertion/fixture.urdf"],
 "task-description": "pick up the L-shaped red block and place it into the L-shaped fixture.",
 "task-name": "block-insertion"}
 
{"assets-used": ["kitting/kit.urdf", "kitting/object-template.urdf"],
 "task-description": "pick up different objects and arrange them on a board marked with corresponding silhouettes.",
 "task-name": "assembling-kits"}
 
{"assets-used": ["pallet/pallet.urdf", "box/box-template.urdf"],
 "task-description": "pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.",
 "task-name": "palletizing-boxes"}
 
{"assets-used": ["stacking/stand.urdf", "stacking/block.urdf"],
 "task-description": "sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.",
 "task-name": "stack-block-pyramid"}
 
{"assets-used": ["container/container-template.urdf", "box/box-template.urdf"],
 "task-description": "pick up randomly sized boxes and place them tightly into a container.",
 "task-name": "packing-boxes"}
 
{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "pick up the red blocks and place them into the green bowls amidst other objects.",
 "task-name": "place-red-in-green"}
 
{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

=========
Here are some tasks that you have come up with before. Try to learn from these structures but avoid overlapping with these tasks. For instance, `bowl_ball_placement` and `sort_balls_in_bowls` are the same task. `pile_boxes_in_corner` and `stack_blocks_into_pallet` are similar tasks, `align-cylinder-in-corner` and `align-cylinder-corner` are similar.
- color-coded-pallet-organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}
- color_coded_pallet_organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- stack-block-pyramid: {'assets-used': ['stacking/stand.urdf', 'stacking/block.urdf'], 'task-description': 'sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.', 'task-name': 'stack-block-pyramid'}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}





=========
Here are some bad example task instances with explanations.
{
    "task_name": "sort-color-blocks",
    "task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "box/box-template.urdf],
}
reasons: not interesting because it overlaps with the current task `put-block-in-bowl`.

{
    "task-name": "guided-ball-maze",
    "task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
    "assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
}
reasons: the language descriptions are too ambiguous. Navigation is also hard to complete. Also maze.urf does not exist.

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
}
reasons: this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere. Similarly tasks like `insert-ball-into-cylinder` and `cylinder-box-insertion` are invalid.

{
    "task-name": "ball-box-obstacle-course",
    "task-description": "Navigate a ball through an obstacle course created by randomly placed boxes and finally place it inside a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: Navigate the ball is not related to tabletop manipulation tasks.

{
    "task-name": "ball-in-box",
    "task-description": "Use a cable to guide a ball into an open box.",
    "assets-used": ["cable/cable.urdf", "ball/ball-template.urdf", "box/box-template.urdf"]
}
reasons: This task is too hard since it involves interaction of the cable and the ball and cannot be easily completed.

{
    "task-name": "ball-in-container",
    "task-description": "Use the spatula to lift a ball over a wall of boxes and drop it into a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: The only action primitives as pick and place. One cannot use a spatula to lift an object.

{
    "task-name": "line-ball-sorting",
    "task-description": "Move balls of different colors along a single green line, placing each ball in a designated colored box at the end of the line. The challenge includes precision in maintaining the ball on the line and the correct identification of the box color corresponding to each ball.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf"]
}
reasons: Piling or stacking balls are physically infeasible in the simulation.



=========
Now please describe the new task in natural languages and explain its novelty and challenges. Format the answer in a python dictionary with keys "task-name" and value type string, "task-description" (one specific sentence) and value type string, and "assets-used" and value type list of strings. Note that

- Do not use assets that are not in the list above. 
- Tasks that have more colors and shapes are interesting.
- Be as specific as possible about the number, shape, and color of each asset in the task descriptions. 
- The task need to obey physics and remain feasible.





>>> Answer: 
Below is a new task described in natural language within the constraints and guidelines provided:

```python
{
    "task-name": "cylinder-tower-balancing",
    "task-description": "Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.",
    "assets-used": [
        "cylinder/cylinder-template.urdf",
        "stacking/stand.urdf"
    ]
}
```

Novelty:
This task introduces a challenge of stacking objects of varying sizes in a manner that requires precision and balance. Unlike tasks that involve stacking uniform blocks or organizing objects on a flat surface, this task requires the robot to manage the center of gravity of each cylinder to maintain the stability of the tower.

Challenges:
1. Size Grading: The robot needs to identify and sort the cylinders by size, choosing the correct order for stacking.
2. Precision Placement: Each cylinder must be precisely placed to ensure the stack remains balanced.
3. Stability Management: Throughout the task, the robot must handle the cylinders carefully to avoid disturbing the already placed items, especially as the smaller cylinders may have a smaller contact area for balance.

This task also involves complex reasoning about object geometry and the physical properties that influence stability, providing a rich scenario for testing both perception and manipulation skills.

================= API Preview!

>>> Prompt: 
Before writing the code for the task "cylinder-tower-balancing". Here are some APIs that are defined. Please confirm that you understand these APIs.

"""
class Task():
    """Base Task class."""

    def __init__(self):
        self.ee = Suction
        self.mode = 'train'
        self.sixdof = False
        self.primitive = primitives.PickPlace()
        self.oracle_cams = cameras.Oracle.CONFIG

        # Evaluation epsilons (for pose evaluation metric).
        self.pos_eps = 0.01
        self.rot_eps = np.deg2rad(15)

        # Workspace bounds.
        self.pix_size = 0.003125
        self.bounds = np.array([[0.25, 0.75], [-0.5, 0.5], [0, 0.3]])
        self.zone_bounds = np.copy(self.bounds)

        self.goals = []
        self.lang_goals = []
        self.task_completed_desc = "task completed."
        self.progress = 0
        self._rewards = 0
        self.assets_root = None

    def reset(self, env):
        if not self.assets_root:
            raise ValueError('assets_root must be set for task, '
                             'call set_assets_root().')
        self.goals = []
        self.lang_goals = []
        self.progress = 0  # Task progression metric in range [0, 1].
        self._rewards = 0  # Cumulative returned rewards.

    # -------------------------------------------------------------------------
    # Oracle Agent
    # -------------------------------------------------------------------------

    def oracle(self, env):
        """Oracle agent."""
        OracleAgent = collections.namedtuple('OracleAgent', ['act'])

        def act(obs, info):
            """Calculate action."""

            # Oracle uses perfect RGB-D orthographic images and segmentation masks.
            _, hmap, obj_mask = self.get_true_image(env)

            # Unpack next goal step.
            objs, matches, targs, replace, rotations, _, _, _ = self.goals[0]

            # Match objects to targets without replacement.
            if not replace:

                # Modify a copy of the match matrix.
                matches = matches.copy()

                # Ignore already matched objects.
                for i in range(len(objs)):
                    object_id, (symmetry, _) = objs[i]
                    pose = p.getBasePositionAndOrientation(object_id)
                    targets_i = np.argwhere(matches[i, :]).reshape(-1)
                    for j in targets_i:
                        if self.is_match(pose, targs[j], symmetry):
                            matches[i, :] = 0
                            matches[:, j] = 0

            # Get objects to be picked (prioritize farthest from nearest neighbor).
            nn_dists = []
            nn_targets = []
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                xyz, _ = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                if len(targets_i) > 0:
                    targets_xyz = np.float32([targs[j][0] for j in targets_i])
                    dists = np.linalg.norm(
                        targets_xyz - np.float32(xyz).reshape(1, 3), axis=1)
                    nn = np.argmin(dists)
                    nn_dists.append(dists[nn])
                    nn_targets.append(targets_i[nn])

                # Handle ignored objects.
                else:
                    nn_dists.append(0)
                    nn_targets.append(-1)
            order = np.argsort(nn_dists)[::-1]

            # Filter out matched objects.
            order = [i for i in order if nn_dists[i] > 0]

            pick_mask = None
            for pick_i in order:
                pick_mask = np.uint8(obj_mask == objs[pick_i][0])

                # Erode to avoid picking on edges.
                # pick_mask = cv2.erode(pick_mask, np.ones((3, 3), np.uint8))

                if np.sum(pick_mask) > 0:
                    break

            # Trigger task reset if no object is visible.
            if pick_mask is None or np.sum(pick_mask) == 0:
                self.goals = []
                self.lang_goals = []
                print('Object for pick is not visible. Skipping demonstration.')
                return

            # Get picking pose.
            pick_prob = np.float32(pick_mask)
            pick_pix = utils.sample_distribution(pick_prob)
            # For "deterministic" demonstrations on insertion-easy, use this:
            # pick_pix = (160,80)
            pick_pos = utils.pix_to_xyz(pick_pix, hmap,
                                        self.bounds, self.pix_size)
            pick_pose = (np.asarray(pick_pos), np.asarray((0, 0, 0, 1)))

            # Get placing pose.
            targ_pose = targs[nn_targets[pick_i]]
            obj_pose = p.getBasePositionAndOrientation(objs[pick_i][0])
            if not self.sixdof:
                obj_euler = utils.quatXYZW_to_eulerXYZ(obj_pose[1])
                obj_quat = utils.eulerXYZ_to_quatXYZW((0, 0, obj_euler[2]))
                obj_pose = (obj_pose[0], obj_quat)
            world_to_pick = utils.invert(pick_pose)
            obj_to_pick = utils.multiply(world_to_pick, obj_pose)
            pick_to_obj = utils.invert(obj_to_pick)
            place_pose = utils.multiply(targ_pose, pick_to_obj)

            # Rotate end effector?
            if not rotations:
                place_pose = (place_pose[0], (0, 0, 0, 1))

            place_pose = (np.asarray(place_pose[0]), np.asarray(place_pose[1]))

            return {'pose0': pick_pose, 'pose1': place_pose}

        return OracleAgent(act)

    # -------------------------------------------------------------------------
    # Reward Function and Task Completion Metrics
    # -------------------------------------------------------------------------

    def reward(self):
        """Get delta rewards for current timestep.

        Returns:
          A tuple consisting of the scalar (delta) reward, plus `extras`
            dict which has extra task-dependent info from the process of
            computing rewards that gives us finer-grained details. Use
            `extras` for further data analysis.
        """
        reward, info = 0, {}

        # Unpack next goal step.
        objs, matches, targs, _, _, metric, params, max_reward = self.goals[0]

        # Evaluate by matching object poses.
        if metric == 'pose':
            step_reward = 0
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                pose = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                for j in targets_i:
                    target_pose = targs[j]
                    if self.is_match(pose, target_pose, symmetry):
                        step_reward += max_reward / len(objs)
                        print(f"object {i} match with target {j} rew: {step_reward}")
                        break

        # Evaluate by measuring object intersection with zone.
        elif metric == 'zone':
            zone_pts, total_pts = 0, 0
            obj_pts, zones = params
            for zone_idx, (zone_pose, zone_size) in enumerate(zones):

                # Count valid points in zone.
                for obj_idx, obj_id in enumerate(obj_pts):
                    pts = obj_pts[obj_id]
                    obj_pose = p.getBasePositionAndOrientation(obj_id)
                    world_to_zone = utils.invert(zone_pose)
                    obj_to_zone = utils.multiply(world_to_zone, obj_pose)
                    pts = np.float32(utils.apply(obj_to_zone, pts))
                    if len(zone_size) > 1:
                        valid_pts = np.logical_and.reduce([
                            pts[0, :] > -zone_size[0] / 2, pts[0, :] < zone_size[0] / 2,
                            pts[1, :] > -zone_size[1] / 2, pts[1, :] < zone_size[1] / 2,
                            pts[2, :] < self.zone_bounds[2, 1]])

                    # if zone_idx == matches[obj_idx].argmax():
                    zone_pts += np.sum(np.float32(valid_pts))
                    total_pts += pts.shape[1]
            step_reward = max_reward * (zone_pts / total_pts)

        # Get cumulative rewards and return delta.
        reward = self.progress + step_reward - self._rewards
        self._rewards = self.progress + step_reward

        # Move to next goal step if current goal step is complete.
        if np.abs(max_reward - step_reward) < 0.01:
            self.progress += max_reward  # Update task progress.
            self.goals.pop(0)
            if len(self.lang_goals) > 0:
                self.lang_goals.pop(0)

        return reward, info

    def done(self):
        """Check if the task is done or has failed.

        Returns:
          True if the episode should be considered a success, which we
            use for measuring successes, which is particularly helpful for tasks
            where one may get successes on the very last time step, e.g., getting
            the cloth coverage threshold on the last alllowed action.
            However, for bag-items-easy and bag-items-hard (which use the
            'bag-items' metric), it may be necessary to filter out demos that did
            not attain sufficiently high reward in external code. Currently, this
            is done in `main.py` and its ignore_this_demo() method.
        """
        return (len(self.goals) == 0) or (self._rewards > 0.99)
        # return zone_done or defs_done or goal_done

    # -------------------------------------------------------------------------
    # Environment Helper Functions
    # -------------------------------------------------------------------------

    def is_match(self, pose0, pose1, symmetry):
        """Check if pose0 and pose1 match within a threshold."""

        # Get translational error.
        diff_pos = np.float32(pose0[0][:2]) - np.float32(pose1[0][:2])
        dist_pos = np.linalg.norm(diff_pos)

        # Get rotational error around z-axis (account for symmetries).
        diff_rot = 0
        if symmetry > 0:
            rot0 = np.array(utils.quatXYZW_to_eulerXYZ(pose0[1]))[2]
            rot1 = np.array(utils.quatXYZW_to_eulerXYZ(pose1[1]))[2]
            diff_rot = np.abs(rot0 - rot1) % symmetry
            if diff_rot > (symmetry / 2):
                diff_rot = symmetry - diff_rot

        return (dist_pos < self.pos_eps) and (diff_rot < self.rot_eps)

    def get_random_pose(self, env, obj_size):
        """Get random collision-free object pose within workspace bounds."""

        # Get erosion size of object in pixels.
        max_size = np.sqrt(obj_size[0] ** 2 + obj_size[1] ** 2)
        erode_size = int(np.round(max_size / self.pix_size))

        _, hmap, obj_mask = self.get_true_image(env)

        # Randomly sample an object pose within free-space pixels.
        free = np.ones(obj_mask.shape, dtype=np.uint8)
        for obj_ids in env.obj_ids.values():
            for obj_id in obj_ids:
                free[obj_mask == obj_id] = 0
        free[0, :], free[:, 0], free[-1, :], free[:, -1] = 0, 0, 0, 0
        free = cv2.erode(free, np.ones((erode_size, erode_size), np.uint8))

        # if np.sum(free) == 0:
        #     return None, None

        if np.sum(free) == 0:
            # avoid returning None, None
            # return None, None
            pix = (obj_mask.shape[0] // 2, obj_mask.shape[1] // 2)
        else:
            pix = utils.sample_distribution(np.float32(free))
        pos = utils.pix_to_xyz(pix, hmap, self.bounds, self.pix_size)
        pos = (pos[0], pos[1], obj_size[2] / 2)
        theta = np.random.rand() * 2 * np.pi
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta))
        return pos, rot

    def get_lang_goal(self):
        if len(self.lang_goals) == 0:
            return self.task_completed_desc
        else:
            return self.lang_goals[0]

    def get_reward(self):
        return float(self._rewards)

    # -------------------------------------------------------------------------
    # Helper Functions
    # -------------------------------------------------------------------------

    def fill_template(self, template, replace):
        """Read a file and replace key strings."""
        full_template_path = os.path.join(self.assets_root, template)
        with open(full_template_path, 'r') as file:
            fdata = file.read()
        for field in replace:
            for i in range(len(replace[field])):
                fdata = fdata.replace(f'{field}{i}', str(replace[field][i]))
        alphabet = string.ascii_lowercase + string.digits
        rname = ''.join(random.choices(alphabet, k=16))
        tmpdir = tempfile.gettempdir()
        template_filename = os.path.split(template)[-1]
        fname = os.path.join(tmpdir, f'{template_filename}.{rname}')
        with open(fname, 'w') as file:
            file.write(fdata)
        return fname

    def get_random_size(self, min_x, max_x, min_y, max_y, min_z, max_z):
        """Get random box size."""
        size = np.random.rand(3)
        size[0] = size[0] * (max_x - min_x) + min_x
        size[1] = size[1] * (max_y - min_y) + min_y
        size[2] = size[2] * (max_z - min_z) + min_z
        return tuple(size)

    def color_random_brown(self, obj):
        shade = np.random.rand() + 0.5
        color = np.float32([shade * 156, shade * 117, shade * 95, 255]) / 255
        p.changeVisualShape(obj, -1, rgbaColor=color)

  """""
  
  # Environment Class
  def add_object(self, urdf, pose, category='rigid'):
    """List of (fixed, rigid, or deformable) objects in env."""
    fixed_base = 1 if category == 'fixed' else 0
    obj_id = pybullet_utils.load_urdf(
        p,
        os.path.join(self.assets_root, urdf),
        pose[0],
        pose[1],
        useFixedBase=fixed_base)
    self.obj_ids[category].append(obj_id)
    return obj_id
"""

=========
Note that the objects need to obey physics and not collide with each other, and the object goal poses need to be above the table with lower bound x=0.25, y=-0.5 and upper bound x=0.75, y=0.5. When there are multiple objects for a multi-step pick-and-place task, there are often multiple subgoals. Once the task and environment are generated, an agent with a pick and place primitive will follow the defined goal to accomplish the tasks. 

Additionally, make sure you understand and summarize the ``self.goals`` variables, which has a list of 8-tuple with (objs, matches, targ_poses, replace, rotations, metric, params, step_max_reward, symmetries).
- objs (List of obj_id): object ID.
- matches (Binary Matrix): a binary matrix that denotes which object is matched with which target. This matrix has dimension len(objs) x len(targs).
- targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation). 
- replace (Boolean): whether each object can match with one unique target. This is important if we have one target and multiple objects. If it's set to be false, then any object matching with the target will satisfy.
- rotations (Boolean): whether the placement action has a rotation degree of freedom. 
- metric (`pose` or `zone`): `pose` or `zone` that the object needs to be transported to. Example: `pose`. 
- params (List of (zone_target, zone_size)): a list of (zone_target, zone_size) for each zone if the metric is `zone`. 
- step_max_reward (float): the total reward of matching all the objects with all the target poses. It is not dependent on the number of objects but dependent on the number of goals. 
- symmetries: the radians that the object is symmetric around z axis.
- language_goal: the low-level language instructions that denote the goal of this step.
 


>>> Answer: 
I understand the provided APIs and the task requirements. Here's a summary of my understanding:

The `Task` class is a base class for defining a robotic task in a simulated environment. It includes methods for resetting the task, providing an oracle (perfect agent) for demonstrations, calculating rewards, checking task completion, and various helper functions for interacting with the environment.

Key components of the `Task` class include:

- `reset(self, env)`: Resets the task to its initial state.
- `oracle(self, env)`: Provides an oracle agent that can perform the task perfectly using privileged information.
- `reward(self)`: Calculates the reward for the current timestep based on the task's progress.
- `done(self)`: Checks if the task is completed or has failed.
- `is_match(self, pose0, pose1, symmetry)`: Checks if two poses match within a specified threshold, considering object symmetry.
- `get_random_pose(self, env, obj_size)`: Generates a random collision-free pose for an object within the workspace bounds.
- `fill_template(self, template, replace)`: Fills a URDF template with specific values and returns the path to the temporary file.
- `get_random_size(self, min_x, max_x, min_y, max_y, min_z, max_z)`: Generates a random size for an object within specified bounds.
- `color_random_brown(self, obj)`: Assigns a random brown color to an object.

The `add_object` function in the environment class is used to add objects to the simulation. It takes the URDF file path, the pose of the object, and the category (fixed, rigid, or deformable) as arguments.

The `self.goals` variable is a list of 8-tuples that define the subgoals for a multi-step pick-and-place task. Each tuple contains:

- `objs`: A list of object IDs.
- `matches`: A binary matrix indicating which objects are matched with which targets.
- `targ_poses`: A list of target poses, each consisting of a translation and rotation.
- `replace`: A boolean indicating whether objects can match with multiple targets or only one unique target.
- `rotations`: A boolean indicating whether the placement action includes a rotation degree of freedom.
- `metric`: A string that specifies the evaluation metric ('pose' or 'zone').
- `params`: Additional parameters for the metric, such as zone targets and sizes if the metric is 'zone'.
- `step_max_reward`: The total reward for matching all objects with their target poses.
- `symmetries`: The radians of symmetry around the z-axis for each object.
- `language_goal`: Low-level language instructions that describe the goal of the current step.

Understanding these APIs and the task structure is crucial for writing the simulation code for the "cylinder-tower-balancing" task. The task will involve creating a simulation environment, defining the objects and their properties, and programming the robot's behavior to stack the cylinders in the correct order without collisions and within the bounds of the workspace.

================= Code Generation!

>>> Prompt: 
Now I will provide you some reference code and you can write the code for the task "cylinder-tower-balancing".


"""
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class PackingShapes(Task):
    """pick up randomly sized shapes and place them tightly into a container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 1
        self.homogeneous = False

        self.lang_template = "pack the {obj} in the brown box"
        self.task_completed_desc = "done packing shapes."
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        # Shape Names:
        shapes = utils.assembling_kit_shapes

        n_objects = 5
        if self.mode == 'train':
            obj_shapes = np.random.choice(self.train_set, n_objects, replace=False)
        else:
            if self.homogeneous:
                obj_shapes = [np.random.choice(self.test_set, replace=False)] * n_objects
            else:
                obj_shapes = np.random.choice(self.test_set, n_objects, replace=False)

        # Shuffle colors to avoid always picking an object of the same color
        colors, color_names = utils.get_colors(mode=self.mode)

        # Add container box.
        zone_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, zone_pose, 'fixed')

        # Add objects.
        objects = []
        template = 'kitting/object-template.urdf'
        for i in range(n_objects):
            shape = obj_shapes[i]

            # x, y, z dimensions for the asset size
            size = (0.08, 0.08, 0.02)
            pose= self.get_random_pose(env, size)
            fname = f'{shape:02d}.obj'
            fname = os.path.join(self.assets_root, 'kitting', fname)
            scale = [0.003, 0.003, 0.001]  # .0005
            replace = {'FNAME': (fname,),
                       'SCALE': scale,
                       'COLOR': colors[i]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            block_id = env.add_object(urdf, pose)
            objects.append(block_id)

        # Pick the first shape.
        num_objects_to_pick = 1
        for i in range(num_objects_to_pick):
            # IMPORTANT: Specify (obj_pts, [(zone_pose, zone_size)]) for target `zone`. obj_pts is a dict
            language_goal = self.lang_template.format(obj=shapes[obj_shapes[i]])
            self.add_goal(objs=[objects[i]], matches=np.int32([[1]]), targ_poses=[zone_pose], replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1 / num_objects_to_pick,
                language_goal=language_goal)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PlaceRedInGreen(Task):
    """pick up the red blocks and place them into the green bowls amidst other objects."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = "put the red blocks in a green bowl"
        self.task_completed_desc = "done placing blocks in bowls."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_blocks = np.random.randint(1, n_bowls + 1)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, obj_size=bowl_size)
            env.add_object(urdf=bowl_urdf, pose=bowl_pose, category='fixed')
            bowl_poses.append(bowl_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        for _ in range(n_blocks):
            block_pose = self.get_random_pose(env, obj_size=block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Goal: each red block is in a different green bowl.
        self.add_goal(objs=blocks, matches=np.ones((len(blocks), len(bowl_poses))), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

        # Colors of distractor objects.
        bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'green']
        block_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'red']

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = block_colors if is_block else bowl_colors
            pose = self.get_random_pose(env, obj_size=size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1
"""
"""
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils


class SweepingPiles(Task):
    """Push piles of small objects into a target goal zone marked on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = "push the pile of blocks into the green square"
        self.task_completed_desc = "done sweeping."
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add goal zone.
        zone_size = (0.12, 0.12, 0)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add pile of small blocks with `make_piles` function
        obj_ids = self.make_piles(env)

        # Add goal
        self.add_goal(objs=obj_ids, matches=np.ones((50, 1)), targ_poses=[zone_pose], replace=True,
                rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class StackBlockPyramid(Task):
    """Build a pyramid of colored blocks in a color sequence"""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = "make the {row} row with {blocks}"
        self.task_completed_desc = "done stacking block pyramid."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['red']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, blue, purple).
        language_goal = self.lang_template.format(blocks="the green, blue and purple blocks", row="bottom")
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (middle row: yellow, orange).
        language_goal = self.lang_template.format(blocks="the yellow and orange blocks", row="middle")      
        self.add_goal(objs=objs[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (top row: red).
        language_goal = self.lang_template.format(blocks="the red block", row="top")
        self.add_goal(objs=objs[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2]*1, language_goal=language_goal)
"""



Do not use libraries, functions, and assets that you don't know. For each object, try to describe its color, size, category in the task first before you write the code. You do not need extra helper functions. Comment the code liberally to explain what each piece does and why it's written that way. If you have only one goal, `step_max_reward` in `add_goal` should be 1. Use functions `make_piles` and `make_ropes` for creating piles and cables. To use spatula together with the push primitives, import the libraries 
"""
from cliport.tasks import primitives;
from cliport.tasks.grippers import Spatula
"""
and then use `self.primitive = primitives.push` and `self.ee = Spatula`.
Note that the number of language goals usually match the number of motion goals, since they should correspond to each other.

Before generate code, you have a few considerations to focus on:
1. You are strictly prohibited from using function interfaces that do not appear in the above sample code. For example, the module cliport.tasks.primitives does not have pick_plack or place functions, only the push function interface is available.
2. Module 'cliport.tasks.primitives' has no attribute 'pick_place', you mustn't use it.
3. There are two types of your Gripper, one is Spatula and the other is Suction.You need to choose a different end-effector depending on your task requirements. If you need to move an object on the Z axis, then you need to use the Suction type. If you just need to translate an object in a 2D plane, then you can use either Spatula or Suction type.
4. You must determine the type of end-effector you need to use based on the type of task you have. You can choose by adding self.ee=Spatula or self.ee=Suction to the __init__(self) function, the default self.ee is Suction.
5. If you want to use Suction, you must import module using "from cliport.tasks.grippers import Suction". Else if you want to use Spatula, you must import module using "from cliport.tasks.grippers import Spatula".
6. The x-coordinate of the object is in the range [0.25, 0.75], the y-coordinate is in the range [-0.5,0.5] and the z-coordinate is in the range [0, 0.3].
7. The initial position of all objects needs to get its random initial position through the get_random_pose function.
8. The self.max_steps parameter value should be greater than the number of calls to self.add_goal, and preferably equal to twice the number of calls to self.add_goal. For example, if you call self.add_goal twice in one task, then self.max_steps is better set to 4.

If you want to generate the color of the object, you have to obey following rules:
1. You must use the utils.COLORS['COLOR_NAME'] function interface to generate an RGB three-channel value for a color.
2. The available colors for 'COLOR_NAME' are blue, red, green, orange, yellow, purple, pink, cyan, brown, white, gray, indigo, violet, black, silver and gold.
3. If you want to generate a red object, then its RGB three-channel color can be obtained through utils.COLORS['red'].
All object’s colors generation must follow color generation method above.

If you want to generate the target pose of the object(third parameter of function 'self.add_goal' targ_poses), you have to obey following rules:
1. The target pose of an object is represented by the three-dimensional spatial coordinates of the object and its orientation quaternion.
2. The target pose of an object must be represented by [(x,y,z),(q1,q2,q3,q4)]. Where (x,y,z) are the three-dimensional coordinates of the object and (q1,q2,q3,q4) denote the quaternions of the object's target pose.
3. The target pose of an object must be generated by you or use the initial pose of an object as the target pose of the current object.
4. Here's an example, to generate the target pose of a Y object, we have the initial pose information of an X object. So target pose of Y can be represented by pose_y=[(x,y,z),(q1,q2,q3,q4)] or pose_y=initial_pose_x.(Where x,y,z,q1,q2,q3,q4 are specific values.)
5. targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation).
6. The targ_poses you generate must contain translation[x,y,z], but rotation[q0,q1,q2,q3] you may or may not generate.
All object's target pose generation must follow method above.

Now write the code for the task "cylinder-tower-balancing" in python code block starting with ```python.  Reminder: {'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']} 


>>> Answer: 
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderTowerBalancing(Task):
    """Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice that number
        self.lang_template = "stack the {size} cylinder on the {place}"
        self.task_completed_desc = "done constructing the cylinder tower."
        self.ee = Suction  # Using Suction since we need to move objects on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the sizes for the cylinders (large, medium, small)
        sizes = [(0.08, 0.08, 0.12), (0.06, 0.06, 0.09), (0.04, 0.04, 0.06)]
        size_names = ['large', 'medium', 'small']
        colors = ['blue', 'green', 'red']  # Assigning colors to each cylinder

        # Add stand.
        stand_size = (0.05, 0.05, 0.005)
        stand_urdf = 'stacking/stand.urdf'
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object(stand_urdf, stand_pose, category='fixed')

        # Add cylinders.
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []
        cylinder_ids = []
        for i in range(3):
            # Generate a random pose for the cylinder
            pose = self.get_random_pose(env, sizes[i])
            replace = {
                'DIM': sizes[i],
                'HALF': tuple([x / 2 for x in sizes[i]]),
                'COLOR': utils.COLORS[colors[i]]
            }
            # Fill the URDF template with size and color
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, pose)
            cylinder_poses.append(pose)
            cylinder_ids.append(cylinder_id)

        # Define the target poses for each cylinder, stacked on the stand
        targ_poses = [
            (stand_pose[0], stand_pose[1]),  # Bottom cylinder on the stand
            (utils.apply(stand_pose, (0, 0, sizes[0][2])), stand_pose[1]),  # Middle cylinder on top of the bottom cylinder
            (utils.apply(stand_pose, (0, 0, sizes[0][2] + sizes[1][2])), stand_pose[1])  # Top cylinder on top of the middle cylinder
        ]

        # Add goals for each cylinder
        for i in range(3):
            language_goal = self.lang_template.format(size=size_names[i], place="stand" if i == 0 else size_names[i-1] + " cylinder")
            self.add_goal(
                objs=[cylinder_ids[i]],  # Object to move
                matches=np.ones((1, 1)),  # Single object to single target
                targ_poses=[targ_poses[i]],  # Target pose
                replace=False,  # Object cannot match with multiple targets
                rotations=True,  # Allow rotation
                metric='pose',  # Use pose metric
                params=None,  # No additional parameters
                step_max_reward=1 / 3,  # Equal reward for each step, summing to 1
                language_goal=language_goal  # Language goal
            )
```

This code defines a task where a robot must stack three cylinders of different sizes on top of each other on a stand. The cylinders are added to the environment with random initial poses, and the task goals are defined to stack them from largest to smallest. The `Suction` end-effector is used because the task involves lifting objects along the Z-axis. The `max_steps` is set to 6 to allow for two steps per goal (picking and placing), and the `step_max_reward` is divided equally among the three goals. The language goals provide a description of each step in the task.

================= TRIAL: 4

================= Code Reflect!

>>> Prompt: 


Do you think your task is sufficently interesting to be added as a new task for future task given that we already have the following task name and descriptions? Moreover, does the simulation code achieve the goal and the language descriptions in the task? Be as rigorous and high-standard as possible.

Reminder:
your task:
{'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}

import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderTowerBalancing(Task):
    """Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice that number
        self.lang_template = "stack the {size} cylinder on the {place}"
        self.task_completed_desc = "done constructing the cylinder tower."
        self.ee = Suction  # Using Suction since we need to move objects on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the sizes for the cylinders (large, medium, small)
        sizes = [(0.08, 0.08, 0.12), (0.06, 0.06, 0.09), (0.04, 0.04, 0.06)]
        size_names = ['large', 'medium', 'small']
        colors = ['blue', 'green', 'red']  # Assigning colors to each cylinder

        # Add stand.
        stand_size = (0.05, 0.05, 0.005)
        stand_urdf = 'stacking/stand.urdf'
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object(stand_urdf, stand_pose, category='fixed')

        # Add cylinders.
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []
        cylinder_ids = []
        for i in range(3):
            # Generate a random pose for the cylinder
            pose = self.get_random_pose(env, sizes[i])
            replace = {
                'DIM': sizes[i],
                'HALF': tuple([x / 2 for x in sizes[i]]),
                'COLOR': utils.COLORS[colors[i]]
            }
            # Fill the URDF template with size and color
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, pose)
            cylinder_poses.append(pose)
            cylinder_ids.append(cylinder_id)

        # Define the target poses for each cylinder, stacked on the stand
        targ_poses = [
            (stand_pose[0], stand_pose[1]),  # Bottom cylinder on the stand
            (utils.apply(stand_pose, (0, 0, sizes[0][2])), stand_pose[1]),  # Middle cylinder on top of the bottom cylinder
            (utils.apply(stand_pose, (0, 0, sizes[0][2] + sizes[1][2])), stand_pose[1])  # Top cylinder on top of the middle cylinder
        ]

        # Add goals for each cylinder
        for i in range(3):
            language_goal = self.lang_template.format(size=size_names[i], place="stand" if i == 0 else size_names[i-1] + " cylinder")
            self.add_goal(
                objs=[cylinder_ids[i]],  # Object to move
                matches=np.ones((1, 1)),  # Single object to single target
                targ_poses=[targ_poses[i]],  # Target pose
                replace=False,  # Object cannot match with multiple targets
                rotations=True,  # Allow rotation
                metric='pose',  # Use pose metric
                params=None,  # No additional parameters
                step_max_reward=1 / 3,  # Equal reward for each step, summing to 1
                language_goal=language_goal  # Language goal
            )

current task list:
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- stack-block-pyramid: {'assets-used': ['stacking/stand.urdf', 'stacking/block.urdf'], 'task-description': 'sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.', 'task-name': 'stack-block-pyramid'}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- cylinder_hurdle_arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- color_coded_pallet_organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color-coded-pallet-organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}




=========
Reply explain your reasons and then say True or False, formatted in a python dictionary, do not miss commas or add extra spaces. Here are some examples.

{
	"task_name": "sort-color-blocks",
	"task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "yellow-bowl.urdf", "box/box-template.urdf],
	"reasons": "not interesting because it overlaps with the current task `put-block-in-bowl`"
	"add_to_the_task_list": "False",
}

{
  	"task-name": "guided-ball-maze",
  	"task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
  	"assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
   	"reasons": "the language descriptions are too ambiguous. Navigation is also hard to complete."
  	"add_to_the_task_list": "False",  
}

{
 	"task-name": "sort-blocks-by-zone",
 	"task-description": "Sort different colored blocks into their corresponding colored zones marked on the tabletop.",
 	"assets-used": ["zone/zone.urdf", "stacking/block.urdf"],
	"reasons": "the task is not covered in the current list and is an interesting combination of zone and block objects." 
	"add_to_the_task_list": "True",
}

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
    "reasons": "this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "arrange-blocks-on-pallet",
    "task-description": "arrange the blocks on the pallet in the order: red, orange, yellow, green, blue, and purple.",
    "assets-used": ["stacking/block.urdf", "pallet/pallelt.urdf"],
    "reasons": "this task overlaps with `arrange-boxes-on-pallet` by merely changing the blocks to boxes.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "cylinder-color-alignment",
    "task-description": "Pick up cylinders of different colors and align them inside a box in the order of the colors displayed on the single green line on the tabletop.",
    "assets-used": ["cylinder/cylinder-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf   
    "reasons": "the execution code only has one goal, i.e. it will only move one cylinder on top of the box, which is not that interesting.", 
    "add_to_the_task_list": "False","]
}

{
    "task-name": "build-bridge",
    "task-description": "Construct a bridge using two yellow blocks and three blue blocks. Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between. Then, place the blue block horizontally on top of the yellow blocks.",
     "assets-used": ["block/block.urdf", "ball/ball-template.urdf"]
    "reasons": "this task is an interesting and long-horizon task for pick and place primitives. Training manipulation agent with this skill will be a useful building block for next skills.", 
    "add_to_the_task_list": "True",
}

=========

Please incorporate these feedbacks when you design new task!



>>> Prompt: 


Do you think your task is sufficently interesting to be added as a new task for future task given that we already have the following task name and descriptions? Moreover, does the simulation code achieve the goal and the language descriptions in the task? Be as rigorous and high-standard as possible.

Reminder:
your task:
{'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}

import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderTowerBalancing(Task):
    """Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice that number
        self.lang_template = "stack the {size} cylinder on the {place}"
        self.task_completed_desc = "done constructing the cylinder tower."
        self.ee = Suction  # Using Suction since we need to move objects on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the sizes for the cylinders (large, medium, small)
        sizes = [(0.08, 0.08, 0.12), (0.06, 0.06, 0.09), (0.04, 0.04, 0.06)]
        size_names = ['large', 'medium', 'small']
        colors = ['blue', 'green', 'red']  # Assigning colors to each cylinder

        # Add stand.
        stand_size = (0.05, 0.05, 0.005)
        stand_urdf = 'stacking/stand.urdf'
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object(stand_urdf, stand_pose, category='fixed')

        # Add cylinders.
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []
        cylinder_ids = []
        for i in range(3):
            # Generate a random pose for the cylinder
            pose = self.get_random_pose(env, sizes[i])
            replace = {
                'DIM': sizes[i],
                'HALF': tuple([x / 2 for x in sizes[i]]),
                'COLOR': utils.COLORS[colors[i]]
            }
            # Fill the URDF template with size and color
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, pose)
            cylinder_poses.append(pose)
            cylinder_ids.append(cylinder_id)

        # Define the target poses for each cylinder, stacked on the stand
        targ_poses = [
            (stand_pose[0], stand_pose[1]),  # Bottom cylinder on the stand
            (utils.apply(stand_pose, (0, 0, sizes[0][2])), stand_pose[1]),  # Middle cylinder on top of the bottom cylinder
            (utils.apply(stand_pose, (0, 0, sizes[0][2] + sizes[1][2])), stand_pose[1])  # Top cylinder on top of the middle cylinder
        ]

        # Add goals for each cylinder
        for i in range(3):
            language_goal = self.lang_template.format(size=size_names[i], place="stand" if i == 0 else size_names[i-1] + " cylinder")
            self.add_goal(
                objs=[cylinder_ids[i]],  # Object to move
                matches=np.ones((1, 1)),  # Single object to single target
                targ_poses=[targ_poses[i]],  # Target pose
                replace=False,  # Object cannot match with multiple targets
                rotations=True,  # Allow rotation
                metric='pose',  # Use pose metric
                params=None,  # No additional parameters
                step_max_reward=1 / 3,  # Equal reward for each step, summing to 1
                language_goal=language_goal  # Language goal
            )

current task list:
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- stack-block-pyramid: {'assets-used': ['stacking/stand.urdf', 'stacking/block.urdf'], 'task-description': 'sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.', 'task-name': 'stack-block-pyramid'}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- cylinder_hurdle_arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- color_coded_pallet_organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color-coded-pallet-organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}




=========
Reply explain your reasons and then say True or False, formatted in a python dictionary, do not miss commas or add extra spaces. Here are some examples.

{
	"task_name": "sort-color-blocks",
	"task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "yellow-bowl.urdf", "box/box-template.urdf],
	"reasons": "not interesting because it overlaps with the current task `put-block-in-bowl`"
	"add_to_the_task_list": "False",
}

{
  	"task-name": "guided-ball-maze",
  	"task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
  	"assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
   	"reasons": "the language descriptions are too ambiguous. Navigation is also hard to complete."
  	"add_to_the_task_list": "False",  
}

{
 	"task-name": "sort-blocks-by-zone",
 	"task-description": "Sort different colored blocks into their corresponding colored zones marked on the tabletop.",
 	"assets-used": ["zone/zone.urdf", "stacking/block.urdf"],
	"reasons": "the task is not covered in the current list and is an interesting combination of zone and block objects." 
	"add_to_the_task_list": "True",
}

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
    "reasons": "this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "arrange-blocks-on-pallet",
    "task-description": "arrange the blocks on the pallet in the order: red, orange, yellow, green, blue, and purple.",
    "assets-used": ["stacking/block.urdf", "pallet/pallelt.urdf"],
    "reasons": "this task overlaps with `arrange-boxes-on-pallet` by merely changing the blocks to boxes.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "cylinder-color-alignment",
    "task-description": "Pick up cylinders of different colors and align them inside a box in the order of the colors displayed on the single green line on the tabletop.",
    "assets-used": ["cylinder/cylinder-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf   
    "reasons": "the execution code only has one goal, i.e. it will only move one cylinder on top of the box, which is not that interesting.", 
    "add_to_the_task_list": "False","]
}

{
    "task-name": "build-bridge",
    "task-description": "Construct a bridge using two yellow blocks and three blue blocks. Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between. Then, place the blue block horizontally on top of the yellow blocks.",
     "assets-used": ["block/block.urdf", "ball/ball-template.urdf"]
    "reasons": "this task is an interesting and long-horizon task for pick and place primitives. Training manipulation agent with this skill will be a useful building block for next skills.", 
    "add_to_the_task_list": "True",
}

=========

Please incorporate these feedbacks when you design new task!



>>> Prompt: 


Do you think your task is sufficently interesting to be added as a new task for future task given that we already have the following task name and descriptions? Moreover, does the simulation code achieve the goal and the language descriptions in the task? Be as rigorous and high-standard as possible.

Reminder:
your task:
{'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}

import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderTowerBalancing(Task):
    """Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice that number
        self.lang_template = "stack the {size} cylinder on the {place}"
        self.task_completed_desc = "done constructing the cylinder tower."
        self.ee = Suction  # Using Suction since we need to move objects on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the sizes for the cylinders (large, medium, small)
        sizes = [(0.08, 0.08, 0.12), (0.06, 0.06, 0.09), (0.04, 0.04, 0.06)]
        size_names = ['large', 'medium', 'small']
        colors = ['blue', 'green', 'red']  # Assigning colors to each cylinder

        # Add stand.
        stand_size = (0.05, 0.05, 0.005)
        stand_urdf = 'stacking/stand.urdf'
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object(stand_urdf, stand_pose, category='fixed')

        # Add cylinders.
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []
        cylinder_ids = []
        for i in range(3):
            # Generate a random pose for the cylinder
            pose = self.get_random_pose(env, sizes[i])
            replace = {
                'DIM': sizes[i],
                'HALF': tuple([x / 2 for x in sizes[i]]),
                'COLOR': utils.COLORS[colors[i]]
            }
            # Fill the URDF template with size and color
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, pose)
            cylinder_poses.append(pose)
            cylinder_ids.append(cylinder_id)

        # Define the target poses for each cylinder, stacked on the stand
        targ_poses = [
            (stand_pose[0], stand_pose[1]),  # Bottom cylinder on the stand
            (utils.apply(stand_pose, (0, 0, sizes[0][2])), stand_pose[1]),  # Middle cylinder on top of the bottom cylinder
            (utils.apply(stand_pose, (0, 0, sizes[0][2] + sizes[1][2])), stand_pose[1])  # Top cylinder on top of the middle cylinder
        ]

        # Add goals for each cylinder
        for i in range(3):
            language_goal = self.lang_template.format(size=size_names[i], place="stand" if i == 0 else size_names[i-1] + " cylinder")
            self.add_goal(
                objs=[cylinder_ids[i]],  # Object to move
                matches=np.ones((1, 1)),  # Single object to single target
                targ_poses=[targ_poses[i]],  # Target pose
                replace=False,  # Object cannot match with multiple targets
                rotations=True,  # Allow rotation
                metric='pose',  # Use pose metric
                params=None,  # No additional parameters
                step_max_reward=1 / 3,  # Equal reward for each step, summing to 1
                language_goal=language_goal  # Language goal
            )

current task list:
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- stack-block-pyramid: {'assets-used': ['stacking/stand.urdf', 'stacking/block.urdf'], 'task-description': 'sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.', 'task-name': 'stack-block-pyramid'}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- cylinder_hurdle_arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- color_coded_pallet_organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color-coded-pallet-organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}




=========
Reply explain your reasons and then say True or False, formatted in a python dictionary, do not miss commas or add extra spaces. Here are some examples.

{
	"task_name": "sort-color-blocks",
	"task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "yellow-bowl.urdf", "box/box-template.urdf],
	"reasons": "not interesting because it overlaps with the current task `put-block-in-bowl`"
	"add_to_the_task_list": "False",
}

{
  	"task-name": "guided-ball-maze",
  	"task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
  	"assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
   	"reasons": "the language descriptions are too ambiguous. Navigation is also hard to complete."
  	"add_to_the_task_list": "False",  
}

{
 	"task-name": "sort-blocks-by-zone",
 	"task-description": "Sort different colored blocks into their corresponding colored zones marked on the tabletop.",
 	"assets-used": ["zone/zone.urdf", "stacking/block.urdf"],
	"reasons": "the task is not covered in the current list and is an interesting combination of zone and block objects." 
	"add_to_the_task_list": "True",
}

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
    "reasons": "this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "arrange-blocks-on-pallet",
    "task-description": "arrange the blocks on the pallet in the order: red, orange, yellow, green, blue, and purple.",
    "assets-used": ["stacking/block.urdf", "pallet/pallelt.urdf"],
    "reasons": "this task overlaps with `arrange-boxes-on-pallet` by merely changing the blocks to boxes.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "cylinder-color-alignment",
    "task-description": "Pick up cylinders of different colors and align them inside a box in the order of the colors displayed on the single green line on the tabletop.",
    "assets-used": ["cylinder/cylinder-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf   
    "reasons": "the execution code only has one goal, i.e. it will only move one cylinder on top of the box, which is not that interesting.", 
    "add_to_the_task_list": "False","]
}

{
    "task-name": "build-bridge",
    "task-description": "Construct a bridge using two yellow blocks and three blue blocks. Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between. Then, place the blue block horizontally on top of the yellow blocks.",
     "assets-used": ["block/block.urdf", "ball/ball-template.urdf"]
    "reasons": "this task is an interesting and long-horizon task for pick and place primitives. Training manipulation agent with this skill will be a useful building block for next skills.", 
    "add_to_the_task_list": "True",
}

=========

Please incorporate these feedbacks when you design new task!



>>> Prompt: 


Do you think your task is sufficently interesting to be added as a new task for future task given that we already have the following task name and descriptions? Moreover, does the simulation code achieve the goal and the language descriptions in the task? Be as rigorous and high-standard as possible.

Reminder:
your task:
{'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}

import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderTowerBalancing(Task):
    """Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice that number
        self.lang_template = "stack the {size} cylinder on the {place}"
        self.task_completed_desc = "done constructing the cylinder tower."
        self.ee = Suction  # Using Suction since we need to move objects on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the sizes for the cylinders (large, medium, small)
        sizes = [(0.08, 0.08, 0.12), (0.06, 0.06, 0.09), (0.04, 0.04, 0.06)]
        size_names = ['large', 'medium', 'small']
        colors = ['blue', 'green', 'red']  # Assigning colors to each cylinder

        # Add stand.
        stand_size = (0.05, 0.05, 0.005)
        stand_urdf = 'stacking/stand.urdf'
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object(stand_urdf, stand_pose, category='fixed')

        # Add cylinders.
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []
        cylinder_ids = []
        for i in range(3):
            # Generate a random pose for the cylinder
            pose = self.get_random_pose(env, sizes[i])
            replace = {
                'DIM': sizes[i],
                'HALF': tuple([x / 2 for x in sizes[i]]),
                'COLOR': utils.COLORS[colors[i]]
            }
            # Fill the URDF template with size and color
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, pose)
            cylinder_poses.append(pose)
            cylinder_ids.append(cylinder_id)

        # Define the target poses for each cylinder, stacked on the stand
        targ_poses = [
            (stand_pose[0], stand_pose[1]),  # Bottom cylinder on the stand
            (utils.apply(stand_pose, (0, 0, sizes[0][2])), stand_pose[1]),  # Middle cylinder on top of the bottom cylinder
            (utils.apply(stand_pose, (0, 0, sizes[0][2] + sizes[1][2])), stand_pose[1])  # Top cylinder on top of the middle cylinder
        ]

        # Add goals for each cylinder
        for i in range(3):
            language_goal = self.lang_template.format(size=size_names[i], place="stand" if i == 0 else size_names[i-1] + " cylinder")
            self.add_goal(
                objs=[cylinder_ids[i]],  # Object to move
                matches=np.ones((1, 1)),  # Single object to single target
                targ_poses=[targ_poses[i]],  # Target pose
                replace=False,  # Object cannot match with multiple targets
                rotations=True,  # Allow rotation
                metric='pose',  # Use pose metric
                params=None,  # No additional parameters
                step_max_reward=1 / 3,  # Equal reward for each step, summing to 1
                language_goal=language_goal  # Language goal
            )

current task list:
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- stack-block-pyramid: {'assets-used': ['stacking/stand.urdf', 'stacking/block.urdf'], 'task-description': 'sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.', 'task-name': 'stack-block-pyramid'}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- cylinder_hurdle_arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- color_coded_pallet_organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color-coded-pallet-organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}




=========
Reply explain your reasons and then say True or False, formatted in a python dictionary, do not miss commas or add extra spaces. Here are some examples.

{
	"task_name": "sort-color-blocks",
	"task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "yellow-bowl.urdf", "box/box-template.urdf],
	"reasons": "not interesting because it overlaps with the current task `put-block-in-bowl`"
	"add_to_the_task_list": "False",
}

{
  	"task-name": "guided-ball-maze",
  	"task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
  	"assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
   	"reasons": "the language descriptions are too ambiguous. Navigation is also hard to complete."
  	"add_to_the_task_list": "False",  
}

{
 	"task-name": "sort-blocks-by-zone",
 	"task-description": "Sort different colored blocks into their corresponding colored zones marked on the tabletop.",
 	"assets-used": ["zone/zone.urdf", "stacking/block.urdf"],
	"reasons": "the task is not covered in the current list and is an interesting combination of zone and block objects." 
	"add_to_the_task_list": "True",
}

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
    "reasons": "this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "arrange-blocks-on-pallet",
    "task-description": "arrange the blocks on the pallet in the order: red, orange, yellow, green, blue, and purple.",
    "assets-used": ["stacking/block.urdf", "pallet/pallelt.urdf"],
    "reasons": "this task overlaps with `arrange-boxes-on-pallet` by merely changing the blocks to boxes.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "cylinder-color-alignment",
    "task-description": "Pick up cylinders of different colors and align them inside a box in the order of the colors displayed on the single green line on the tabletop.",
    "assets-used": ["cylinder/cylinder-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf   
    "reasons": "the execution code only has one goal, i.e. it will only move one cylinder on top of the box, which is not that interesting.", 
    "add_to_the_task_list": "False","]
}

{
    "task-name": "build-bridge",
    "task-description": "Construct a bridge using two yellow blocks and three blue blocks. Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between. Then, place the blue block horizontally on top of the yellow blocks.",
     "assets-used": ["block/block.urdf", "ball/ball-template.urdf"]
    "reasons": "this task is an interesting and long-horizon task for pick and place primitives. Training manipulation agent with this skill will be a useful building block for next skills.", 
    "add_to_the_task_list": "True",
}

=========

Please incorporate these feedbacks when you design new task!



>>> Answer: 
{
    "task-name": "cylinder-tower-balancing",
    "task-description": "Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.",
    "assets-used": ["cylinder/cylinder-template.urdf", "stacking/stand.urdf"],
    "reasons": "The task is sufficiently distinct from other stacking tasks such as 'stack-block-pyramid' and 'cylinder-hurdle-arrangement' as it involves precise stacking of cylinders in order of size rather than blocks or arranging cylinders over hurdles. The language descriptions accurately describe the goal of stacking cylinders of different sizes in a specific order, which adds a clear linguistic component to the task. The simulation code appears to correctly implement the task, including the addition of objects to the environment, the definition of target poses, and the setting of goals with language descriptions.",
    "add_to_the_task_list": "True",
}

================= Task and Asset Design!

>>> Prompt: 
You are an AI in robot simulation code and task design. I will provide you some example tasks, code implementation, and some guidelines for how to generate tasks and then you will help me generate a new task. My goal is to design diverse and feasible tasks for tabletop manipulation. I will first ask you to describe the task in natural languages and then will let you write the code for it. 

=========
Here are all the assets. Use only these assets in the task and code design. 
"""
insertion/:
ell.urdf  fixture.urdf

bowl/:
bowl.urdf

box/:
box-template.urdf

stacking/:
block.urdf  stand.urdf

zone/:
zone.obj  zone.urdf

pallet/:
pallet.obj  pallet.urdf

ball/:
ball-template.urdf

cylinder/:
cylinder-template.urdf

bowl/:
bowl.urdf

# assets not for picking
corner/:
corner-template.urdf

line/:
single-green-line-template.urdf

container/:
container-template.urdf
"""
 
=========
Here are some examples of good tasks. Try to learn from these structures but avoid overlapping wiht them.

{"assets-used": ["zone/zone.urdf", "block/small.urdf"],
 "task-description": "Push piles of small objects into a target goal zone marked on the tabletop.",
 "task-name": "sweeping-piles"}

{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "Place all blocks of a specified color in a bowl of specified color.",
 "task-name": "put-block-in-bowl"}
 
{"assets-used": ["insertion/ell.urdf", "insertion/fixture.urdf"],
 "task-description": "pick up the L-shaped red block and place it into the L-shaped fixture.",
 "task-name": "block-insertion"}
 
{"assets-used": ["kitting/kit.urdf", "kitting/object-template.urdf"],
 "task-description": "pick up different objects and arrange them on a board marked with corresponding silhouettes.",
 "task-name": "assembling-kits"}
 
{"assets-used": ["pallet/pallet.urdf", "box/box-template.urdf"],
 "task-description": "pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.",
 "task-name": "palletizing-boxes"}
 
{"assets-used": ["stacking/stand.urdf", "stacking/block.urdf"],
 "task-description": "sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.",
 "task-name": "stack-block-pyramid"}
 
{"assets-used": ["container/container-template.urdf", "box/box-template.urdf"],
 "task-description": "pick up randomly sized boxes and place them tightly into a container.",
 "task-name": "packing-boxes"}
 
{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "pick up the red blocks and place them into the green bowls amidst other objects.",
 "task-name": "place-red-in-green"}
 
{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

=========
Here are some tasks that you have come up with before. Try to learn from these structures but avoid overlapping with these tasks. For instance, `bowl_ball_placement` and `sort_balls_in_bowls` are the same task. `pile_boxes_in_corner` and `stack_blocks_into_pallet` are similar tasks, `align-cylinder-in-corner` and `align-cylinder-corner` are similar.
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- cylinder_hurdle_arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- color-coded-pallet-organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}
- stack-block-pyramid: {'assets-used': ['stacking/stand.urdf', 'stacking/block.urdf'], 'task-description': 'sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.', 'task-name': 'stack-block-pyramid'}
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- color_coded_pallet_organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}





=========
Here are some bad example task instances with explanations.
{
    "task_name": "sort-color-blocks",
    "task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "box/box-template.urdf],
}
reasons: not interesting because it overlaps with the current task `put-block-in-bowl`.

{
    "task-name": "guided-ball-maze",
    "task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
    "assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
}
reasons: the language descriptions are too ambiguous. Navigation is also hard to complete. Also maze.urf does not exist.

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
}
reasons: this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere. Similarly tasks like `insert-ball-into-cylinder` and `cylinder-box-insertion` are invalid.

{
    "task-name": "ball-box-obstacle-course",
    "task-description": "Navigate a ball through an obstacle course created by randomly placed boxes and finally place it inside a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: Navigate the ball is not related to tabletop manipulation tasks.

{
    "task-name": "ball-in-box",
    "task-description": "Use a cable to guide a ball into an open box.",
    "assets-used": ["cable/cable.urdf", "ball/ball-template.urdf", "box/box-template.urdf"]
}
reasons: This task is too hard since it involves interaction of the cable and the ball and cannot be easily completed.

{
    "task-name": "ball-in-container",
    "task-description": "Use the spatula to lift a ball over a wall of boxes and drop it into a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: The only action primitives as pick and place. One cannot use a spatula to lift an object.

{
    "task-name": "line-ball-sorting",
    "task-description": "Move balls of different colors along a single green line, placing each ball in a designated colored box at the end of the line. The challenge includes precision in maintaining the ball on the line and the correct identification of the box color corresponding to each ball.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf"]
}
reasons: Piling or stacking balls are physically infeasible in the simulation.



=========
Now please describe the new task in natural languages and explain its novelty and challenges. Format the answer in a python dictionary with keys "task-name" and value type string, "task-description" (one specific sentence) and value type string, and "assets-used" and value type list of strings. Note that

- Do not use assets that are not in the list above. 
- Tasks that have more colors and shapes are interesting.
- Be as specific as possible about the number, shape, and color of each asset in the task descriptions. 
- The task need to obey physics and remain feasible.





>>> Answer: 
Here's a new tabletop manipulation task described in natural language, ensuring feasibility and novelty while adhering to the constraints provided:

```python
{
    "task-name": "color-gradient-tower",
    "task-description": "Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.",
    "assets-used": ["stacking/stand.urdf", "cylinder/cylinder-template.urdf", "zone/zone.urdf"]
}
```

Novelty and Challenges:
- The task introduces a color gradient concept which adds complexity to the sorting criteria. Unlike simply sorting by color, the robot needs to discern the gradient from darkest to lightest, which can be more subtle.
- The inclusion of no-go zones (marked on the tabletop) adds an additional layer of spatial awareness and precision required by the robot. It must stack the cylinders in the correct order while also considering where it can move or place objects.
- It focuses on precise manipulation and planning, as the cylinders must be accurately placed on the stand without knocking over the tower.
- The task leverages color recognition, spatial reasoning, and delicate handling of the cylinders, all of which are key skills for robotic manipulation.

================= API Preview!

>>> Prompt: 
Before writing the code for the task "color-gradient-tower". Here are some APIs that are defined. Please confirm that you understand these APIs.

"""
class Task():
    """Base Task class."""

    def __init__(self):
        self.ee = Suction
        self.mode = 'train'
        self.sixdof = False
        self.primitive = primitives.PickPlace()
        self.oracle_cams = cameras.Oracle.CONFIG

        # Evaluation epsilons (for pose evaluation metric).
        self.pos_eps = 0.01
        self.rot_eps = np.deg2rad(15)

        # Workspace bounds.
        self.pix_size = 0.003125
        self.bounds = np.array([[0.25, 0.75], [-0.5, 0.5], [0, 0.3]])
        self.zone_bounds = np.copy(self.bounds)

        self.goals = []
        self.lang_goals = []
        self.task_completed_desc = "task completed."
        self.progress = 0
        self._rewards = 0
        self.assets_root = None

    def reset(self, env):
        if not self.assets_root:
            raise ValueError('assets_root must be set for task, '
                             'call set_assets_root().')
        self.goals = []
        self.lang_goals = []
        self.progress = 0  # Task progression metric in range [0, 1].
        self._rewards = 0  # Cumulative returned rewards.

    # -------------------------------------------------------------------------
    # Oracle Agent
    # -------------------------------------------------------------------------

    def oracle(self, env):
        """Oracle agent."""
        OracleAgent = collections.namedtuple('OracleAgent', ['act'])

        def act(obs, info):
            """Calculate action."""

            # Oracle uses perfect RGB-D orthographic images and segmentation masks.
            _, hmap, obj_mask = self.get_true_image(env)

            # Unpack next goal step.
            objs, matches, targs, replace, rotations, _, _, _ = self.goals[0]

            # Match objects to targets without replacement.
            if not replace:

                # Modify a copy of the match matrix.
                matches = matches.copy()

                # Ignore already matched objects.
                for i in range(len(objs)):
                    object_id, (symmetry, _) = objs[i]
                    pose = p.getBasePositionAndOrientation(object_id)
                    targets_i = np.argwhere(matches[i, :]).reshape(-1)
                    for j in targets_i:
                        if self.is_match(pose, targs[j], symmetry):
                            matches[i, :] = 0
                            matches[:, j] = 0

            # Get objects to be picked (prioritize farthest from nearest neighbor).
            nn_dists = []
            nn_targets = []
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                xyz, _ = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                if len(targets_i) > 0:
                    targets_xyz = np.float32([targs[j][0] for j in targets_i])
                    dists = np.linalg.norm(
                        targets_xyz - np.float32(xyz).reshape(1, 3), axis=1)
                    nn = np.argmin(dists)
                    nn_dists.append(dists[nn])
                    nn_targets.append(targets_i[nn])

                # Handle ignored objects.
                else:
                    nn_dists.append(0)
                    nn_targets.append(-1)
            order = np.argsort(nn_dists)[::-1]

            # Filter out matched objects.
            order = [i for i in order if nn_dists[i] > 0]

            pick_mask = None
            for pick_i in order:
                pick_mask = np.uint8(obj_mask == objs[pick_i][0])

                # Erode to avoid picking on edges.
                # pick_mask = cv2.erode(pick_mask, np.ones((3, 3), np.uint8))

                if np.sum(pick_mask) > 0:
                    break

            # Trigger task reset if no object is visible.
            if pick_mask is None or np.sum(pick_mask) == 0:
                self.goals = []
                self.lang_goals = []
                print('Object for pick is not visible. Skipping demonstration.')
                return

            # Get picking pose.
            pick_prob = np.float32(pick_mask)
            pick_pix = utils.sample_distribution(pick_prob)
            # For "deterministic" demonstrations on insertion-easy, use this:
            # pick_pix = (160,80)
            pick_pos = utils.pix_to_xyz(pick_pix, hmap,
                                        self.bounds, self.pix_size)
            pick_pose = (np.asarray(pick_pos), np.asarray((0, 0, 0, 1)))

            # Get placing pose.
            targ_pose = targs[nn_targets[pick_i]]
            obj_pose = p.getBasePositionAndOrientation(objs[pick_i][0])
            if not self.sixdof:
                obj_euler = utils.quatXYZW_to_eulerXYZ(obj_pose[1])
                obj_quat = utils.eulerXYZ_to_quatXYZW((0, 0, obj_euler[2]))
                obj_pose = (obj_pose[0], obj_quat)
            world_to_pick = utils.invert(pick_pose)
            obj_to_pick = utils.multiply(world_to_pick, obj_pose)
            pick_to_obj = utils.invert(obj_to_pick)
            place_pose = utils.multiply(targ_pose, pick_to_obj)

            # Rotate end effector?
            if not rotations:
                place_pose = (place_pose[0], (0, 0, 0, 1))

            place_pose = (np.asarray(place_pose[0]), np.asarray(place_pose[1]))

            return {'pose0': pick_pose, 'pose1': place_pose}

        return OracleAgent(act)

    # -------------------------------------------------------------------------
    # Reward Function and Task Completion Metrics
    # -------------------------------------------------------------------------

    def reward(self):
        """Get delta rewards for current timestep.

        Returns:
          A tuple consisting of the scalar (delta) reward, plus `extras`
            dict which has extra task-dependent info from the process of
            computing rewards that gives us finer-grained details. Use
            `extras` for further data analysis.
        """
        reward, info = 0, {}

        # Unpack next goal step.
        objs, matches, targs, _, _, metric, params, max_reward = self.goals[0]

        # Evaluate by matching object poses.
        if metric == 'pose':
            step_reward = 0
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                pose = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                for j in targets_i:
                    target_pose = targs[j]
                    if self.is_match(pose, target_pose, symmetry):
                        step_reward += max_reward / len(objs)
                        print(f"object {i} match with target {j} rew: {step_reward}")
                        break

        # Evaluate by measuring object intersection with zone.
        elif metric == 'zone':
            zone_pts, total_pts = 0, 0
            obj_pts, zones = params
            for zone_idx, (zone_pose, zone_size) in enumerate(zones):

                # Count valid points in zone.
                for obj_idx, obj_id in enumerate(obj_pts):
                    pts = obj_pts[obj_id]
                    obj_pose = p.getBasePositionAndOrientation(obj_id)
                    world_to_zone = utils.invert(zone_pose)
                    obj_to_zone = utils.multiply(world_to_zone, obj_pose)
                    pts = np.float32(utils.apply(obj_to_zone, pts))
                    if len(zone_size) > 1:
                        valid_pts = np.logical_and.reduce([
                            pts[0, :] > -zone_size[0] / 2, pts[0, :] < zone_size[0] / 2,
                            pts[1, :] > -zone_size[1] / 2, pts[1, :] < zone_size[1] / 2,
                            pts[2, :] < self.zone_bounds[2, 1]])

                    # if zone_idx == matches[obj_idx].argmax():
                    zone_pts += np.sum(np.float32(valid_pts))
                    total_pts += pts.shape[1]
            step_reward = max_reward * (zone_pts / total_pts)

        # Get cumulative rewards and return delta.
        reward = self.progress + step_reward - self._rewards
        self._rewards = self.progress + step_reward

        # Move to next goal step if current goal step is complete.
        if np.abs(max_reward - step_reward) < 0.01:
            self.progress += max_reward  # Update task progress.
            self.goals.pop(0)
            if len(self.lang_goals) > 0:
                self.lang_goals.pop(0)

        return reward, info

    def done(self):
        """Check if the task is done or has failed.

        Returns:
          True if the episode should be considered a success, which we
            use for measuring successes, which is particularly helpful for tasks
            where one may get successes on the very last time step, e.g., getting
            the cloth coverage threshold on the last alllowed action.
            However, for bag-items-easy and bag-items-hard (which use the
            'bag-items' metric), it may be necessary to filter out demos that did
            not attain sufficiently high reward in external code. Currently, this
            is done in `main.py` and its ignore_this_demo() method.
        """
        return (len(self.goals) == 0) or (self._rewards > 0.99)
        # return zone_done or defs_done or goal_done

    # -------------------------------------------------------------------------
    # Environment Helper Functions
    # -------------------------------------------------------------------------

    def is_match(self, pose0, pose1, symmetry):
        """Check if pose0 and pose1 match within a threshold."""

        # Get translational error.
        diff_pos = np.float32(pose0[0][:2]) - np.float32(pose1[0][:2])
        dist_pos = np.linalg.norm(diff_pos)

        # Get rotational error around z-axis (account for symmetries).
        diff_rot = 0
        if symmetry > 0:
            rot0 = np.array(utils.quatXYZW_to_eulerXYZ(pose0[1]))[2]
            rot1 = np.array(utils.quatXYZW_to_eulerXYZ(pose1[1]))[2]
            diff_rot = np.abs(rot0 - rot1) % symmetry
            if diff_rot > (symmetry / 2):
                diff_rot = symmetry - diff_rot

        return (dist_pos < self.pos_eps) and (diff_rot < self.rot_eps)

    def get_random_pose(self, env, obj_size):
        """Get random collision-free object pose within workspace bounds."""

        # Get erosion size of object in pixels.
        max_size = np.sqrt(obj_size[0] ** 2 + obj_size[1] ** 2)
        erode_size = int(np.round(max_size / self.pix_size))

        _, hmap, obj_mask = self.get_true_image(env)

        # Randomly sample an object pose within free-space pixels.
        free = np.ones(obj_mask.shape, dtype=np.uint8)
        for obj_ids in env.obj_ids.values():
            for obj_id in obj_ids:
                free[obj_mask == obj_id] = 0
        free[0, :], free[:, 0], free[-1, :], free[:, -1] = 0, 0, 0, 0
        free = cv2.erode(free, np.ones((erode_size, erode_size), np.uint8))

        # if np.sum(free) == 0:
        #     return None, None

        if np.sum(free) == 0:
            # avoid returning None, None
            # return None, None
            pix = (obj_mask.shape[0] // 2, obj_mask.shape[1] // 2)
        else:
            pix = utils.sample_distribution(np.float32(free))
        pos = utils.pix_to_xyz(pix, hmap, self.bounds, self.pix_size)
        pos = (pos[0], pos[1], obj_size[2] / 2)
        theta = np.random.rand() * 2 * np.pi
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta))
        return pos, rot

    def get_lang_goal(self):
        if len(self.lang_goals) == 0:
            return self.task_completed_desc
        else:
            return self.lang_goals[0]

    def get_reward(self):
        return float(self._rewards)

    # -------------------------------------------------------------------------
    # Helper Functions
    # -------------------------------------------------------------------------

    def fill_template(self, template, replace):
        """Read a file and replace key strings."""
        full_template_path = os.path.join(self.assets_root, template)
        with open(full_template_path, 'r') as file:
            fdata = file.read()
        for field in replace:
            for i in range(len(replace[field])):
                fdata = fdata.replace(f'{field}{i}', str(replace[field][i]))
        alphabet = string.ascii_lowercase + string.digits
        rname = ''.join(random.choices(alphabet, k=16))
        tmpdir = tempfile.gettempdir()
        template_filename = os.path.split(template)[-1]
        fname = os.path.join(tmpdir, f'{template_filename}.{rname}')
        with open(fname, 'w') as file:
            file.write(fdata)
        return fname

    def get_random_size(self, min_x, max_x, min_y, max_y, min_z, max_z):
        """Get random box size."""
        size = np.random.rand(3)
        size[0] = size[0] * (max_x - min_x) + min_x
        size[1] = size[1] * (max_y - min_y) + min_y
        size[2] = size[2] * (max_z - min_z) + min_z
        return tuple(size)

    def color_random_brown(self, obj):
        shade = np.random.rand() + 0.5
        color = np.float32([shade * 156, shade * 117, shade * 95, 255]) / 255
        p.changeVisualShape(obj, -1, rgbaColor=color)

  """""
  
  # Environment Class
  def add_object(self, urdf, pose, category='rigid'):
    """List of (fixed, rigid, or deformable) objects in env."""
    fixed_base = 1 if category == 'fixed' else 0
    obj_id = pybullet_utils.load_urdf(
        p,
        os.path.join(self.assets_root, urdf),
        pose[0],
        pose[1],
        useFixedBase=fixed_base)
    self.obj_ids[category].append(obj_id)
    return obj_id
"""

=========
Note that the objects need to obey physics and not collide with each other, and the object goal poses need to be above the table with lower bound x=0.25, y=-0.5 and upper bound x=0.75, y=0.5. When there are multiple objects for a multi-step pick-and-place task, there are often multiple subgoals. Once the task and environment are generated, an agent with a pick and place primitive will follow the defined goal to accomplish the tasks. 

Additionally, make sure you understand and summarize the ``self.goals`` variables, which has a list of 8-tuple with (objs, matches, targ_poses, replace, rotations, metric, params, step_max_reward, symmetries).
- objs (List of obj_id): object ID.
- matches (Binary Matrix): a binary matrix that denotes which object is matched with which target. This matrix has dimension len(objs) x len(targs).
- targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation). 
- replace (Boolean): whether each object can match with one unique target. This is important if we have one target and multiple objects. If it's set to be false, then any object matching with the target will satisfy.
- rotations (Boolean): whether the placement action has a rotation degree of freedom. 
- metric (`pose` or `zone`): `pose` or `zone` that the object needs to be transported to. Example: `pose`. 
- params (List of (zone_target, zone_size)): a list of (zone_target, zone_size) for each zone if the metric is `zone`. 
- step_max_reward (float): the total reward of matching all the objects with all the target poses. It is not dependent on the number of objects but dependent on the number of goals. 
- symmetries: the radians that the object is symmetric around z axis.
- language_goal: the low-level language instructions that denote the goal of this step.
 


>>> Answer: 
I understand the provided APIs and the structure of the `Task` class, as well as the `add_object` function for the environment. Here's a summary of my understanding:

### Task Class
- The `Task` class is a base class for defining robotic tasks.
- It initializes with a set of default parameters, including end-effector type, mode, six degrees of freedom (DoF) flag, a pick-and-place primitive, and camera configurations.
- The `reset` method is used to reset the task state.
- The `oracle` method provides an oracle agent that can generate actions based on perfect knowledge of the environment.
- The `reward` method calculates the reward for the current timestep based on the task's goals.
- The `done` method checks if the task is completed or has failed.
- The `is_match` method checks if two poses match within a specified threshold.
- The `get_random_pose` method generates a random collision-free pose within the workspace bounds.
- The `get_lang_goal` method retrieves the current language goal.
- The `get_reward` method returns the current cumulative reward.
- The `fill_template` method is a utility to read a file and replace key strings with specified values.
- The `get_random_size` method generates a random size for an object within specified bounds.
- The `color_random_brown` method assigns a random brown color to an object.

### Environment Class
- The `add_object` method is used to add objects to the environment, specifying the object's URDF file, pose, and category (fixed, rigid, or deformable).

### self.goals Variable
- `self.goals` is a list of 8-tuples that define the subgoals for a task.
- Each tuple contains:
  - `objs`: A list of object IDs.
  - `matches`: A binary matrix indicating which objects are matched with which targets.
  - `targ_poses`: A list of target poses, each a tuple of translation and rotation.
  - `replace`: A boolean indicating if objects can match with multiple targets or just one.
  - `rotations`: A boolean indicating if the placement action includes rotation.
  - `metric`: A string ('pose' or 'zone') specifying the type of goal.
  - `params`: Additional parameters, such as zone targets and sizes if the metric is 'zone'.
  - `step_max_reward`: The total reward for completing the subgoal.
  - `symmetries`: The radians of symmetry around the z-axis for the objects.
  - `language_goal`: Low-level language instructions describing the subgoal.

With this understanding, I can proceed to write the simulation code for the "color-gradient-tower" task, ensuring that the objects obey physics, do not collide with each other, and that the goal poses are within the specified bounds. The task will involve multiple subgoals, each defined by the `self.goals` variable, and will be accomplished by an agent using pick-and-place primitives.

================= Code Generation!

>>> Prompt: 
Now I will provide you some reference code and you can write the code for the task "color-gradient-tower".


"""
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class PackingShapes(Task):
    """pick up randomly sized shapes and place them tightly into a container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 1
        self.homogeneous = False

        self.lang_template = "pack the {obj} in the brown box"
        self.task_completed_desc = "done packing shapes."
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        # Shape Names:
        shapes = utils.assembling_kit_shapes

        n_objects = 5
        if self.mode == 'train':
            obj_shapes = np.random.choice(self.train_set, n_objects, replace=False)
        else:
            if self.homogeneous:
                obj_shapes = [np.random.choice(self.test_set, replace=False)] * n_objects
            else:
                obj_shapes = np.random.choice(self.test_set, n_objects, replace=False)

        # Shuffle colors to avoid always picking an object of the same color
        colors, color_names = utils.get_colors(mode=self.mode)

        # Add container box.
        zone_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, zone_pose, 'fixed')

        # Add objects.
        objects = []
        template = 'kitting/object-template.urdf'
        for i in range(n_objects):
            shape = obj_shapes[i]

            # x, y, z dimensions for the asset size
            size = (0.08, 0.08, 0.02)
            pose= self.get_random_pose(env, size)
            fname = f'{shape:02d}.obj'
            fname = os.path.join(self.assets_root, 'kitting', fname)
            scale = [0.003, 0.003, 0.001]  # .0005
            replace = {'FNAME': (fname,),
                       'SCALE': scale,
                       'COLOR': colors[i]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            block_id = env.add_object(urdf, pose)
            objects.append(block_id)

        # Pick the first shape.
        num_objects_to_pick = 1
        for i in range(num_objects_to_pick):
            # IMPORTANT: Specify (obj_pts, [(zone_pose, zone_size)]) for target `zone`. obj_pts is a dict
            language_goal = self.lang_template.format(obj=shapes[obj_shapes[i]])
            self.add_goal(objs=[objects[i]], matches=np.int32([[1]]), targ_poses=[zone_pose], replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1 / num_objects_to_pick,
                language_goal=language_goal)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PlaceRedInGreen(Task):
    """pick up the red blocks and place them into the green bowls amidst other objects."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = "put the red blocks in a green bowl"
        self.task_completed_desc = "done placing blocks in bowls."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_blocks = np.random.randint(1, n_bowls + 1)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, obj_size=bowl_size)
            env.add_object(urdf=bowl_urdf, pose=bowl_pose, category='fixed')
            bowl_poses.append(bowl_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        for _ in range(n_blocks):
            block_pose = self.get_random_pose(env, obj_size=block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Goal: each red block is in a different green bowl.
        self.add_goal(objs=blocks, matches=np.ones((len(blocks), len(bowl_poses))), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

        # Colors of distractor objects.
        bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'green']
        block_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'red']

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = block_colors if is_block else bowl_colors
            pose = self.get_random_pose(env, obj_size=size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1
"""
"""
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils


class SweepingPiles(Task):
    """Push piles of small objects into a target goal zone marked on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = "push the pile of blocks into the green square"
        self.task_completed_desc = "done sweeping."
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add goal zone.
        zone_size = (0.12, 0.12, 0)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add pile of small blocks with `make_piles` function
        obj_ids = self.make_piles(env)

        # Add goal
        self.add_goal(objs=obj_ids, matches=np.ones((50, 1)), targ_poses=[zone_pose], replace=True,
                rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class StackBlockPyramid(Task):
    """Build a pyramid of colored blocks in a color sequence"""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = "make the {row} row with {blocks}"
        self.task_completed_desc = "done stacking block pyramid."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['red']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, blue, purple).
        language_goal = self.lang_template.format(blocks="the green, blue and purple blocks", row="bottom")
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (middle row: yellow, orange).
        language_goal = self.lang_template.format(blocks="the yellow and orange blocks", row="middle")      
        self.add_goal(objs=objs[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (top row: red).
        language_goal = self.lang_template.format(blocks="the red block", row="top")
        self.add_goal(objs=objs[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2]*1, language_goal=language_goal)
"""



Do not use libraries, functions, and assets that you don't know. For each object, try to describe its color, size, category in the task first before you write the code. You do not need extra helper functions. Comment the code liberally to explain what each piece does and why it's written that way. If you have only one goal, `step_max_reward` in `add_goal` should be 1. Use functions `make_piles` and `make_ropes` for creating piles and cables. To use spatula together with the push primitives, import the libraries 
"""
from cliport.tasks import primitives;
from cliport.tasks.grippers import Spatula
"""
and then use `self.primitive = primitives.push` and `self.ee = Spatula`.
Note that the number of language goals usually match the number of motion goals, since they should correspond to each other.

Before generate code, you have a few considerations to focus on:
1. You are strictly prohibited from using function interfaces that do not appear in the above sample code. For example, the module cliport.tasks.primitives does not have pick_plack or place functions, only the push function interface is available.
2. Module 'cliport.tasks.primitives' has no attribute 'pick_place', you mustn't use it.
3. There are two types of your Gripper, one is Spatula and the other is Suction.You need to choose a different end-effector depending on your task requirements. If you need to move an object on the Z axis, then you need to use the Suction type. If you just need to translate an object in a 2D plane, then you can use either Spatula or Suction type.
4. You must determine the type of end-effector you need to use based on the type of task you have. You can choose by adding self.ee=Spatula or self.ee=Suction to the __init__(self) function, the default self.ee is Suction.
5. If you want to use Suction, you must import module using "from cliport.tasks.grippers import Suction". Else if you want to use Spatula, you must import module using "from cliport.tasks.grippers import Spatula".
6. The x-coordinate of the object is in the range [0.25, 0.75], the y-coordinate is in the range [-0.5,0.5] and the z-coordinate is in the range [0, 0.3].
7. The initial position of all objects needs to get its random initial position through the get_random_pose function.
8. The self.max_steps parameter value should be greater than the number of calls to self.add_goal, and preferably equal to twice the number of calls to self.add_goal. For example, if you call self.add_goal twice in one task, then self.max_steps is better set to 4.

If you want to generate the color of the object, you have to obey following rules:
1. You must use the utils.COLORS['COLOR_NAME'] function interface to generate an RGB three-channel value for a color.
2. The available colors for 'COLOR_NAME' are blue, red, green, orange, yellow, purple, pink, cyan, brown, white, gray, indigo, violet, black, silver and gold.
3. If you want to generate a red object, then its RGB three-channel color can be obtained through utils.COLORS['red'].
All object’s colors generation must follow color generation method above.

If you want to generate the target pose of the object(third parameter of function 'self.add_goal' targ_poses), you have to obey following rules:
1. The target pose of an object is represented by the three-dimensional spatial coordinates of the object and its orientation quaternion.
2. The target pose of an object must be represented by [(x,y,z),(q1,q2,q3,q4)]. Where (x,y,z) are the three-dimensional coordinates of the object and (q1,q2,q3,q4) denote the quaternions of the object's target pose.
3. The target pose of an object must be generated by you or use the initial pose of an object as the target pose of the current object.
4. Here's an example, to generate the target pose of a Y object, we have the initial pose information of an X object. So target pose of Y can be represented by pose_y=[(x,y,z),(q1,q2,q3,q4)] or pose_y=initial_pose_x.(Where x,y,z,q1,q2,q3,q4 are specific values.)
5. targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation).
6. The targ_poses you generate must contain translation[x,y,z], but rotation[q0,q1,q2,q3] you may or may not generate.
All object's target pose generation must follow method above.

Now write the code for the task "color-gradient-tower" in python code block starting with ```python.  Reminder: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']} 


>>> Answer: 
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ColorGradientTower(Task):
    """Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones."""

    def __init__(self):
        super().__init__()
        self.max_steps = 12  # We expect to call self.add_goal six times, so we set max_steps to twice that number
        self.lang_template = "stack the {color} cylinder on the stand"
        self.task_completed_desc = "done building the color gradient tower."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector

    def reset(self, env):
        super().reset(env)

        # Define the colors in order from darkest to lightest
        color_names = ['indigo', 'blue', 'green', 'yellow', 'orange', 'red']
        colors = [utils.COLORS[name] for name in color_names]

        # Add the stand
        stand_size = (0.05, 0.05, 0.005)  # Size of the stand
        stand_urdf = 'stacking/stand.urdf'
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object(stand_urdf, stand_pose, category='fixed')

        # Add the no-go zone
        zone_size = (0.15, 0.15, 0)  # Size of the no-go zone
        zone_urdf = 'zone/zone.urdf'
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object(zone_urdf, zone_pose, 'fixed')

        # Add cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_size = (0.02, 0.02, 0.08)  # Size of the cylinders
        cylinder_poses = []
        for i, color in enumerate(colors):
            # Get a random pose for the cylinder
            pose = self.get_random_pose(env, cylinder_size)
            replace = {'COLOR': color}
            # Fill the URDF template with the color
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, pose)
            cylinder_poses.append((cylinder_id, pose))

        # Define the target poses for the cylinders on the stand
        # The cylinders should be stacked on top of each other in the order of the color gradient
        targ_poses = []
        for i in range(len(cylinder_poses)):
            x, y, z = stand_pose[0]
            # Increment the z-coordinate for each cylinder to stack them
            z += (i + 1) * cylinder_size[2]
            targ_poses.append(((x, y, z), (0, 0, 0, 1)))  # We keep the orientation the same

        # Add goals for each cylinder
        for i, (cylinder_id, _) in enumerate(cylinder_poses):
            language_goal = self.lang_template.format(color=color_names[i])
            self.add_goal(objs=[cylinder_id], matches=np.ones((1, 1)), targ_poses=[targ_poses[i]],
                          replace=False, rotations=False, metric='pose', params=None,
                          step_max_reward=1/6, language_goal=language_goal)

        # The task is set up with cylinders and goals, ready for the agent to execute
```

================= TRIAL: 5

================= Code Reflect!

>>> Prompt: 


Do you think your task is sufficently interesting to be added as a new task for future task given that we already have the following task name and descriptions? Moreover, does the simulation code achieve the goal and the language descriptions in the task? Be as rigorous and high-standard as possible.

Reminder:
your task:
{'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}

import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ColorGradientTower(Task):
    """Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones."""

    def __init__(self):
        super().__init__()
        self.max_steps = 12  # We expect to call self.add_goal six times, so we set max_steps to twice that number
        self.lang_template = "stack the {color} cylinder on the stand"
        self.task_completed_desc = "done building the color gradient tower."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector

    def reset(self, env):
        super().reset(env)

        # Define the colors in order from darkest to lightest
        color_names = ['indigo', 'blue', 'green', 'yellow', 'orange', 'red']
        colors = [utils.COLORS[name] for name in color_names]

        # Add the stand
        stand_size = (0.05, 0.05, 0.005)  # Size of the stand
        stand_urdf = 'stacking/stand.urdf'
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object(stand_urdf, stand_pose, category='fixed')

        # Add the no-go zone
        zone_size = (0.15, 0.15, 0)  # Size of the no-go zone
        zone_urdf = 'zone/zone.urdf'
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object(zone_urdf, zone_pose, 'fixed')

        # Add cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_size = (0.02, 0.02, 0.08)  # Size of the cylinders
        cylinder_poses = []
        for i, color in enumerate(colors):
            # Get a random pose for the cylinder
            pose = self.get_random_pose(env, cylinder_size)
            replace = {'COLOR': color}
            # Fill the URDF template with the color
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, pose)
            cylinder_poses.append((cylinder_id, pose))

        # Define the target poses for the cylinders on the stand
        # The cylinders should be stacked on top of each other in the order of the color gradient
        targ_poses = []
        for i in range(len(cylinder_poses)):
            x, y, z = stand_pose[0]
            # Increment the z-coordinate for each cylinder to stack them
            z += (i + 1) * cylinder_size[2]
            targ_poses.append(((x, y, z), (0, 0, 0, 1)))  # We keep the orientation the same

        # Add goals for each cylinder
        for i, (cylinder_id, _) in enumerate(cylinder_poses):
            language_goal = self.lang_template.format(color=color_names[i])
            self.add_goal(objs=[cylinder_id], matches=np.ones((1, 1)), targ_poses=[targ_poses[i]],
                          replace=False, rotations=False, metric='pose', params=None,
                          step_max_reward=1/6, language_goal=language_goal)

        # The task is set up with cylinders and goals, ready for the agent to execute

current task list:
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- stack-block-pyramid: {'assets-used': ['stacking/stand.urdf', 'stacking/block.urdf'], 'task-description': 'sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.', 'task-name': 'stack-block-pyramid'}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- cylinder_hurdle_arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- color_coded_pallet_organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color-coded-pallet-organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- cylinder_tower_balancing: {'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}
- cylinder-tower-balancing: {'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}




=========
Reply explain your reasons and then say True or False, formatted in a python dictionary, do not miss commas or add extra spaces. Here are some examples.

{
	"task_name": "sort-color-blocks",
	"task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "yellow-bowl.urdf", "box/box-template.urdf],
	"reasons": "not interesting because it overlaps with the current task `put-block-in-bowl`"
	"add_to_the_task_list": "False",
}

{
  	"task-name": "guided-ball-maze",
  	"task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
  	"assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
   	"reasons": "the language descriptions are too ambiguous. Navigation is also hard to complete."
  	"add_to_the_task_list": "False",  
}

{
 	"task-name": "sort-blocks-by-zone",
 	"task-description": "Sort different colored blocks into their corresponding colored zones marked on the tabletop.",
 	"assets-used": ["zone/zone.urdf", "stacking/block.urdf"],
	"reasons": "the task is not covered in the current list and is an interesting combination of zone and block objects." 
	"add_to_the_task_list": "True",
}

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
    "reasons": "this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "arrange-blocks-on-pallet",
    "task-description": "arrange the blocks on the pallet in the order: red, orange, yellow, green, blue, and purple.",
    "assets-used": ["stacking/block.urdf", "pallet/pallelt.urdf"],
    "reasons": "this task overlaps with `arrange-boxes-on-pallet` by merely changing the blocks to boxes.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "cylinder-color-alignment",
    "task-description": "Pick up cylinders of different colors and align them inside a box in the order of the colors displayed on the single green line on the tabletop.",
    "assets-used": ["cylinder/cylinder-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf   
    "reasons": "the execution code only has one goal, i.e. it will only move one cylinder on top of the box, which is not that interesting.", 
    "add_to_the_task_list": "False","]
}

{
    "task-name": "build-bridge",
    "task-description": "Construct a bridge using two yellow blocks and three blue blocks. Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between. Then, place the blue block horizontally on top of the yellow blocks.",
     "assets-used": ["block/block.urdf", "ball/ball-template.urdf"]
    "reasons": "this task is an interesting and long-horizon task for pick and place primitives. Training manipulation agent with this skill will be a useful building block for next skills.", 
    "add_to_the_task_list": "True",
}

=========

Please incorporate these feedbacks when you design new task!



>>> Answer: 
{
    "task-name": "color-gradient-tower",
    "task-description": "Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.",
    "assets-used": ["stacking/stand.urdf", "cylinder/cylinder-template.urdf", "zone/zone.urdf"],
    "reasons": "The task is unique in its requirement to order objects by color gradient, which is not covered by existing tasks. It also introduces an additional spatial reasoning challenge by incorporating no-go zones. The simulation code appears to correctly implement the task, including the setup of the environment with the stand and no-go zones, the addition of differently colored cylinders, and the definition of goals that require the cylinders to be stacked in a specific order. The language descriptions are clear and directly related to the task goals, providing unambiguous instructions for stacking the cylinders in the correct order.",
    "add_to_the_task_list": "True",
}

================= Task and Asset Design!

>>> Prompt: 
You are an AI in robot simulation code and task design. I will provide you some example tasks, code implementation, and some guidelines for how to generate tasks and then you will help me generate a new task. My goal is to design diverse and feasible tasks for tabletop manipulation. I will first ask you to describe the task in natural languages and then will let you write the code for it. 

=========
Here are all the assets. Use only these assets in the task and code design. 
"""
insertion/:
ell.urdf  fixture.urdf

bowl/:
bowl.urdf

box/:
box-template.urdf

stacking/:
block.urdf  stand.urdf

zone/:
zone.obj  zone.urdf

pallet/:
pallet.obj  pallet.urdf

ball/:
ball-template.urdf

cylinder/:
cylinder-template.urdf

bowl/:
bowl.urdf

# assets not for picking
corner/:
corner-template.urdf

line/:
single-green-line-template.urdf

container/:
container-template.urdf
"""
 
=========
Here are some examples of good tasks. Try to learn from these structures but avoid overlapping wiht them.

{"assets-used": ["zone/zone.urdf", "block/small.urdf"],
 "task-description": "Push piles of small objects into a target goal zone marked on the tabletop.",
 "task-name": "sweeping-piles"}

{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "Place all blocks of a specified color in a bowl of specified color.",
 "task-name": "put-block-in-bowl"}
 
{"assets-used": ["insertion/ell.urdf", "insertion/fixture.urdf"],
 "task-description": "pick up the L-shaped red block and place it into the L-shaped fixture.",
 "task-name": "block-insertion"}
 
{"assets-used": ["kitting/kit.urdf", "kitting/object-template.urdf"],
 "task-description": "pick up different objects and arrange them on a board marked with corresponding silhouettes.",
 "task-name": "assembling-kits"}
 
{"assets-used": ["pallet/pallet.urdf", "box/box-template.urdf"],
 "task-description": "pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.",
 "task-name": "palletizing-boxes"}
 
{"assets-used": ["stacking/stand.urdf", "stacking/block.urdf"],
 "task-description": "sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.",
 "task-name": "stack-block-pyramid"}
 
{"assets-used": ["container/container-template.urdf", "box/box-template.urdf"],
 "task-description": "pick up randomly sized boxes and place them tightly into a container.",
 "task-name": "packing-boxes"}
 
{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "pick up the red blocks and place them into the green bowls amidst other objects.",
 "task-name": "place-red-in-green"}
 
{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

=========
Here are some tasks that you have come up with before. Try to learn from these structures but avoid overlapping with these tasks. For instance, `bowl_ball_placement` and `sort_balls_in_bowls` are the same task. `pile_boxes_in_corner` and `stack_blocks_into_pallet` are similar tasks, `align-cylinder-in-corner` and `align-cylinder-corner` are similar.
- color_coded_pallet_organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- cylinder-tower-balancing: {'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- cylinder_tower_balancing: {'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- cylinder_hurdle_arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}





=========
Here are some bad example task instances with explanations.
{
    "task_name": "sort-color-blocks",
    "task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "box/box-template.urdf],
}
reasons: not interesting because it overlaps with the current task `put-block-in-bowl`.

{
    "task-name": "guided-ball-maze",
    "task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
    "assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
}
reasons: the language descriptions are too ambiguous. Navigation is also hard to complete. Also maze.urf does not exist.

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
}
reasons: this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere. Similarly tasks like `insert-ball-into-cylinder` and `cylinder-box-insertion` are invalid.

{
    "task-name": "ball-box-obstacle-course",
    "task-description": "Navigate a ball through an obstacle course created by randomly placed boxes and finally place it inside a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: Navigate the ball is not related to tabletop manipulation tasks.

{
    "task-name": "ball-in-box",
    "task-description": "Use a cable to guide a ball into an open box.",
    "assets-used": ["cable/cable.urdf", "ball/ball-template.urdf", "box/box-template.urdf"]
}
reasons: This task is too hard since it involves interaction of the cable and the ball and cannot be easily completed.

{
    "task-name": "ball-in-container",
    "task-description": "Use the spatula to lift a ball over a wall of boxes and drop it into a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: The only action primitives as pick and place. One cannot use a spatula to lift an object.

{
    "task-name": "line-ball-sorting",
    "task-description": "Move balls of different colors along a single green line, placing each ball in a designated colored box at the end of the line. The challenge includes precision in maintaining the ball on the line and the correct identification of the box color corresponding to each ball.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf"]
}
reasons: Piling or stacking balls are physically infeasible in the simulation.



=========
Now please describe the new task in natural languages and explain its novelty and challenges. Format the answer in a python dictionary with keys "task-name" and value type string, "task-description" (one specific sentence) and value type string, and "assets-used" and value type list of strings. Note that

- Do not use assets that are not in the list above. 
- Tasks that have more colors and shapes are interesting.
- Be as specific as possible about the number, shape, and color of each asset in the task descriptions. 
- The task need to obey physics and remain feasible.





>>> Answer: 
Based on the provided assets and guidelines, here is a new task description in natural language:

```python
{
    "task-name": "bowl-cylinder-sequence",
    "task-description": "Arrange a sequence of cylinders of varying heights into a large bowl, with the tallest cylinder in the center and progressively shorter cylinders around it, creating a terraced pattern.",
    "assets-used": ["bowl/bowl.urdf", "cylinder/cylinder-template.urdf"]
}
```

Explanation of its novelty and challenges:
- **Novelty**: This task introduces the concept of spatial reasoning and precision in placement within a container which has not been specifically targeted by the earlier tasks. It combines elements of pattern recognition (terraced pattern) and the handling of objects of varying sizes (cylinders of different heights).
  
- **Challenges**: The primary challenge is to pick and place objects of varying heights in a specific pattern that requires the robot to recognize height differences and spatially plan the sequence inside the bowl. Additionally, the task will require careful manipulation to prevent knocking over already placed cylinders when placing subsequent ones, thus emphasizing delicate interaction with the environment and the objects within the bowl.

================= API Preview!

>>> Prompt: 
Before writing the code for the task "bowl-cylinder-sequence". Here are some APIs that are defined. Please confirm that you understand these APIs.

"""
class Task():
    """Base Task class."""

    def __init__(self):
        self.ee = Suction
        self.mode = 'train'
        self.sixdof = False
        self.primitive = primitives.PickPlace()
        self.oracle_cams = cameras.Oracle.CONFIG

        # Evaluation epsilons (for pose evaluation metric).
        self.pos_eps = 0.01
        self.rot_eps = np.deg2rad(15)

        # Workspace bounds.
        self.pix_size = 0.003125
        self.bounds = np.array([[0.25, 0.75], [-0.5, 0.5], [0, 0.3]])
        self.zone_bounds = np.copy(self.bounds)

        self.goals = []
        self.lang_goals = []
        self.task_completed_desc = "task completed."
        self.progress = 0
        self._rewards = 0
        self.assets_root = None

    def reset(self, env):
        if not self.assets_root:
            raise ValueError('assets_root must be set for task, '
                             'call set_assets_root().')
        self.goals = []
        self.lang_goals = []
        self.progress = 0  # Task progression metric in range [0, 1].
        self._rewards = 0  # Cumulative returned rewards.

    # -------------------------------------------------------------------------
    # Oracle Agent
    # -------------------------------------------------------------------------

    def oracle(self, env):
        """Oracle agent."""
        OracleAgent = collections.namedtuple('OracleAgent', ['act'])

        def act(obs, info):
            """Calculate action."""

            # Oracle uses perfect RGB-D orthographic images and segmentation masks.
            _, hmap, obj_mask = self.get_true_image(env)

            # Unpack next goal step.
            objs, matches, targs, replace, rotations, _, _, _ = self.goals[0]

            # Match objects to targets without replacement.
            if not replace:

                # Modify a copy of the match matrix.
                matches = matches.copy()

                # Ignore already matched objects.
                for i in range(len(objs)):
                    object_id, (symmetry, _) = objs[i]
                    pose = p.getBasePositionAndOrientation(object_id)
                    targets_i = np.argwhere(matches[i, :]).reshape(-1)
                    for j in targets_i:
                        if self.is_match(pose, targs[j], symmetry):
                            matches[i, :] = 0
                            matches[:, j] = 0

            # Get objects to be picked (prioritize farthest from nearest neighbor).
            nn_dists = []
            nn_targets = []
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                xyz, _ = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                if len(targets_i) > 0:
                    targets_xyz = np.float32([targs[j][0] for j in targets_i])
                    dists = np.linalg.norm(
                        targets_xyz - np.float32(xyz).reshape(1, 3), axis=1)
                    nn = np.argmin(dists)
                    nn_dists.append(dists[nn])
                    nn_targets.append(targets_i[nn])

                # Handle ignored objects.
                else:
                    nn_dists.append(0)
                    nn_targets.append(-1)
            order = np.argsort(nn_dists)[::-1]

            # Filter out matched objects.
            order = [i for i in order if nn_dists[i] > 0]

            pick_mask = None
            for pick_i in order:
                pick_mask = np.uint8(obj_mask == objs[pick_i][0])

                # Erode to avoid picking on edges.
                # pick_mask = cv2.erode(pick_mask, np.ones((3, 3), np.uint8))

                if np.sum(pick_mask) > 0:
                    break

            # Trigger task reset if no object is visible.
            if pick_mask is None or np.sum(pick_mask) == 0:
                self.goals = []
                self.lang_goals = []
                print('Object for pick is not visible. Skipping demonstration.')
                return

            # Get picking pose.
            pick_prob = np.float32(pick_mask)
            pick_pix = utils.sample_distribution(pick_prob)
            # For "deterministic" demonstrations on insertion-easy, use this:
            # pick_pix = (160,80)
            pick_pos = utils.pix_to_xyz(pick_pix, hmap,
                                        self.bounds, self.pix_size)
            pick_pose = (np.asarray(pick_pos), np.asarray((0, 0, 0, 1)))

            # Get placing pose.
            targ_pose = targs[nn_targets[pick_i]]
            obj_pose = p.getBasePositionAndOrientation(objs[pick_i][0])
            if not self.sixdof:
                obj_euler = utils.quatXYZW_to_eulerXYZ(obj_pose[1])
                obj_quat = utils.eulerXYZ_to_quatXYZW((0, 0, obj_euler[2]))
                obj_pose = (obj_pose[0], obj_quat)
            world_to_pick = utils.invert(pick_pose)
            obj_to_pick = utils.multiply(world_to_pick, obj_pose)
            pick_to_obj = utils.invert(obj_to_pick)
            place_pose = utils.multiply(targ_pose, pick_to_obj)

            # Rotate end effector?
            if not rotations:
                place_pose = (place_pose[0], (0, 0, 0, 1))

            place_pose = (np.asarray(place_pose[0]), np.asarray(place_pose[1]))

            return {'pose0': pick_pose, 'pose1': place_pose}

        return OracleAgent(act)

    # -------------------------------------------------------------------------
    # Reward Function and Task Completion Metrics
    # -------------------------------------------------------------------------

    def reward(self):
        """Get delta rewards for current timestep.

        Returns:
          A tuple consisting of the scalar (delta) reward, plus `extras`
            dict which has extra task-dependent info from the process of
            computing rewards that gives us finer-grained details. Use
            `extras` for further data analysis.
        """
        reward, info = 0, {}

        # Unpack next goal step.
        objs, matches, targs, _, _, metric, params, max_reward = self.goals[0]

        # Evaluate by matching object poses.
        if metric == 'pose':
            step_reward = 0
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                pose = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                for j in targets_i:
                    target_pose = targs[j]
                    if self.is_match(pose, target_pose, symmetry):
                        step_reward += max_reward / len(objs)
                        print(f"object {i} match with target {j} rew: {step_reward}")
                        break

        # Evaluate by measuring object intersection with zone.
        elif metric == 'zone':
            zone_pts, total_pts = 0, 0
            obj_pts, zones = params
            for zone_idx, (zone_pose, zone_size) in enumerate(zones):

                # Count valid points in zone.
                for obj_idx, obj_id in enumerate(obj_pts):
                    pts = obj_pts[obj_id]
                    obj_pose = p.getBasePositionAndOrientation(obj_id)
                    world_to_zone = utils.invert(zone_pose)
                    obj_to_zone = utils.multiply(world_to_zone, obj_pose)
                    pts = np.float32(utils.apply(obj_to_zone, pts))
                    if len(zone_size) > 1:
                        valid_pts = np.logical_and.reduce([
                            pts[0, :] > -zone_size[0] / 2, pts[0, :] < zone_size[0] / 2,
                            pts[1, :] > -zone_size[1] / 2, pts[1, :] < zone_size[1] / 2,
                            pts[2, :] < self.zone_bounds[2, 1]])

                    # if zone_idx == matches[obj_idx].argmax():
                    zone_pts += np.sum(np.float32(valid_pts))
                    total_pts += pts.shape[1]
            step_reward = max_reward * (zone_pts / total_pts)

        # Get cumulative rewards and return delta.
        reward = self.progress + step_reward - self._rewards
        self._rewards = self.progress + step_reward

        # Move to next goal step if current goal step is complete.
        if np.abs(max_reward - step_reward) < 0.01:
            self.progress += max_reward  # Update task progress.
            self.goals.pop(0)
            if len(self.lang_goals) > 0:
                self.lang_goals.pop(0)

        return reward, info

    def done(self):
        """Check if the task is done or has failed.

        Returns:
          True if the episode should be considered a success, which we
            use for measuring successes, which is particularly helpful for tasks
            where one may get successes on the very last time step, e.g., getting
            the cloth coverage threshold on the last alllowed action.
            However, for bag-items-easy and bag-items-hard (which use the
            'bag-items' metric), it may be necessary to filter out demos that did
            not attain sufficiently high reward in external code. Currently, this
            is done in `main.py` and its ignore_this_demo() method.
        """
        return (len(self.goals) == 0) or (self._rewards > 0.99)
        # return zone_done or defs_done or goal_done

    # -------------------------------------------------------------------------
    # Environment Helper Functions
    # -------------------------------------------------------------------------

    def is_match(self, pose0, pose1, symmetry):
        """Check if pose0 and pose1 match within a threshold."""

        # Get translational error.
        diff_pos = np.float32(pose0[0][:2]) - np.float32(pose1[0][:2])
        dist_pos = np.linalg.norm(diff_pos)

        # Get rotational error around z-axis (account for symmetries).
        diff_rot = 0
        if symmetry > 0:
            rot0 = np.array(utils.quatXYZW_to_eulerXYZ(pose0[1]))[2]
            rot1 = np.array(utils.quatXYZW_to_eulerXYZ(pose1[1]))[2]
            diff_rot = np.abs(rot0 - rot1) % symmetry
            if diff_rot > (symmetry / 2):
                diff_rot = symmetry - diff_rot

        return (dist_pos < self.pos_eps) and (diff_rot < self.rot_eps)

    def get_random_pose(self, env, obj_size):
        """Get random collision-free object pose within workspace bounds."""

        # Get erosion size of object in pixels.
        max_size = np.sqrt(obj_size[0] ** 2 + obj_size[1] ** 2)
        erode_size = int(np.round(max_size / self.pix_size))

        _, hmap, obj_mask = self.get_true_image(env)

        # Randomly sample an object pose within free-space pixels.
        free = np.ones(obj_mask.shape, dtype=np.uint8)
        for obj_ids in env.obj_ids.values():
            for obj_id in obj_ids:
                free[obj_mask == obj_id] = 0
        free[0, :], free[:, 0], free[-1, :], free[:, -1] = 0, 0, 0, 0
        free = cv2.erode(free, np.ones((erode_size, erode_size), np.uint8))

        # if np.sum(free) == 0:
        #     return None, None

        if np.sum(free) == 0:
            # avoid returning None, None
            # return None, None
            pix = (obj_mask.shape[0] // 2, obj_mask.shape[1] // 2)
        else:
            pix = utils.sample_distribution(np.float32(free))
        pos = utils.pix_to_xyz(pix, hmap, self.bounds, self.pix_size)
        pos = (pos[0], pos[1], obj_size[2] / 2)
        theta = np.random.rand() * 2 * np.pi
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta))
        return pos, rot

    def get_lang_goal(self):
        if len(self.lang_goals) == 0:
            return self.task_completed_desc
        else:
            return self.lang_goals[0]

    def get_reward(self):
        return float(self._rewards)

    # -------------------------------------------------------------------------
    # Helper Functions
    # -------------------------------------------------------------------------

    def fill_template(self, template, replace):
        """Read a file and replace key strings."""
        full_template_path = os.path.join(self.assets_root, template)
        with open(full_template_path, 'r') as file:
            fdata = file.read()
        for field in replace:
            for i in range(len(replace[field])):
                fdata = fdata.replace(f'{field}{i}', str(replace[field][i]))
        alphabet = string.ascii_lowercase + string.digits
        rname = ''.join(random.choices(alphabet, k=16))
        tmpdir = tempfile.gettempdir()
        template_filename = os.path.split(template)[-1]
        fname = os.path.join(tmpdir, f'{template_filename}.{rname}')
        with open(fname, 'w') as file:
            file.write(fdata)
        return fname

    def get_random_size(self, min_x, max_x, min_y, max_y, min_z, max_z):
        """Get random box size."""
        size = np.random.rand(3)
        size[0] = size[0] * (max_x - min_x) + min_x
        size[1] = size[1] * (max_y - min_y) + min_y
        size[2] = size[2] * (max_z - min_z) + min_z
        return tuple(size)

    def color_random_brown(self, obj):
        shade = np.random.rand() + 0.5
        color = np.float32([shade * 156, shade * 117, shade * 95, 255]) / 255
        p.changeVisualShape(obj, -1, rgbaColor=color)

  """""
  
  # Environment Class
  def add_object(self, urdf, pose, category='rigid'):
    """List of (fixed, rigid, or deformable) objects in env."""
    fixed_base = 1 if category == 'fixed' else 0
    obj_id = pybullet_utils.load_urdf(
        p,
        os.path.join(self.assets_root, urdf),
        pose[0],
        pose[1],
        useFixedBase=fixed_base)
    self.obj_ids[category].append(obj_id)
    return obj_id
"""

=========
Note that the objects need to obey physics and not collide with each other, and the object goal poses need to be above the table with lower bound x=0.25, y=-0.5 and upper bound x=0.75, y=0.5. When there are multiple objects for a multi-step pick-and-place task, there are often multiple subgoals. Once the task and environment are generated, an agent with a pick and place primitive will follow the defined goal to accomplish the tasks. 

Additionally, make sure you understand and summarize the ``self.goals`` variables, which has a list of 8-tuple with (objs, matches, targ_poses, replace, rotations, metric, params, step_max_reward, symmetries).
- objs (List of obj_id): object ID.
- matches (Binary Matrix): a binary matrix that denotes which object is matched with which target. This matrix has dimension len(objs) x len(targs).
- targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation). 
- replace (Boolean): whether each object can match with one unique target. This is important if we have one target and multiple objects. If it's set to be false, then any object matching with the target will satisfy.
- rotations (Boolean): whether the placement action has a rotation degree of freedom. 
- metric (`pose` or `zone`): `pose` or `zone` that the object needs to be transported to. Example: `pose`. 
- params (List of (zone_target, zone_size)): a list of (zone_target, zone_size) for each zone if the metric is `zone`. 
- step_max_reward (float): the total reward of matching all the objects with all the target poses. It is not dependent on the number of objects but dependent on the number of goals. 
- symmetries: the radians that the object is symmetric around z axis.
- language_goal: the low-level language instructions that denote the goal of this step.
 


>>> Answer: 
I understand the provided APIs and the structure of the `Task` class, which serves as a base class for defining robotic tasks in a simulated environment. Here's a summary of the key components and the `self.goals` variable:

### Key Components of the Task Class:
- **Initialization**: Sets up the end effector, mode, six degrees of freedom (DoF) capability, primitive actions, camera configurations, and workspace bounds.
- **Reset**: Resets the task state and initializes goals and progress.
- **Oracle**: Provides an oracle agent that can act optimally using perfect knowledge of the environment.
- **Reward Function**: Calculates the reward based on the current state and the goals.
- **Task Completion**: Determines if the task is completed or has failed.
- **Environment Helper Functions**: Includes functions to check if poses match, get random collision-free poses, and other utility functions.
- **Helper Functions**: Provides additional utility functions such as filling templates with data and generating random sizes or colors for objects.

### The `self.goals` Variable:
- **objs**: A list of object IDs that are involved in the current goal step.
- **matches**: A binary matrix indicating potential matches between objects and target poses.
- **targ_poses**: A list of target poses, each defined by a translation and rotation tuple.
- **replace**: A boolean indicating whether objects can be matched to targets uniquely or not.
- **rotations**: A boolean indicating whether the placement action includes a rotational component.
- **metric**: A string that specifies the evaluation metric, either 'pose' for precise placement or 'zone' for area-based placement.
- **params**: Additional parameters relevant to the metric, such as zone targets and sizes if the metric is 'zone'.
- **step_max_reward**: The maximum reward available for completing the current goal step.
- **symmetries**: Specifies the rotational symmetry of objects around the z-axis in radians.
- **language_goal**: Descriptive language instructions that define the goal of the current step.

### Environment Class:
- **add_object**: A method to add objects to the environment, specifying their URDF, pose, and category (fixed, rigid, or deformable).

The task "bowl-cylinder-sequence" will require careful consideration of the provided APIs to ensure that the cylinders are placed correctly within the bowl according to the specified pattern. The task will involve generating appropriate goal states, handling object symmetries, and ensuring that the agent can execute the pick-and-place actions to achieve the desired arrangement without collisions.

================= Code Generation!

>>> Prompt: 
Now I will provide you some reference code and you can write the code for the task "bowl-cylinder-sequence".


"""
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class PackingShapes(Task):
    """pick up randomly sized shapes and place them tightly into a container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 1
        self.homogeneous = False

        self.lang_template = "pack the {obj} in the brown box"
        self.task_completed_desc = "done packing shapes."
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        # Shape Names:
        shapes = utils.assembling_kit_shapes

        n_objects = 5
        if self.mode == 'train':
            obj_shapes = np.random.choice(self.train_set, n_objects, replace=False)
        else:
            if self.homogeneous:
                obj_shapes = [np.random.choice(self.test_set, replace=False)] * n_objects
            else:
                obj_shapes = np.random.choice(self.test_set, n_objects, replace=False)

        # Shuffle colors to avoid always picking an object of the same color
        colors, color_names = utils.get_colors(mode=self.mode)

        # Add container box.
        zone_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, zone_pose, 'fixed')

        # Add objects.
        objects = []
        template = 'kitting/object-template.urdf'
        for i in range(n_objects):
            shape = obj_shapes[i]

            # x, y, z dimensions for the asset size
            size = (0.08, 0.08, 0.02)
            pose= self.get_random_pose(env, size)
            fname = f'{shape:02d}.obj'
            fname = os.path.join(self.assets_root, 'kitting', fname)
            scale = [0.003, 0.003, 0.001]  # .0005
            replace = {'FNAME': (fname,),
                       'SCALE': scale,
                       'COLOR': colors[i]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            block_id = env.add_object(urdf, pose)
            objects.append(block_id)

        # Pick the first shape.
        num_objects_to_pick = 1
        for i in range(num_objects_to_pick):
            # IMPORTANT: Specify (obj_pts, [(zone_pose, zone_size)]) for target `zone`. obj_pts is a dict
            language_goal = self.lang_template.format(obj=shapes[obj_shapes[i]])
            self.add_goal(objs=[objects[i]], matches=np.int32([[1]]), targ_poses=[zone_pose], replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1 / num_objects_to_pick,
                language_goal=language_goal)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PlaceRedInGreen(Task):
    """pick up the red blocks and place them into the green bowls amidst other objects."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = "put the red blocks in a green bowl"
        self.task_completed_desc = "done placing blocks in bowls."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_blocks = np.random.randint(1, n_bowls + 1)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, obj_size=bowl_size)
            env.add_object(urdf=bowl_urdf, pose=bowl_pose, category='fixed')
            bowl_poses.append(bowl_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        for _ in range(n_blocks):
            block_pose = self.get_random_pose(env, obj_size=block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Goal: each red block is in a different green bowl.
        self.add_goal(objs=blocks, matches=np.ones((len(blocks), len(bowl_poses))), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

        # Colors of distractor objects.
        bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'green']
        block_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'red']

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = block_colors if is_block else bowl_colors
            pose = self.get_random_pose(env, obj_size=size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1
"""
"""
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils


class SweepingPiles(Task):
    """Push piles of small objects into a target goal zone marked on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = "push the pile of blocks into the green square"
        self.task_completed_desc = "done sweeping."
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add goal zone.
        zone_size = (0.12, 0.12, 0)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add pile of small blocks with `make_piles` function
        obj_ids = self.make_piles(env)

        # Add goal
        self.add_goal(objs=obj_ids, matches=np.ones((50, 1)), targ_poses=[zone_pose], replace=True,
                rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class StackBlockPyramid(Task):
    """Build a pyramid of colored blocks in a color sequence"""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = "make the {row} row with {blocks}"
        self.task_completed_desc = "done stacking block pyramid."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['red']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, blue, purple).
        language_goal = self.lang_template.format(blocks="the green, blue and purple blocks", row="bottom")
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (middle row: yellow, orange).
        language_goal = self.lang_template.format(blocks="the yellow and orange blocks", row="middle")      
        self.add_goal(objs=objs[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (top row: red).
        language_goal = self.lang_template.format(blocks="the red block", row="top")
        self.add_goal(objs=objs[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2]*1, language_goal=language_goal)
"""



Do not use libraries, functions, and assets that you don't know. For each object, try to describe its color, size, category in the task first before you write the code. You do not need extra helper functions. Comment the code liberally to explain what each piece does and why it's written that way. If you have only one goal, `step_max_reward` in `add_goal` should be 1. Use functions `make_piles` and `make_ropes` for creating piles and cables. To use spatula together with the push primitives, import the libraries 
"""
from cliport.tasks import primitives;
from cliport.tasks.grippers import Spatula
"""
and then use `self.primitive = primitives.push` and `self.ee = Spatula`.
Note that the number of language goals usually match the number of motion goals, since they should correspond to each other.

Before generate code, you have a few considerations to focus on:
1. You are strictly prohibited from using function interfaces that do not appear in the above sample code. For example, the module cliport.tasks.primitives does not have pick_plack or place functions, only the push function interface is available.
2. Module 'cliport.tasks.primitives' has no attribute 'pick_place', you mustn't use it.
3. There are two types of your Gripper, one is Spatula and the other is Suction.You need to choose a different end-effector depending on your task requirements. If you need to move an object on the Z axis, then you need to use the Suction type. If you just need to translate an object in a 2D plane, then you can use either Spatula or Suction type.
4. You must determine the type of end-effector you need to use based on the type of task you have. You can choose by adding self.ee=Spatula or self.ee=Suction to the __init__(self) function, the default self.ee is Suction.
5. If you want to use Suction, you must import module using "from cliport.tasks.grippers import Suction". Else if you want to use Spatula, you must import module using "from cliport.tasks.grippers import Spatula".
6. The x-coordinate of the object is in the range [0.25, 0.75], the y-coordinate is in the range [-0.5,0.5] and the z-coordinate is in the range [0, 0.3].
7. The initial position of all objects needs to get its random initial position through the get_random_pose function.
8. The self.max_steps parameter value should be greater than the number of calls to self.add_goal, and preferably equal to twice the number of calls to self.add_goal. For example, if you call self.add_goal twice in one task, then self.max_steps is better set to 4.

If you want to generate the color of the object, you have to obey following rules:
1. You must use the utils.COLORS['COLOR_NAME'] function interface to generate an RGB three-channel value for a color.
2. The available colors for 'COLOR_NAME' are blue, red, green, orange, yellow, purple, pink, cyan, brown, white, gray, indigo, violet, black, silver and gold.
3. If you want to generate a red object, then its RGB three-channel color can be obtained through utils.COLORS['red'].
All object’s colors generation must follow color generation method above.

If you want to generate the target pose of the object(third parameter of function 'self.add_goal' targ_poses), you have to obey following rules:
1. The target pose of an object is represented by the three-dimensional spatial coordinates of the object and its orientation quaternion.
2. The target pose of an object must be represented by [(x,y,z),(q1,q2,q3,q4)]. Where (x,y,z) are the three-dimensional coordinates of the object and (q1,q2,q3,q4) denote the quaternions of the object's target pose.
3. The target pose of an object must be generated by you or use the initial pose of an object as the target pose of the current object.
4. Here's an example, to generate the target pose of a Y object, we have the initial pose information of an X object. So target pose of Y can be represented by pose_y=[(x,y,z),(q1,q2,q3,q4)] or pose_y=initial_pose_x.(Where x,y,z,q1,q2,q3,q4 are specific values.)
5. targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation).
6. The targ_poses you generate must contain translation[x,y,z], but rotation[q0,q1,q2,q3] you may or may not generate.
All object's target pose generation must follow method above.

Now write the code for the task "bowl-cylinder-sequence" in python code block starting with ```python.  Reminder: {'task-name': 'bowl-cylinder-sequence', 'task-description': 'Arrange a sequence of cylinders of varying heights into a large bowl, with the tallest cylinder in the center and progressively shorter cylinders around it, creating a terraced pattern.', 'assets-used': ['bowl/bowl.urdf', 'cylinder/cylinder-template.urdf']} 


>>> Answer: 
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BowlCylinderSequence(Task):
    """Arrange a sequence of cylinders of varying heights into a large bowl."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we have 5 cylinders to place, 2 steps per cylinder
        self.lang_template = "place the {height} cylinder in the center of the bowl"
        self.task_completed_desc = "done arranging the cylinders."
        self.ee = Suction  # Use suction end-effector to pick and place cylinders

    def reset(self, env):
        super().reset(env)

        # Define the bowl properties
        bowl_size = (0.18, 0.18, 0.06)  # Size of the bowl (x, y, z)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_pose = self.get_random_pose(env, bowl_size)
        env.add_object(bowl_urdf, bowl_pose, 'fixed')  # Add the bowl to the environment

        # Define the properties for the cylinders
        n_cylinders = 5  # Number of cylinders to place
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_heights = np.linspace(0.10, 0.02, n_cylinders)  # Heights of cylinders from tallest to shortest
        cylinder_radius = 0.02  # Radius of the cylinders

        # Add cylinders to the environment
        cylinders = []
        for i in range(n_cylinders):
            # Define the size and pose of the cylinder
            size = (2 * cylinder_radius, 2 * cylinder_radius, cylinder_heights[i])
            pose = self.get_random_pose(env, size)
            color = utils.COLORS['silver']  # Color of the cylinder

            # Fill the cylinder URDF template with the correct parameters
            replace = {'SIZE': size, 'COLOR': color}
            urdf = self.fill_template(cylinder_template, replace)

            # Add the cylinder to the environment
            cylinder_id = env.add_object(urdf, pose)
            cylinders.append(cylinder_id)

        # Define the target poses for the cylinders
        # The tallest cylinder goes in the center of the bowl
        center_pose = (bowl_pose[0], bowl_pose[1])  # Use the bowl's pose as the center target pose
        target_poses = [center_pose]

        # Surrounding cylinders are placed around the center, creating a terraced pattern
        # Calculate the positions based on the bowl's size and the cylinders' radii
        offsets = np.linspace(cylinder_radius, bowl_size[0] / 2 - cylinder_radius, n_cylinders - 1)
        for i, offset in enumerate(offsets):
            angle = 2 * np.pi * i / (n_cylinders - 1)
            x_offset = offset * np.cos(angle)
            y_offset = offset * np.sin(angle)
            target_poses.append((utils.apply(bowl_pose, (x_offset, y_offset, 0)), bowl_pose[1]))

        # Add goals for each cylinder
        for i, cylinder_id in enumerate(cylinders):
            # Define the language goal for placing the cylinder
            height_descriptor = "tallest" if i == 0 else "shorter"
            language_goal = self.lang_template.format(height=height_descriptor)

            # Add the goal for the current cylinder
            self.add_goal(objs=[cylinder_id], matches=np.int32([[1]]), targ_poses=[target_poses[i]],
                          replace=False, rotations=True, metric='pose', params=None,
                          step_max_reward=1 / n_cylinders, language_goal=language_goal)

# Instantiate the task
task = BowlCylinderSequence()
```

This code defines a task where a sequence of cylinders of varying heights must be arranged into a large bowl, with the tallest cylinder in the center and progressively shorter cylinders around it. The task uses a suction end-effector to pick and place the cylinders. The cylinders are colored silver and are added to the environment with random initial poses. The target poses for the cylinders are calculated based on the bowl's size and position, creating a terraced pattern. Each cylinder has an associated goal with a language description and a step reward.

================= TRIAL: 6

================= Task and Asset Design!

>>> Prompt: 
You are an AI in robot simulation code and task design. I will provide you some example tasks, code implementation, and some guidelines for how to generate tasks and then you will help me generate a new task. My goal is to design diverse and feasible tasks for tabletop manipulation. I will first ask you to describe the task in natural languages and then will let you write the code for it. 

=========
Here are all the assets. Use only these assets in the task and code design. 
"""
insertion/:
ell.urdf  fixture.urdf

bowl/:
bowl.urdf

box/:
box-template.urdf

stacking/:
block.urdf  stand.urdf

zone/:
zone.obj  zone.urdf

pallet/:
pallet.obj  pallet.urdf

ball/:
ball-template.urdf

cylinder/:
cylinder-template.urdf

bowl/:
bowl.urdf

# assets not for picking
corner/:
corner-template.urdf

line/:
single-green-line-template.urdf

container/:
container-template.urdf
"""
 
=========
Here are some examples of good tasks. Try to learn from these structures but avoid overlapping wiht them.

{"assets-used": ["zone/zone.urdf", "block/small.urdf"],
 "task-description": "Push piles of small objects into a target goal zone marked on the tabletop.",
 "task-name": "sweeping-piles"}

{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "Place all blocks of a specified color in a bowl of specified color.",
 "task-name": "put-block-in-bowl"}
 
{"assets-used": ["insertion/ell.urdf", "insertion/fixture.urdf"],
 "task-description": "pick up the L-shaped red block and place it into the L-shaped fixture.",
 "task-name": "block-insertion"}
 
{"assets-used": ["kitting/kit.urdf", "kitting/object-template.urdf"],
 "task-description": "pick up different objects and arrange them on a board marked with corresponding silhouettes.",
 "task-name": "assembling-kits"}
 
{"assets-used": ["pallet/pallet.urdf", "box/box-template.urdf"],
 "task-description": "pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.",
 "task-name": "palletizing-boxes"}
 
{"assets-used": ["stacking/stand.urdf", "stacking/block.urdf"],
 "task-description": "sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.",
 "task-name": "stack-block-pyramid"}
 
{"assets-used": ["container/container-template.urdf", "box/box-template.urdf"],
 "task-description": "pick up randomly sized boxes and place them tightly into a container.",
 "task-name": "packing-boxes"}
 
{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "pick up the red blocks and place them into the green bowls amidst other objects.",
 "task-name": "place-red-in-green"}
 
{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

=========
Here are some tasks that you have come up with before. Try to learn from these structures but avoid overlapping with these tasks. For instance, `bowl_ball_placement` and `sort_balls_in_bowls` are the same task. `pile_boxes_in_corner` and `stack_blocks_into_pallet` are similar tasks, `align-cylinder-in-corner` and `align-cylinder-corner` are similar.
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- color-coded-pallet-organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color-gradient-tower: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color_coded_pallet_organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color_gradient_tower: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}





=========
Here are some bad example task instances with explanations.
{
    "task_name": "sort-color-blocks",
    "task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "box/box-template.urdf],
}
reasons: not interesting because it overlaps with the current task `put-block-in-bowl`.

{
    "task-name": "guided-ball-maze",
    "task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
    "assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
}
reasons: the language descriptions are too ambiguous. Navigation is also hard to complete. Also maze.urf does not exist.

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
}
reasons: this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere. Similarly tasks like `insert-ball-into-cylinder` and `cylinder-box-insertion` are invalid.

{
    "task-name": "ball-box-obstacle-course",
    "task-description": "Navigate a ball through an obstacle course created by randomly placed boxes and finally place it inside a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: Navigate the ball is not related to tabletop manipulation tasks.

{
    "task-name": "ball-in-box",
    "task-description": "Use a cable to guide a ball into an open box.",
    "assets-used": ["cable/cable.urdf", "ball/ball-template.urdf", "box/box-template.urdf"]
}
reasons: This task is too hard since it involves interaction of the cable and the ball and cannot be easily completed.

{
    "task-name": "ball-in-container",
    "task-description": "Use the spatula to lift a ball over a wall of boxes and drop it into a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: The only action primitives as pick and place. One cannot use a spatula to lift an object.

{
    "task-name": "line-ball-sorting",
    "task-description": "Move balls of different colors along a single green line, placing each ball in a designated colored box at the end of the line. The challenge includes precision in maintaining the ball on the line and the correct identification of the box color corresponding to each ball.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf"]
}
reasons: Piling or stacking balls are physically infeasible in the simulation.



=========
Now please describe the new task in natural languages and explain its novelty and challenges. Format the answer in a python dictionary with keys "task-name" and value type string, "task-description" (one specific sentence) and value type string, and "assets-used" and value type list of strings. Note that

- Do not use assets that are not in the list above. 
- Tasks that have more colors and shapes are interesting.
- Be as specific as possible about the number, shape, and color of each asset in the task descriptions. 
- The task need to obey physics and remain feasible.





>>> Answer: 
Here's a description of a new tabletop manipulation task that meets the criteria provided:

```python
{
    "task-name": "precision-ball-placement",
    "task-description": "Place a series of differently colored balls into matching colored bowls that are arranged in a scattered pattern on the tabletop.",
    "assets-used": ["bowl/bowl.urdf", "ball/ball-template.urdf"]
}
```

This task's novelty lies in the precision required to place the balls into the bowls, which will be scattered randomly on the tabletop, increasing the difficulty of the task due to the variable distances and navigation required. The challenge includes fine manipulation to ensure each ball is carefully placed into the correct bowl without knocking over other bowls or balls. The task also involves color matching and spatial reasoning to determine the shortest path to correctly fill all the bowls. It promotes the development of algorithms that can handle precise movement in a cluttered environment while maintaining the correct association between object colors and their destination.

================= API Preview!

>>> Prompt: 
Before writing the code for the task "precision-ball-placement". Here are some APIs that are defined. Please confirm that you understand these APIs.

"""
class Task():
    """Base Task class."""

    def __init__(self):
        self.ee = Suction
        self.mode = 'train'
        self.sixdof = False
        self.primitive = primitives.PickPlace()
        self.oracle_cams = cameras.Oracle.CONFIG

        # Evaluation epsilons (for pose evaluation metric).
        self.pos_eps = 0.01
        self.rot_eps = np.deg2rad(15)

        # Workspace bounds.
        self.pix_size = 0.003125
        self.bounds = np.array([[0.25, 0.75], [-0.5, 0.5], [0, 0.3]])
        self.zone_bounds = np.copy(self.bounds)

        self.goals = []
        self.lang_goals = []
        self.task_completed_desc = "task completed."
        self.progress = 0
        self._rewards = 0
        self.assets_root = None

    def reset(self, env):
        if not self.assets_root:
            raise ValueError('assets_root must be set for task, '
                             'call set_assets_root().')
        self.goals = []
        self.lang_goals = []
        self.progress = 0  # Task progression metric in range [0, 1].
        self._rewards = 0  # Cumulative returned rewards.

    # -------------------------------------------------------------------------
    # Oracle Agent
    # -------------------------------------------------------------------------

    def oracle(self, env):
        """Oracle agent."""
        OracleAgent = collections.namedtuple('OracleAgent', ['act'])

        def act(obs, info):
            """Calculate action."""

            # Oracle uses perfect RGB-D orthographic images and segmentation masks.
            _, hmap, obj_mask = self.get_true_image(env)

            # Unpack next goal step.
            objs, matches, targs, replace, rotations, _, _, _ = self.goals[0]

            # Match objects to targets without replacement.
            if not replace:

                # Modify a copy of the match matrix.
                matches = matches.copy()

                # Ignore already matched objects.
                for i in range(len(objs)):
                    object_id, (symmetry, _) = objs[i]
                    pose = p.getBasePositionAndOrientation(object_id)
                    targets_i = np.argwhere(matches[i, :]).reshape(-1)
                    for j in targets_i:
                        if self.is_match(pose, targs[j], symmetry):
                            matches[i, :] = 0
                            matches[:, j] = 0

            # Get objects to be picked (prioritize farthest from nearest neighbor).
            nn_dists = []
            nn_targets = []
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                xyz, _ = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                if len(targets_i) > 0:
                    targets_xyz = np.float32([targs[j][0] for j in targets_i])
                    dists = np.linalg.norm(
                        targets_xyz - np.float32(xyz).reshape(1, 3), axis=1)
                    nn = np.argmin(dists)
                    nn_dists.append(dists[nn])
                    nn_targets.append(targets_i[nn])

                # Handle ignored objects.
                else:
                    nn_dists.append(0)
                    nn_targets.append(-1)
            order = np.argsort(nn_dists)[::-1]

            # Filter out matched objects.
            order = [i for i in order if nn_dists[i] > 0]

            pick_mask = None
            for pick_i in order:
                pick_mask = np.uint8(obj_mask == objs[pick_i][0])

                # Erode to avoid picking on edges.
                # pick_mask = cv2.erode(pick_mask, np.ones((3, 3), np.uint8))

                if np.sum(pick_mask) > 0:
                    break

            # Trigger task reset if no object is visible.
            if pick_mask is None or np.sum(pick_mask) == 0:
                self.goals = []
                self.lang_goals = []
                print('Object for pick is not visible. Skipping demonstration.')
                return

            # Get picking pose.
            pick_prob = np.float32(pick_mask)
            pick_pix = utils.sample_distribution(pick_prob)
            # For "deterministic" demonstrations on insertion-easy, use this:
            # pick_pix = (160,80)
            pick_pos = utils.pix_to_xyz(pick_pix, hmap,
                                        self.bounds, self.pix_size)
            pick_pose = (np.asarray(pick_pos), np.asarray((0, 0, 0, 1)))

            # Get placing pose.
            targ_pose = targs[nn_targets[pick_i]]
            obj_pose = p.getBasePositionAndOrientation(objs[pick_i][0])
            if not self.sixdof:
                obj_euler = utils.quatXYZW_to_eulerXYZ(obj_pose[1])
                obj_quat = utils.eulerXYZ_to_quatXYZW((0, 0, obj_euler[2]))
                obj_pose = (obj_pose[0], obj_quat)
            world_to_pick = utils.invert(pick_pose)
            obj_to_pick = utils.multiply(world_to_pick, obj_pose)
            pick_to_obj = utils.invert(obj_to_pick)
            place_pose = utils.multiply(targ_pose, pick_to_obj)

            # Rotate end effector?
            if not rotations:
                place_pose = (place_pose[0], (0, 0, 0, 1))

            place_pose = (np.asarray(place_pose[0]), np.asarray(place_pose[1]))

            return {'pose0': pick_pose, 'pose1': place_pose}

        return OracleAgent(act)

    # -------------------------------------------------------------------------
    # Reward Function and Task Completion Metrics
    # -------------------------------------------------------------------------

    def reward(self):
        """Get delta rewards for current timestep.

        Returns:
          A tuple consisting of the scalar (delta) reward, plus `extras`
            dict which has extra task-dependent info from the process of
            computing rewards that gives us finer-grained details. Use
            `extras` for further data analysis.
        """
        reward, info = 0, {}

        # Unpack next goal step.
        objs, matches, targs, _, _, metric, params, max_reward = self.goals[0]

        # Evaluate by matching object poses.
        if metric == 'pose':
            step_reward = 0
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                pose = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                for j in targets_i:
                    target_pose = targs[j]
                    if self.is_match(pose, target_pose, symmetry):
                        step_reward += max_reward / len(objs)
                        print(f"object {i} match with target {j} rew: {step_reward}")
                        break

        # Evaluate by measuring object intersection with zone.
        elif metric == 'zone':
            zone_pts, total_pts = 0, 0
            obj_pts, zones = params
            for zone_idx, (zone_pose, zone_size) in enumerate(zones):

                # Count valid points in zone.
                for obj_idx, obj_id in enumerate(obj_pts):
                    pts = obj_pts[obj_id]
                    obj_pose = p.getBasePositionAndOrientation(obj_id)
                    world_to_zone = utils.invert(zone_pose)
                    obj_to_zone = utils.multiply(world_to_zone, obj_pose)
                    pts = np.float32(utils.apply(obj_to_zone, pts))
                    if len(zone_size) > 1:
                        valid_pts = np.logical_and.reduce([
                            pts[0, :] > -zone_size[0] / 2, pts[0, :] < zone_size[0] / 2,
                            pts[1, :] > -zone_size[1] / 2, pts[1, :] < zone_size[1] / 2,
                            pts[2, :] < self.zone_bounds[2, 1]])

                    # if zone_idx == matches[obj_idx].argmax():
                    zone_pts += np.sum(np.float32(valid_pts))
                    total_pts += pts.shape[1]
            step_reward = max_reward * (zone_pts / total_pts)

        # Get cumulative rewards and return delta.
        reward = self.progress + step_reward - self._rewards
        self._rewards = self.progress + step_reward

        # Move to next goal step if current goal step is complete.
        if np.abs(max_reward - step_reward) < 0.01:
            self.progress += max_reward  # Update task progress.
            self.goals.pop(0)
            if len(self.lang_goals) > 0:
                self.lang_goals.pop(0)

        return reward, info

    def done(self):
        """Check if the task is done or has failed.

        Returns:
          True if the episode should be considered a success, which we
            use for measuring successes, which is particularly helpful for tasks
            where one may get successes on the very last time step, e.g., getting
            the cloth coverage threshold on the last alllowed action.
            However, for bag-items-easy and bag-items-hard (which use the
            'bag-items' metric), it may be necessary to filter out demos that did
            not attain sufficiently high reward in external code. Currently, this
            is done in `main.py` and its ignore_this_demo() method.
        """
        return (len(self.goals) == 0) or (self._rewards > 0.99)
        # return zone_done or defs_done or goal_done

    # -------------------------------------------------------------------------
    # Environment Helper Functions
    # -------------------------------------------------------------------------

    def is_match(self, pose0, pose1, symmetry):
        """Check if pose0 and pose1 match within a threshold."""

        # Get translational error.
        diff_pos = np.float32(pose0[0][:2]) - np.float32(pose1[0][:2])
        dist_pos = np.linalg.norm(diff_pos)

        # Get rotational error around z-axis (account for symmetries).
        diff_rot = 0
        if symmetry > 0:
            rot0 = np.array(utils.quatXYZW_to_eulerXYZ(pose0[1]))[2]
            rot1 = np.array(utils.quatXYZW_to_eulerXYZ(pose1[1]))[2]
            diff_rot = np.abs(rot0 - rot1) % symmetry
            if diff_rot > (symmetry / 2):
                diff_rot = symmetry - diff_rot

        return (dist_pos < self.pos_eps) and (diff_rot < self.rot_eps)

    def get_random_pose(self, env, obj_size):
        """Get random collision-free object pose within workspace bounds."""

        # Get erosion size of object in pixels.
        max_size = np.sqrt(obj_size[0] ** 2 + obj_size[1] ** 2)
        erode_size = int(np.round(max_size / self.pix_size))

        _, hmap, obj_mask = self.get_true_image(env)

        # Randomly sample an object pose within free-space pixels.
        free = np.ones(obj_mask.shape, dtype=np.uint8)
        for obj_ids in env.obj_ids.values():
            for obj_id in obj_ids:
                free[obj_mask == obj_id] = 0
        free[0, :], free[:, 0], free[-1, :], free[:, -1] = 0, 0, 0, 0
        free = cv2.erode(free, np.ones((erode_size, erode_size), np.uint8))

        # if np.sum(free) == 0:
        #     return None, None

        if np.sum(free) == 0:
            # avoid returning None, None
            # return None, None
            pix = (obj_mask.shape[0] // 2, obj_mask.shape[1] // 2)
        else:
            pix = utils.sample_distribution(np.float32(free))
        pos = utils.pix_to_xyz(pix, hmap, self.bounds, self.pix_size)
        pos = (pos[0], pos[1], obj_size[2] / 2)
        theta = np.random.rand() * 2 * np.pi
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta))
        return pos, rot

    def get_lang_goal(self):
        if len(self.lang_goals) == 0:
            return self.task_completed_desc
        else:
            return self.lang_goals[0]

    def get_reward(self):
        return float(self._rewards)

    # -------------------------------------------------------------------------
    # Helper Functions
    # -------------------------------------------------------------------------

    def fill_template(self, template, replace):
        """Read a file and replace key strings."""
        full_template_path = os.path.join(self.assets_root, template)
        with open(full_template_path, 'r') as file:
            fdata = file.read()
        for field in replace:
            for i in range(len(replace[field])):
                fdata = fdata.replace(f'{field}{i}', str(replace[field][i]))
        alphabet = string.ascii_lowercase + string.digits
        rname = ''.join(random.choices(alphabet, k=16))
        tmpdir = tempfile.gettempdir()
        template_filename = os.path.split(template)[-1]
        fname = os.path.join(tmpdir, f'{template_filename}.{rname}')
        with open(fname, 'w') as file:
            file.write(fdata)
        return fname

    def get_random_size(self, min_x, max_x, min_y, max_y, min_z, max_z):
        """Get random box size."""
        size = np.random.rand(3)
        size[0] = size[0] * (max_x - min_x) + min_x
        size[1] = size[1] * (max_y - min_y) + min_y
        size[2] = size[2] * (max_z - min_z) + min_z
        return tuple(size)

    def color_random_brown(self, obj):
        shade = np.random.rand() + 0.5
        color = np.float32([shade * 156, shade * 117, shade * 95, 255]) / 255
        p.changeVisualShape(obj, -1, rgbaColor=color)

  """""
  
  # Environment Class
  def add_object(self, urdf, pose, category='rigid'):
    """List of (fixed, rigid, or deformable) objects in env."""
    fixed_base = 1 if category == 'fixed' else 0
    obj_id = pybullet_utils.load_urdf(
        p,
        os.path.join(self.assets_root, urdf),
        pose[0],
        pose[1],
        useFixedBase=fixed_base)
    self.obj_ids[category].append(obj_id)
    return obj_id
"""

=========
Note that the objects need to obey physics and not collide with each other, and the object goal poses need to be above the table with lower bound x=0.25, y=-0.5 and upper bound x=0.75, y=0.5. When there are multiple objects for a multi-step pick-and-place task, there are often multiple subgoals. Once the task and environment are generated, an agent with a pick and place primitive will follow the defined goal to accomplish the tasks. 

Additionally, make sure you understand and summarize the ``self.goals`` variables, which has a list of 8-tuple with (objs, matches, targ_poses, replace, rotations, metric, params, step_max_reward, symmetries).
- objs (List of obj_id): object ID.
- matches (Binary Matrix): a binary matrix that denotes which object is matched with which target. This matrix has dimension len(objs) x len(targs).
- targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation). 
- replace (Boolean): whether each object can match with one unique target. This is important if we have one target and multiple objects. If it's set to be false, then any object matching with the target will satisfy.
- rotations (Boolean): whether the placement action has a rotation degree of freedom. 
- metric (`pose` or `zone`): `pose` or `zone` that the object needs to be transported to. Example: `pose`. 
- params (List of (zone_target, zone_size)): a list of (zone_target, zone_size) for each zone if the metric is `zone`. 
- step_max_reward (float): the total reward of matching all the objects with all the target poses. It is not dependent on the number of objects but dependent on the number of goals. 
- symmetries: the radians that the object is symmetric around z axis.
- language_goal: the low-level language instructions that denote the goal of this step.
 


>>> Answer: 
I understand the provided APIs and the structure of the `Task` class, as well as the `add_object` function for the environment class. Here's a summary of my understanding:

The `Task` class is a base class for defining robotic tasks in a simulation environment. It initializes with default parameters for the end effector (suction), mode (training), six degrees of freedom (False), and a pick-and-place primitive. It also sets up camera configurations, evaluation metrics, workspace bounds, and other task-related variables.

The `reset` method is used to reset the task state, including goals and progress.

The `oracle` method provides an oracle agent that can calculate the optimal action based on the current state of the environment. It uses perfect knowledge of the environment to determine the best pick and place actions to achieve the task goals.

The `reward` method calculates the reward for the current timestep based on the task's progress and the current goal step. It uses different metrics such as 'pose' or 'zone' to evaluate the success of the actions taken by the agent.

The `done` method checks if the task is completed or has failed, which is determined by whether all goals have been achieved or if the cumulative rewards exceed a certain threshold.

The `is_match` helper function checks if two poses match within a specified translational and rotational threshold, taking into account object symmetries.

The `get_random_pose` helper function generates a random collision-free pose for an object within the workspace bounds.

The `fill_template` helper function reads a URDF file template and replaces placeholders with specific values to generate a unique object configuration.

The `get_random_size` helper function generates a random size for an object within specified bounds.

The `color_random_brown` helper function assigns a random brown color to an object.

The `add_object` function in the environment class is used to add objects to the simulation. It takes a URDF file path, a pose, and a category (fixed, rigid, or deformable) and returns the object ID.

The `self.goals` variable is a list of 8-tuples that define the subgoals for a multi-step pick-and-place task. Each tuple contains information about the objects involved, the target poses, whether objects can be replaced, whether rotations are considered, the evaluation metric, parameters specific to the metric, the maximum reward for completing the step, and the symmetries of the objects. The `language_goal` provides a textual description of the current subgoal.

With this understanding, I can proceed to write the code for the "precision-ball-placement" task, ensuring that the objects obey physics, do not collide with each other, and that the goal poses are within the specified bounds on the table. The task will involve multiple subgoals, each with its own set of objects, matches, target poses, and other parameters as defined in the `self.goals` variable.

================= Code Generation!

>>> Prompt: 
Now I will provide you some reference code and you can write the code for the task "precision-ball-placement".


"""
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class PackingShapes(Task):
    """pick up randomly sized shapes and place them tightly into a container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 1
        self.homogeneous = False

        self.lang_template = "pack the {obj} in the brown box"
        self.task_completed_desc = "done packing shapes."
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        # Shape Names:
        shapes = utils.assembling_kit_shapes

        n_objects = 5
        if self.mode == 'train':
            obj_shapes = np.random.choice(self.train_set, n_objects, replace=False)
        else:
            if self.homogeneous:
                obj_shapes = [np.random.choice(self.test_set, replace=False)] * n_objects
            else:
                obj_shapes = np.random.choice(self.test_set, n_objects, replace=False)

        # Shuffle colors to avoid always picking an object of the same color
        colors, color_names = utils.get_colors(mode=self.mode)

        # Add container box.
        zone_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, zone_pose, 'fixed')

        # Add objects.
        objects = []
        template = 'kitting/object-template.urdf'
        for i in range(n_objects):
            shape = obj_shapes[i]

            # x, y, z dimensions for the asset size
            size = (0.08, 0.08, 0.02)
            pose= self.get_random_pose(env, size)
            fname = f'{shape:02d}.obj'
            fname = os.path.join(self.assets_root, 'kitting', fname)
            scale = [0.003, 0.003, 0.001]  # .0005
            replace = {'FNAME': (fname,),
                       'SCALE': scale,
                       'COLOR': colors[i]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            block_id = env.add_object(urdf, pose)
            objects.append(block_id)

        # Pick the first shape.
        num_objects_to_pick = 1
        for i in range(num_objects_to_pick):
            # IMPORTANT: Specify (obj_pts, [(zone_pose, zone_size)]) for target `zone`. obj_pts is a dict
            language_goal = self.lang_template.format(obj=shapes[obj_shapes[i]])
            self.add_goal(objs=[objects[i]], matches=np.int32([[1]]), targ_poses=[zone_pose], replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1 / num_objects_to_pick,
                language_goal=language_goal)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PlaceRedInGreen(Task):
    """pick up the red blocks and place them into the green bowls amidst other objects."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = "put the red blocks in a green bowl"
        self.task_completed_desc = "done placing blocks in bowls."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_blocks = np.random.randint(1, n_bowls + 1)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, obj_size=bowl_size)
            env.add_object(urdf=bowl_urdf, pose=bowl_pose, category='fixed')
            bowl_poses.append(bowl_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        for _ in range(n_blocks):
            block_pose = self.get_random_pose(env, obj_size=block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Goal: each red block is in a different green bowl.
        self.add_goal(objs=blocks, matches=np.ones((len(blocks), len(bowl_poses))), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

        # Colors of distractor objects.
        bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'green']
        block_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'red']

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = block_colors if is_block else bowl_colors
            pose = self.get_random_pose(env, obj_size=size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1
"""
"""
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils


class SweepingPiles(Task):
    """Push piles of small objects into a target goal zone marked on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = "push the pile of blocks into the green square"
        self.task_completed_desc = "done sweeping."
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add goal zone.
        zone_size = (0.12, 0.12, 0)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add pile of small blocks with `make_piles` function
        obj_ids = self.make_piles(env)

        # Add goal
        self.add_goal(objs=obj_ids, matches=np.ones((50, 1)), targ_poses=[zone_pose], replace=True,
                rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class StackBlockPyramid(Task):
    """Build a pyramid of colored blocks in a color sequence"""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = "make the {row} row with {blocks}"
        self.task_completed_desc = "done stacking block pyramid."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['red']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, blue, purple).
        language_goal = self.lang_template.format(blocks="the green, blue and purple blocks", row="bottom")
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (middle row: yellow, orange).
        language_goal = self.lang_template.format(blocks="the yellow and orange blocks", row="middle")      
        self.add_goal(objs=objs[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (top row: red).
        language_goal = self.lang_template.format(blocks="the red block", row="top")
        self.add_goal(objs=objs[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2]*1, language_goal=language_goal)
"""



Do not use libraries, functions, and assets that you don't know. For each object, try to describe its color, size, category in the task first before you write the code. You do not need extra helper functions. Comment the code liberally to explain what each piece does and why it's written that way. If you have only one goal, `step_max_reward` in `add_goal` should be 1. Use functions `make_piles` and `make_ropes` for creating piles and cables. To use spatula together with the push primitives, import the libraries 
"""
from cliport.tasks import primitives;
from cliport.tasks.grippers import Spatula
"""
and then use `self.primitive = primitives.push` and `self.ee = Spatula`.
Note that the number of language goals usually match the number of motion goals, since they should correspond to each other.

Before generate code, you have a few considerations to focus on:
1. You are strictly prohibited from using function interfaces that do not appear in the above sample code. For example, the module cliport.tasks.primitives does not have pick_plack or place functions, only the push function interface is available.
2. Module 'cliport.tasks.primitives' has no attribute 'pick_place', you mustn't use it.
3. There are two types of your Gripper, one is Spatula and the other is Suction.You need to choose a different end-effector depending on your task requirements. If you need to move an object on the Z axis, then you need to use the Suction type. If you just need to translate an object in a 2D plane, then you can use either Spatula or Suction type.
4. You must determine the type of end-effector you need to use based on the type of task you have. You can choose by adding self.ee=Spatula or self.ee=Suction to the __init__(self) function, the default self.ee is Suction.
5. If you want to use Suction, you must import module using "from cliport.tasks.grippers import Suction". Else if you want to use Spatula, you must import module using "from cliport.tasks.grippers import Spatula".
6. The x-coordinate of the object is in the range [0.25, 0.75], the y-coordinate is in the range [-0.5,0.5] and the z-coordinate is in the range [0, 0.3].
7. The initial position of all objects needs to get its random initial position through the get_random_pose function.
8. The self.max_steps parameter value should be greater than the number of calls to self.add_goal, and preferably equal to twice the number of calls to self.add_goal. For example, if you call self.add_goal twice in one task, then self.max_steps is better set to 4.

If you want to generate the color of the object, you have to obey following rules:
1. You must use the utils.COLORS['COLOR_NAME'] function interface to generate an RGB three-channel value for a color.
2. The available colors for 'COLOR_NAME' are blue, red, green, orange, yellow, purple, pink, cyan, brown, white, gray, indigo, violet, black, silver and gold.
3. If you want to generate a red object, then its RGB three-channel color can be obtained through utils.COLORS['red'].
All object’s colors generation must follow color generation method above.

If you want to generate the target pose of the object(third parameter of function 'self.add_goal' targ_poses), you have to obey following rules:
1. The target pose of an object is represented by the three-dimensional spatial coordinates of the object and its orientation quaternion.
2. The target pose of an object must be represented by [(x,y,z),(q1,q2,q3,q4)]. Where (x,y,z) are the three-dimensional coordinates of the object and (q1,q2,q3,q4) denote the quaternions of the object's target pose.
3. The target pose of an object must be generated by you or use the initial pose of an object as the target pose of the current object.
4. Here's an example, to generate the target pose of a Y object, we have the initial pose information of an X object. So target pose of Y can be represented by pose_y=[(x,y,z),(q1,q2,q3,q4)] or pose_y=initial_pose_x.(Where x,y,z,q1,q2,q3,q4 are specific values.)
5. targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation).
6. The targ_poses you generate must contain translation[x,y,z], but rotation[q0,q1,q2,q3] you may or may not generate.
All object's target pose generation must follow method above.

Now write the code for the task "precision-ball-placement" in python code block starting with ```python.  Reminder: {'task-name': 'precision-ball-placement', 'task-description': 'Place a series of differently colored balls into matching colored bowls that are arranged in a scattered pattern on the tabletop.', 'assets-used': ['bowl/bowl.urdf', 'ball/ball-template.urdf']} 


>>> Answer: 
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PrecisionBallPlacement(Task):
    """Place a series of differently colored balls into matching colored bowls."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we have 5 balls and bowls, 2 steps per ball
        self.lang_template = "put the {color} ball in the {color} bowl"
        self.task_completed_desc = "done placing all balls in matching bowls."
        self.ee = Suction  # Using suction end-effector to pick up balls
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the number of balls and bowls
        n_balls = 5

        # Define colors for the balls and bowls
        colors = ['red', 'green', 'blue', 'yellow', 'purple']
        color_names = [f"{color} ball" for color in colors]

        # Add bowls to the environment
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for color in colors:
            # Generate a random pose for the bowl
            bowl_pose = self.get_random_pose(env, obj_size=(0.12, 0.12, 0))
            # Add the bowl to the environment with the corresponding color
            bowl_id = env.add_object(bowl_urdf, bowl_pose, color=utils.COLORS[color])
            bowl_poses.append(bowl_pose)

        # Add balls to the environment
        ball_template = 'ball/ball-template.urdf'
        for i, color in enumerate(colors):
            # Generate a random pose for the ball
            ball_pose = self.get_random_pose(env, obj_size=(0.04, 0.04, 0.04))
            # Replace the placeholder in the URDF template with the ball's color
            replace = {'COLOR': utils.COLORS[color]}
            # Generate the URDF for the ball with the specified color
            ball_urdf = self.fill_template(ball_template, replace)
            # Add the ball to the environment
            ball_id = env.add_object(ball_urdf, ball_pose)
            
            # Define the language goal for placing the ball in the matching bowl
            language_goal = self.lang_template.format(color=color)
            # Add the goal for the ball to be placed in the matching colored bowl
            self.add_goal(objs=[ball_id], matches=np.int32([[1]]), targ_poses=[bowl_poses[i]], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/n_balls,
                          language_goal=language_goal)

        # Set the task description
        self.lang_goals = [self.lang_template.format(color=color) for color in colors]
```

This code defines a task where the robot must place differently colored balls into matching colored bowls. The task uses a suction end-effector to pick up the balls. Each ball and bowl is assigned a unique color, and the robot's goal is to match each ball with the bowl of the same color. The `add_goal` function is called for each ball to specify the target pose (the pose of the matching bowl) and the language goal that describes the task. The `step_max_reward` is set to `1/n_balls` to distribute the reward evenly across all ball placements.

================= TRIAL: 7

================= Task and Asset Design!

>>> Prompt: 
You are an AI in robot simulation code and task design. I will provide you some example tasks, code implementation, and some guidelines for how to generate tasks and then you will help me generate a new task. My goal is to design diverse and feasible tasks for tabletop manipulation. I will first ask you to describe the task in natural languages and then will let you write the code for it. 

=========
Here are all the assets. Use only these assets in the task and code design. 
"""
insertion/:
ell.urdf  fixture.urdf

bowl/:
bowl.urdf

box/:
box-template.urdf

stacking/:
block.urdf  stand.urdf

zone/:
zone.obj  zone.urdf

pallet/:
pallet.obj  pallet.urdf

ball/:
ball-template.urdf

cylinder/:
cylinder-template.urdf

bowl/:
bowl.urdf

# assets not for picking
corner/:
corner-template.urdf

line/:
single-green-line-template.urdf

container/:
container-template.urdf
"""
 
=========
Here are some examples of good tasks. Try to learn from these structures but avoid overlapping wiht them.

{"assets-used": ["zone/zone.urdf", "block/small.urdf"],
 "task-description": "Push piles of small objects into a target goal zone marked on the tabletop.",
 "task-name": "sweeping-piles"}

{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "Place all blocks of a specified color in a bowl of specified color.",
 "task-name": "put-block-in-bowl"}
 
{"assets-used": ["insertion/ell.urdf", "insertion/fixture.urdf"],
 "task-description": "pick up the L-shaped red block and place it into the L-shaped fixture.",
 "task-name": "block-insertion"}
 
{"assets-used": ["kitting/kit.urdf", "kitting/object-template.urdf"],
 "task-description": "pick up different objects and arrange them on a board marked with corresponding silhouettes.",
 "task-name": "assembling-kits"}
 
{"assets-used": ["pallet/pallet.urdf", "box/box-template.urdf"],
 "task-description": "pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.",
 "task-name": "palletizing-boxes"}
 
{"assets-used": ["stacking/stand.urdf", "stacking/block.urdf"],
 "task-description": "sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.",
 "task-name": "stack-block-pyramid"}
 
{"assets-used": ["container/container-template.urdf", "box/box-template.urdf"],
 "task-description": "pick up randomly sized boxes and place them tightly into a container.",
 "task-name": "packing-boxes"}
 
{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "pick up the red blocks and place them into the green bowls amidst other objects.",
 "task-name": "place-red-in-green"}
 
{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

=========
Here are some tasks that you have come up with before. Try to learn from these structures but avoid overlapping with these tasks. For instance, `bowl_ball_placement` and `sort_balls_in_bowls` are the same task. `pile_boxes_in_corner` and `stack_blocks_into_pallet` are similar tasks, `align-cylinder-in-corner` and `align-cylinder-corner` are similar.
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- color-coded-pallet-organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color-gradient-tower: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color_coded_pallet_organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color_gradient_tower: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}





=========
Here are some bad example task instances with explanations.
{
    "task_name": "sort-color-blocks",
    "task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "box/box-template.urdf],
}
reasons: not interesting because it overlaps with the current task `put-block-in-bowl`.

{
    "task-name": "guided-ball-maze",
    "task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
    "assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
}
reasons: the language descriptions are too ambiguous. Navigation is also hard to complete. Also maze.urf does not exist.

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
}
reasons: this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere. Similarly tasks like `insert-ball-into-cylinder` and `cylinder-box-insertion` are invalid.

{
    "task-name": "ball-box-obstacle-course",
    "task-description": "Navigate a ball through an obstacle course created by randomly placed boxes and finally place it inside a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: Navigate the ball is not related to tabletop manipulation tasks.

{
    "task-name": "ball-in-box",
    "task-description": "Use a cable to guide a ball into an open box.",
    "assets-used": ["cable/cable.urdf", "ball/ball-template.urdf", "box/box-template.urdf"]
}
reasons: This task is too hard since it involves interaction of the cable and the ball and cannot be easily completed.

{
    "task-name": "ball-in-container",
    "task-description": "Use the spatula to lift a ball over a wall of boxes and drop it into a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: The only action primitives as pick and place. One cannot use a spatula to lift an object.

{
    "task-name": "line-ball-sorting",
    "task-description": "Move balls of different colors along a single green line, placing each ball in a designated colored box at the end of the line. The challenge includes precision in maintaining the ball on the line and the correct identification of the box color corresponding to each ball.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf"]
}
reasons: Piling or stacking balls are physically infeasible in the simulation.



=========
Now please describe the new task in natural languages and explain its novelty and challenges. Format the answer in a python dictionary with keys "task-name" and value type string, "task-description" (one specific sentence) and value type string, and "assets-used" and value type list of strings. Note that

- Do not use assets that are not in the list above. 
- Tasks that have more colors and shapes are interesting.
- Be as specific as possible about the number, shape, and color of each asset in the task descriptions. 
- The task need to obey physics and remain feasible.





>>> Answer: 
Here's a new task concept described in natural language, adhering to the constraints and guidelines provided:

```python
{
    "task-name": "precision-box-placement",
    "task-description": "Pick up a small blue box and place it precisely within the bounds of a marked white zone on a pallet, ensuring the box does not touch the zone's edges.",
    "assets-used": ["box/box-template.urdf", "zone/zone.urdf", "pallet/pallet.urdf"]
}
```

Novelty and Challenges:
- The task introduces precision placement within constraints, which requires careful control of the robot's end-effector.
- Using a combination of the pallet and zone assets encourages spatial reasoning within a defined workspace.
- The specific requirement to avoid touching the zone's edges adds difficulty in terms of motion planning and execution accuracy.
- Color distinction between the blue box and white zone assists with visual identification and alignment tasks.

================= API Preview!

>>> Prompt: 
Before writing the code for the task "precision-box-placement". Here are some APIs that are defined. Please confirm that you understand these APIs.

"""
class Task():
    """Base Task class."""

    def __init__(self):
        self.ee = Suction
        self.mode = 'train'
        self.sixdof = False
        self.primitive = primitives.PickPlace()
        self.oracle_cams = cameras.Oracle.CONFIG

        # Evaluation epsilons (for pose evaluation metric).
        self.pos_eps = 0.01
        self.rot_eps = np.deg2rad(15)

        # Workspace bounds.
        self.pix_size = 0.003125
        self.bounds = np.array([[0.25, 0.75], [-0.5, 0.5], [0, 0.3]])
        self.zone_bounds = np.copy(self.bounds)

        self.goals = []
        self.lang_goals = []
        self.task_completed_desc = "task completed."
        self.progress = 0
        self._rewards = 0
        self.assets_root = None

    def reset(self, env):
        if not self.assets_root:
            raise ValueError('assets_root must be set for task, '
                             'call set_assets_root().')
        self.goals = []
        self.lang_goals = []
        self.progress = 0  # Task progression metric in range [0, 1].
        self._rewards = 0  # Cumulative returned rewards.

    # -------------------------------------------------------------------------
    # Oracle Agent
    # -------------------------------------------------------------------------

    def oracle(self, env):
        """Oracle agent."""
        OracleAgent = collections.namedtuple('OracleAgent', ['act'])

        def act(obs, info):
            """Calculate action."""

            # Oracle uses perfect RGB-D orthographic images and segmentation masks.
            _, hmap, obj_mask = self.get_true_image(env)

            # Unpack next goal step.
            objs, matches, targs, replace, rotations, _, _, _ = self.goals[0]

            # Match objects to targets without replacement.
            if not replace:

                # Modify a copy of the match matrix.
                matches = matches.copy()

                # Ignore already matched objects.
                for i in range(len(objs)):
                    object_id, (symmetry, _) = objs[i]
                    pose = p.getBasePositionAndOrientation(object_id)
                    targets_i = np.argwhere(matches[i, :]).reshape(-1)
                    for j in targets_i:
                        if self.is_match(pose, targs[j], symmetry):
                            matches[i, :] = 0
                            matches[:, j] = 0

            # Get objects to be picked (prioritize farthest from nearest neighbor).
            nn_dists = []
            nn_targets = []
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                xyz, _ = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                if len(targets_i) > 0:
                    targets_xyz = np.float32([targs[j][0] for j in targets_i])
                    dists = np.linalg.norm(
                        targets_xyz - np.float32(xyz).reshape(1, 3), axis=1)
                    nn = np.argmin(dists)
                    nn_dists.append(dists[nn])
                    nn_targets.append(targets_i[nn])

                # Handle ignored objects.
                else:
                    nn_dists.append(0)
                    nn_targets.append(-1)
            order = np.argsort(nn_dists)[::-1]

            # Filter out matched objects.
            order = [i for i in order if nn_dists[i] > 0]

            pick_mask = None
            for pick_i in order:
                pick_mask = np.uint8(obj_mask == objs[pick_i][0])

                # Erode to avoid picking on edges.
                # pick_mask = cv2.erode(pick_mask, np.ones((3, 3), np.uint8))

                if np.sum(pick_mask) > 0:
                    break

            # Trigger task reset if no object is visible.
            if pick_mask is None or np.sum(pick_mask) == 0:
                self.goals = []
                self.lang_goals = []
                print('Object for pick is not visible. Skipping demonstration.')
                return

            # Get picking pose.
            pick_prob = np.float32(pick_mask)
            pick_pix = utils.sample_distribution(pick_prob)
            # For "deterministic" demonstrations on insertion-easy, use this:
            # pick_pix = (160,80)
            pick_pos = utils.pix_to_xyz(pick_pix, hmap,
                                        self.bounds, self.pix_size)
            pick_pose = (np.asarray(pick_pos), np.asarray((0, 0, 0, 1)))

            # Get placing pose.
            targ_pose = targs[nn_targets[pick_i]]
            obj_pose = p.getBasePositionAndOrientation(objs[pick_i][0])
            if not self.sixdof:
                obj_euler = utils.quatXYZW_to_eulerXYZ(obj_pose[1])
                obj_quat = utils.eulerXYZ_to_quatXYZW((0, 0, obj_euler[2]))
                obj_pose = (obj_pose[0], obj_quat)
            world_to_pick = utils.invert(pick_pose)
            obj_to_pick = utils.multiply(world_to_pick, obj_pose)
            pick_to_obj = utils.invert(obj_to_pick)
            place_pose = utils.multiply(targ_pose, pick_to_obj)

            # Rotate end effector?
            if not rotations:
                place_pose = (place_pose[0], (0, 0, 0, 1))

            place_pose = (np.asarray(place_pose[0]), np.asarray(place_pose[1]))

            return {'pose0': pick_pose, 'pose1': place_pose}

        return OracleAgent(act)

    # -------------------------------------------------------------------------
    # Reward Function and Task Completion Metrics
    # -------------------------------------------------------------------------

    def reward(self):
        """Get delta rewards for current timestep.

        Returns:
          A tuple consisting of the scalar (delta) reward, plus `extras`
            dict which has extra task-dependent info from the process of
            computing rewards that gives us finer-grained details. Use
            `extras` for further data analysis.
        """
        reward, info = 0, {}

        # Unpack next goal step.
        objs, matches, targs, _, _, metric, params, max_reward = self.goals[0]

        # Evaluate by matching object poses.
        if metric == 'pose':
            step_reward = 0
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                pose = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                for j in targets_i:
                    target_pose = targs[j]
                    if self.is_match(pose, target_pose, symmetry):
                        step_reward += max_reward / len(objs)
                        print(f"object {i} match with target {j} rew: {step_reward}")
                        break

        # Evaluate by measuring object intersection with zone.
        elif metric == 'zone':
            zone_pts, total_pts = 0, 0
            obj_pts, zones = params
            for zone_idx, (zone_pose, zone_size) in enumerate(zones):

                # Count valid points in zone.
                for obj_idx, obj_id in enumerate(obj_pts):
                    pts = obj_pts[obj_id]
                    obj_pose = p.getBasePositionAndOrientation(obj_id)
                    world_to_zone = utils.invert(zone_pose)
                    obj_to_zone = utils.multiply(world_to_zone, obj_pose)
                    pts = np.float32(utils.apply(obj_to_zone, pts))
                    if len(zone_size) > 1:
                        valid_pts = np.logical_and.reduce([
                            pts[0, :] > -zone_size[0] / 2, pts[0, :] < zone_size[0] / 2,
                            pts[1, :] > -zone_size[1] / 2, pts[1, :] < zone_size[1] / 2,
                            pts[2, :] < self.zone_bounds[2, 1]])

                    # if zone_idx == matches[obj_idx].argmax():
                    zone_pts += np.sum(np.float32(valid_pts))
                    total_pts += pts.shape[1]
            step_reward = max_reward * (zone_pts / total_pts)

        # Get cumulative rewards and return delta.
        reward = self.progress + step_reward - self._rewards
        self._rewards = self.progress + step_reward

        # Move to next goal step if current goal step is complete.
        if np.abs(max_reward - step_reward) < 0.01:
            self.progress += max_reward  # Update task progress.
            self.goals.pop(0)
            if len(self.lang_goals) > 0:
                self.lang_goals.pop(0)

        return reward, info

    def done(self):
        """Check if the task is done or has failed.

        Returns:
          True if the episode should be considered a success, which we
            use for measuring successes, which is particularly helpful for tasks
            where one may get successes on the very last time step, e.g., getting
            the cloth coverage threshold on the last alllowed action.
            However, for bag-items-easy and bag-items-hard (which use the
            'bag-items' metric), it may be necessary to filter out demos that did
            not attain sufficiently high reward in external code. Currently, this
            is done in `main.py` and its ignore_this_demo() method.
        """
        return (len(self.goals) == 0) or (self._rewards > 0.99)
        # return zone_done or defs_done or goal_done

    # -------------------------------------------------------------------------
    # Environment Helper Functions
    # -------------------------------------------------------------------------

    def is_match(self, pose0, pose1, symmetry):
        """Check if pose0 and pose1 match within a threshold."""

        # Get translational error.
        diff_pos = np.float32(pose0[0][:2]) - np.float32(pose1[0][:2])
        dist_pos = np.linalg.norm(diff_pos)

        # Get rotational error around z-axis (account for symmetries).
        diff_rot = 0
        if symmetry > 0:
            rot0 = np.array(utils.quatXYZW_to_eulerXYZ(pose0[1]))[2]
            rot1 = np.array(utils.quatXYZW_to_eulerXYZ(pose1[1]))[2]
            diff_rot = np.abs(rot0 - rot1) % symmetry
            if diff_rot > (symmetry / 2):
                diff_rot = symmetry - diff_rot

        return (dist_pos < self.pos_eps) and (diff_rot < self.rot_eps)

    def get_random_pose(self, env, obj_size):
        """Get random collision-free object pose within workspace bounds."""

        # Get erosion size of object in pixels.
        max_size = np.sqrt(obj_size[0] ** 2 + obj_size[1] ** 2)
        erode_size = int(np.round(max_size / self.pix_size))

        _, hmap, obj_mask = self.get_true_image(env)

        # Randomly sample an object pose within free-space pixels.
        free = np.ones(obj_mask.shape, dtype=np.uint8)
        for obj_ids in env.obj_ids.values():
            for obj_id in obj_ids:
                free[obj_mask == obj_id] = 0
        free[0, :], free[:, 0], free[-1, :], free[:, -1] = 0, 0, 0, 0
        free = cv2.erode(free, np.ones((erode_size, erode_size), np.uint8))

        # if np.sum(free) == 0:
        #     return None, None

        if np.sum(free) == 0:
            # avoid returning None, None
            # return None, None
            pix = (obj_mask.shape[0] // 2, obj_mask.shape[1] // 2)
        else:
            pix = utils.sample_distribution(np.float32(free))
        pos = utils.pix_to_xyz(pix, hmap, self.bounds, self.pix_size)
        pos = (pos[0], pos[1], obj_size[2] / 2)
        theta = np.random.rand() * 2 * np.pi
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta))
        return pos, rot

    def get_lang_goal(self):
        if len(self.lang_goals) == 0:
            return self.task_completed_desc
        else:
            return self.lang_goals[0]

    def get_reward(self):
        return float(self._rewards)

    # -------------------------------------------------------------------------
    # Helper Functions
    # -------------------------------------------------------------------------

    def fill_template(self, template, replace):
        """Read a file and replace key strings."""
        full_template_path = os.path.join(self.assets_root, template)
        with open(full_template_path, 'r') as file:
            fdata = file.read()
        for field in replace:
            for i in range(len(replace[field])):
                fdata = fdata.replace(f'{field}{i}', str(replace[field][i]))
        alphabet = string.ascii_lowercase + string.digits
        rname = ''.join(random.choices(alphabet, k=16))
        tmpdir = tempfile.gettempdir()
        template_filename = os.path.split(template)[-1]
        fname = os.path.join(tmpdir, f'{template_filename}.{rname}')
        with open(fname, 'w') as file:
            file.write(fdata)
        return fname

    def get_random_size(self, min_x, max_x, min_y, max_y, min_z, max_z):
        """Get random box size."""
        size = np.random.rand(3)
        size[0] = size[0] * (max_x - min_x) + min_x
        size[1] = size[1] * (max_y - min_y) + min_y
        size[2] = size[2] * (max_z - min_z) + min_z
        return tuple(size)

    def color_random_brown(self, obj):
        shade = np.random.rand() + 0.5
        color = np.float32([shade * 156, shade * 117, shade * 95, 255]) / 255
        p.changeVisualShape(obj, -1, rgbaColor=color)

  """""
  
  # Environment Class
  def add_object(self, urdf, pose, category='rigid'):
    """List of (fixed, rigid, or deformable) objects in env."""
    fixed_base = 1 if category == 'fixed' else 0
    obj_id = pybullet_utils.load_urdf(
        p,
        os.path.join(self.assets_root, urdf),
        pose[0],
        pose[1],
        useFixedBase=fixed_base)
    self.obj_ids[category].append(obj_id)
    return obj_id
"""

=========
Note that the objects need to obey physics and not collide with each other, and the object goal poses need to be above the table with lower bound x=0.25, y=-0.5 and upper bound x=0.75, y=0.5. When there are multiple objects for a multi-step pick-and-place task, there are often multiple subgoals. Once the task and environment are generated, an agent with a pick and place primitive will follow the defined goal to accomplish the tasks. 

Additionally, make sure you understand and summarize the ``self.goals`` variables, which has a list of 8-tuple with (objs, matches, targ_poses, replace, rotations, metric, params, step_max_reward, symmetries).
- objs (List of obj_id): object ID.
- matches (Binary Matrix): a binary matrix that denotes which object is matched with which target. This matrix has dimension len(objs) x len(targs).
- targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation). 
- replace (Boolean): whether each object can match with one unique target. This is important if we have one target and multiple objects. If it's set to be false, then any object matching with the target will satisfy.
- rotations (Boolean): whether the placement action has a rotation degree of freedom. 
- metric (`pose` or `zone`): `pose` or `zone` that the object needs to be transported to. Example: `pose`. 
- params (List of (zone_target, zone_size)): a list of (zone_target, zone_size) for each zone if the metric is `zone`. 
- step_max_reward (float): the total reward of matching all the objects with all the target poses. It is not dependent on the number of objects but dependent on the number of goals. 
- symmetries: the radians that the object is symmetric around z axis.
- language_goal: the low-level language instructions that denote the goal of this step.
 


>>> Answer: 
I understand the provided APIs and the task requirements. Here's a summary of my understanding:

The `Task` class is a base class for defining a robotic task in a simulation environment. It includes methods for resetting the task, defining an oracle (expert) agent, computing rewards, checking task completion, and various helper functions for interacting with the environment.

Key components of the `Task` class include:

- `reset(self, env)`: Resets the task to an initial state.
- `oracle(self, env)`: Defines an oracle agent that can provide an optimal action sequence for the task.
- `reward(self)`: Computes the reward for the current timestep based on the task's goals and the current state of the environment.
- `done(self)`: Checks whether the task is completed or has failed.
- `is_match(self, pose0, pose1, symmetry)`: Checks if two poses match within a specified threshold, considering object symmetry.
- `get_random_pose(self, env, obj_size)`: Generates a random collision-free pose for an object within the workspace bounds.
- `fill_template(self, template, replace)`: Fills a template file with specified values.
- `get_random_size(self, min_x, max_x, min_y, max_y, min_z, max_z)`: Generates a random size for an object within specified bounds.
- `color_random_brown(self, obj)`: Assigns a random brown color to an object.
- `add_object(self, urdf, pose, category)`: Adds an object to the environment with a specified pose and category.

The `self.goals` variable is a list of 8-tuples that define the subgoals for a pick-and-place task. Each tuple contains the following elements:

- `objs`: A list of object IDs that are involved in the task.
- `matches`: A binary matrix indicating which objects are matched with which targets.
- `targ_poses`: A list of target poses, each defined by a translation and rotation.
- `replace`: A boolean indicating whether objects can match with multiple targets or only one unique target.
- `rotations`: A boolean indicating whether the placement action includes a rotation degree of freedom.
- `metric`: A string that specifies the evaluation metric for the task, either 'pose' or 'zone'.
- `params`: A list of parameters relevant to the metric, such as zone targets and sizes if the metric is 'zone'.
- `step_max_reward`: The maximum reward for completing the current subgoal.
- `symmetries`: The radians of rotational symmetry around the z-axis for the objects.
- `language_goal`: A string providing low-level language instructions for the current subgoal.

The task environment is governed by physics, and objects must not collide with each other. The goal poses for objects must be within specified workspace bounds. The agent in the environment will use a pick-and-place primitive to accomplish the task goals as defined by `self.goals`.

================= Code Generation!

>>> Prompt: 
Now I will provide you some reference code and you can write the code for the task "precision-box-placement".


"""
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class PackingShapes(Task):
    """pick up randomly sized shapes and place them tightly into a container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 1
        self.homogeneous = False

        self.lang_template = "pack the {obj} in the brown box"
        self.task_completed_desc = "done packing shapes."
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        # Shape Names:
        shapes = utils.assembling_kit_shapes

        n_objects = 5
        if self.mode == 'train':
            obj_shapes = np.random.choice(self.train_set, n_objects, replace=False)
        else:
            if self.homogeneous:
                obj_shapes = [np.random.choice(self.test_set, replace=False)] * n_objects
            else:
                obj_shapes = np.random.choice(self.test_set, n_objects, replace=False)

        # Shuffle colors to avoid always picking an object of the same color
        colors, color_names = utils.get_colors(mode=self.mode)

        # Add container box.
        zone_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, zone_pose, 'fixed')

        # Add objects.
        objects = []
        template = 'kitting/object-template.urdf'
        for i in range(n_objects):
            shape = obj_shapes[i]

            # x, y, z dimensions for the asset size
            size = (0.08, 0.08, 0.02)
            pose= self.get_random_pose(env, size)
            fname = f'{shape:02d}.obj'
            fname = os.path.join(self.assets_root, 'kitting', fname)
            scale = [0.003, 0.003, 0.001]  # .0005
            replace = {'FNAME': (fname,),
                       'SCALE': scale,
                       'COLOR': colors[i]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            block_id = env.add_object(urdf, pose)
            objects.append(block_id)

        # Pick the first shape.
        num_objects_to_pick = 1
        for i in range(num_objects_to_pick):
            # IMPORTANT: Specify (obj_pts, [(zone_pose, zone_size)]) for target `zone`. obj_pts is a dict
            language_goal = self.lang_template.format(obj=shapes[obj_shapes[i]])
            self.add_goal(objs=[objects[i]], matches=np.int32([[1]]), targ_poses=[zone_pose], replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1 / num_objects_to_pick,
                language_goal=language_goal)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PlaceRedInGreen(Task):
    """pick up the red blocks and place them into the green bowls amidst other objects."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = "put the red blocks in a green bowl"
        self.task_completed_desc = "done placing blocks in bowls."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_blocks = np.random.randint(1, n_bowls + 1)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, obj_size=bowl_size)
            env.add_object(urdf=bowl_urdf, pose=bowl_pose, category='fixed')
            bowl_poses.append(bowl_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        for _ in range(n_blocks):
            block_pose = self.get_random_pose(env, obj_size=block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Goal: each red block is in a different green bowl.
        self.add_goal(objs=blocks, matches=np.ones((len(blocks), len(bowl_poses))), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

        # Colors of distractor objects.
        bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'green']
        block_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'red']

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = block_colors if is_block else bowl_colors
            pose = self.get_random_pose(env, obj_size=size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1
"""
"""
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils


class SweepingPiles(Task):
    """Push piles of small objects into a target goal zone marked on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = "push the pile of blocks into the green square"
        self.task_completed_desc = "done sweeping."
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add goal zone.
        zone_size = (0.12, 0.12, 0)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add pile of small blocks with `make_piles` function
        obj_ids = self.make_piles(env)

        # Add goal
        self.add_goal(objs=obj_ids, matches=np.ones((50, 1)), targ_poses=[zone_pose], replace=True,
                rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class StackBlockPyramid(Task):
    """Build a pyramid of colored blocks in a color sequence"""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = "make the {row} row with {blocks}"
        self.task_completed_desc = "done stacking block pyramid."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['red']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, blue, purple).
        language_goal = self.lang_template.format(blocks="the green, blue and purple blocks", row="bottom")
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (middle row: yellow, orange).
        language_goal = self.lang_template.format(blocks="the yellow and orange blocks", row="middle")      
        self.add_goal(objs=objs[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (top row: red).
        language_goal = self.lang_template.format(blocks="the red block", row="top")
        self.add_goal(objs=objs[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2]*1, language_goal=language_goal)
"""



Do not use libraries, functions, and assets that you don't know. For each object, try to describe its color, size, category in the task first before you write the code. You do not need extra helper functions. Comment the code liberally to explain what each piece does and why it's written that way. If you have only one goal, `step_max_reward` in `add_goal` should be 1. Use functions `make_piles` and `make_ropes` for creating piles and cables. To use spatula together with the push primitives, import the libraries 
"""
from cliport.tasks import primitives;
from cliport.tasks.grippers import Spatula
"""
and then use `self.primitive = primitives.push` and `self.ee = Spatula`.
Note that the number of language goals usually match the number of motion goals, since they should correspond to each other.

Before generate code, you have a few considerations to focus on:
1. You are strictly prohibited from using function interfaces that do not appear in the above sample code. For example, the module cliport.tasks.primitives does not have pick_plack or place functions, only the push function interface is available.
2. Module 'cliport.tasks.primitives' has no attribute 'pick_place', you mustn't use it.
3. There are two types of your Gripper, one is Spatula and the other is Suction.You need to choose a different end-effector depending on your task requirements. If you need to move an object on the Z axis, then you need to use the Suction type. If you just need to translate an object in a 2D plane, then you can use either Spatula or Suction type.
4. You must determine the type of end-effector you need to use based on the type of task you have. You can choose by adding self.ee=Spatula or self.ee=Suction to the __init__(self) function, the default self.ee is Suction.
5. If you want to use Suction, you must import module using "from cliport.tasks.grippers import Suction". Else if you want to use Spatula, you must import module using "from cliport.tasks.grippers import Spatula".
6. The x-coordinate of the object is in the range [0.25, 0.75], the y-coordinate is in the range [-0.5,0.5] and the z-coordinate is in the range [0, 0.3].
7. The initial position of all objects needs to get its random initial position through the get_random_pose function.
8. The self.max_steps parameter value should be greater than the number of calls to self.add_goal, and preferably equal to twice the number of calls to self.add_goal. For example, if you call self.add_goal twice in one task, then self.max_steps is better set to 4.

If you want to generate the color of the object, you have to obey following rules:
1. You must use the utils.COLORS['COLOR_NAME'] function interface to generate an RGB three-channel value for a color.
2. The available colors for 'COLOR_NAME' are blue, red, green, orange, yellow, purple, pink, cyan, brown, white, gray, indigo, violet, black, silver and gold.
3. If you want to generate a red object, then its RGB three-channel color can be obtained through utils.COLORS['red'].
All object’s colors generation must follow color generation method above.

If you want to generate the target pose of the object(third parameter of function 'self.add_goal' targ_poses), you have to obey following rules:
1. The target pose of an object is represented by the three-dimensional spatial coordinates of the object and its orientation quaternion.
2. The target pose of an object must be represented by [(x,y,z),(q1,q2,q3,q4)]. Where (x,y,z) are the three-dimensional coordinates of the object and (q1,q2,q3,q4) denote the quaternions of the object's target pose.
3. The target pose of an object must be generated by you or use the initial pose of an object as the target pose of the current object.
4. Here's an example, to generate the target pose of a Y object, we have the initial pose information of an X object. So target pose of Y can be represented by pose_y=[(x,y,z),(q1,q2,q3,q4)] or pose_y=initial_pose_x.(Where x,y,z,q1,q2,q3,q4 are specific values.)
5. targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation).
6. The targ_poses you generate must contain translation[x,y,z], but rotation[q0,q1,q2,q3] you may or may not generate.
All object's target pose generation must follow method above.

Now write the code for the task "precision-box-placement" in python code block starting with ```python.  Reminder: {'task-name': 'precision-box-placement', 'task-description': "Pick up a small blue box and place it precisely within the bounds of a marked white zone on a pallet, ensuring the box does not touch the zone's edges.", 'assets-used': ['box/box-template.urdf', 'zone/zone.urdf', 'pallet/pallet.urdf']} 


>>> Answer: 
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PrecisionBoxPlacement(Task):
    """Pick up a small blue box and place it precisely within the bounds of a marked white zone on a pallet, ensuring the box does not touch the zone's edges."""

    def __init__(self):
        super().__init__()
        self.max_steps = 2  # One step to pick and one step to place
        self.lang_template = "place the blue box in the center of the white zone without touching the edges"
        self.task_completed_desc = "done placing the blue box."
        self.ee = Suction  # Using Suction end-effector to pick up the box

    def reset(self, env):
        super().reset(env)

        # Define the size of the blue box
        box_size = (0.05, 0.05, 0.05)  # Small box size

        # Define the size and pose of the white zone
        zone_size = (0.15, 0.15, 0)  # Larger than the box to fit within bounds
        zone_pose = self.get_random_pose(env, zone_size)  # Random pose within workspace bounds

        # Define the size and pose of the pallet
        pallet_size = (0.3, 0.3, 0.02)  # Size of the pallet
        pallet_pose = self.get_random_pose(env, pallet_size)  # Random pose within workspace bounds

        # Add the pallet to the environment
        env.add_object('pallet/pallet.urdf', pallet_pose, 'fixed')

        # Add the white zone to the environment
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Generate the blue color for the box
        blue_color = utils.COLORS['blue']

        # Add the blue box to the environment
        box_template = 'box/box-template.urdf'
        box_pose = self.get_random_pose(env, box_size)  # Random pose within workspace bounds
        replace = {'SIZE': box_size, 'COLOR': blue_color}
        box_urdf = self.fill_template(box_template, replace)
        box_id = env.add_object(box_urdf, box_pose)

        # Define the language goal
        language_goal = self.lang_template

        # Add the goal for the task
        # The target pose is the same as the zone pose but with a z-offset to place the box above the zone
        target_pose = (zone_pose[0], zone_pose[1])
        self.add_goal(objs=[box_id], matches=np.ones((1, 1)), targ_poses=[target_pose], replace=False,
                      rotations=False, metric='pose', params=None, step_max_reward=1, language_goal=language_goal)

# Instantiate the task
task = PrecisionBoxPlacement()
```

This code defines the task "precision-box-placement" where a small blue box must be picked up and placed precisely within the bounds of a marked white zone on a pallet. The task uses a Suction end-effector to pick up the box, and the placement must be done without touching the edges of the zone. The `reset` method adds the pallet, zone, and box to the environment with random poses within the workspace bounds. The goal is added with a target pose that matches the zone pose but with a z-offset to ensure the box is placed above the zone. The `max_steps` is set to 2, which allows one step for picking and one step for placing. The language goal provides a description of the task to be completed.

================= TRIAL: 8

================= Code Reflect!

>>> Prompt: 


Do you think your task is sufficently interesting to be added as a new task for future task given that we already have the following task name and descriptions? Moreover, does the simulation code achieve the goal and the language descriptions in the task? Be as rigorous and high-standard as possible.

Reminder:
your task:
{'task-name': 'precision-box-placement', 'task-description': "Pick up a small blue box and place it precisely within the bounds of a marked white zone on a pallet, ensuring the box does not touch the zone's edges.", 'assets-used': ['box/box-template.urdf', 'zone/zone.urdf', 'pallet/pallet.urdf']}

import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PrecisionBoxPlacement(Task):
    """Pick up a small blue box and place it precisely within the bounds of a marked white zone on a pallet, ensuring the box does not touch the zone's edges."""

    def __init__(self):
        super().__init__()
        self.max_steps = 2  # One step to pick and one step to place
        self.lang_template = "place the blue box in the center of the white zone without touching the edges"
        self.task_completed_desc = "done placing the blue box."
        self.ee = Suction  # Using Suction end-effector to pick up the box

    def reset(self, env):
        super().reset(env)

        # Define the size of the blue box
        box_size = (0.05, 0.05, 0.05)  # Small box size

        # Define the size and pose of the white zone
        zone_size = (0.15, 0.15, 0)  # Larger than the box to fit within bounds
        zone_pose = self.get_random_pose(env, zone_size)  # Random pose within workspace bounds

        # Define the size and pose of the pallet
        pallet_size = (0.3, 0.3, 0.02)  # Size of the pallet
        pallet_pose = self.get_random_pose(env, pallet_size)  # Random pose within workspace bounds

        # Add the pallet to the environment
        env.add_object('pallet/pallet.urdf', pallet_pose, 'fixed')

        # Add the white zone to the environment
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Generate the blue color for the box
        blue_color = utils.COLORS['blue']

        # Add the blue box to the environment
        box_template = 'box/box-template.urdf'
        box_pose = self.get_random_pose(env, box_size)  # Random pose within workspace bounds
        replace = {'SIZE': box_size, 'COLOR': blue_color}
        box_urdf = self.fill_template(box_template, replace)
        box_id = env.add_object(box_urdf, box_pose)

        # Define the language goal
        language_goal = self.lang_template

        # Add the goal for the task
        # The target pose is the same as the zone pose but with a z-offset to place the box above the zone
        target_pose = (zone_pose[0], zone_pose[1])
        self.add_goal(objs=[box_id], matches=np.ones((1, 1)), targ_poses=[target_pose], replace=False,
                      rotations=False, metric='pose', params=None, step_max_reward=1, language_goal=language_goal)

# Instantiate the task
task = PrecisionBoxPlacement()

current task list:
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- stack-block-pyramid: {'assets-used': ['stacking/stand.urdf', 'stacking/block.urdf'], 'task-description': 'sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.', 'task-name': 'stack-block-pyramid'}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- cylinder_hurdle_arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- color_coded_pallet_organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color-coded-pallet-organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- cylinder_tower_balancing: {'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}
- cylinder-tower-balancing: {'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}
- color_gradient_tower: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color-gradient-tower: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}




=========
Reply explain your reasons and then say True or False, formatted in a python dictionary, do not miss commas or add extra spaces. Here are some examples.

{
	"task_name": "sort-color-blocks",
	"task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "yellow-bowl.urdf", "box/box-template.urdf],
	"reasons": "not interesting because it overlaps with the current task `put-block-in-bowl`"
	"add_to_the_task_list": "False",
}

{
  	"task-name": "guided-ball-maze",
  	"task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
  	"assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
   	"reasons": "the language descriptions are too ambiguous. Navigation is also hard to complete."
  	"add_to_the_task_list": "False",  
}

{
 	"task-name": "sort-blocks-by-zone",
 	"task-description": "Sort different colored blocks into their corresponding colored zones marked on the tabletop.",
 	"assets-used": ["zone/zone.urdf", "stacking/block.urdf"],
	"reasons": "the task is not covered in the current list and is an interesting combination of zone and block objects." 
	"add_to_the_task_list": "True",
}

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
    "reasons": "this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "arrange-blocks-on-pallet",
    "task-description": "arrange the blocks on the pallet in the order: red, orange, yellow, green, blue, and purple.",
    "assets-used": ["stacking/block.urdf", "pallet/pallelt.urdf"],
    "reasons": "this task overlaps with `arrange-boxes-on-pallet` by merely changing the blocks to boxes.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "cylinder-color-alignment",
    "task-description": "Pick up cylinders of different colors and align them inside a box in the order of the colors displayed on the single green line on the tabletop.",
    "assets-used": ["cylinder/cylinder-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf   
    "reasons": "the execution code only has one goal, i.e. it will only move one cylinder on top of the box, which is not that interesting.", 
    "add_to_the_task_list": "False","]
}

{
    "task-name": "build-bridge",
    "task-description": "Construct a bridge using two yellow blocks and three blue blocks. Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between. Then, place the blue block horizontally on top of the yellow blocks.",
     "assets-used": ["block/block.urdf", "ball/ball-template.urdf"]
    "reasons": "this task is an interesting and long-horizon task for pick and place primitives. Training manipulation agent with this skill will be a useful building block for next skills.", 
    "add_to_the_task_list": "True",
}

=========

Please incorporate these feedbacks when you design new task!



>>> Answer: 
{
    "task-name": "precision-box-placement",
    "task-description": "Pick up a small blue box and place it precisely within the bounds of a marked white zone on a pallet, ensuring the box does not touch the zone's edges.",
    "assets-used": ["box/box-template.urdf", "zone/zone.urdf", "pallet/pallet.urdf"],
    "reasons": "The task is sufficiently distinct from the other tasks listed, as it focuses on precision placement within a confined space without touching boundaries, which is a new challenge not covered by the existing tasks. The simulation code appears to correctly instantiate the task environment, place the objects, and define the language descriptions and goals. However, it lacks a z-offset in the target_pose which is crucial for placing the box above the zone, and the code does not include any logic for checking if the box touches the edges of the zone, which is a key part of the task description.",
    "add_to_the_task_list": "False",
}

================= Task and Asset Design!

>>> Prompt: 
You are an AI in robot simulation code and task design. I will provide you some example tasks, code implementation, and some guidelines for how to generate tasks and then you will help me generate a new task. My goal is to design diverse and feasible tasks for tabletop manipulation. I will first ask you to describe the task in natural languages and then will let you write the code for it. 

=========
Here are all the assets. Use only these assets in the task and code design. 
"""
insertion/:
ell.urdf  fixture.urdf

bowl/:
bowl.urdf

box/:
box-template.urdf

stacking/:
block.urdf  stand.urdf

zone/:
zone.obj  zone.urdf

pallet/:
pallet.obj  pallet.urdf

ball/:
ball-template.urdf

cylinder/:
cylinder-template.urdf

bowl/:
bowl.urdf

# assets not for picking
corner/:
corner-template.urdf

line/:
single-green-line-template.urdf

container/:
container-template.urdf
"""
 
=========
Here are some examples of good tasks. Try to learn from these structures but avoid overlapping wiht them.

{"assets-used": ["zone/zone.urdf", "block/small.urdf"],
 "task-description": "Push piles of small objects into a target goal zone marked on the tabletop.",
 "task-name": "sweeping-piles"}

{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "Place all blocks of a specified color in a bowl of specified color.",
 "task-name": "put-block-in-bowl"}
 
{"assets-used": ["insertion/ell.urdf", "insertion/fixture.urdf"],
 "task-description": "pick up the L-shaped red block and place it into the L-shaped fixture.",
 "task-name": "block-insertion"}
 
{"assets-used": ["kitting/kit.urdf", "kitting/object-template.urdf"],
 "task-description": "pick up different objects and arrange them on a board marked with corresponding silhouettes.",
 "task-name": "assembling-kits"}
 
{"assets-used": ["pallet/pallet.urdf", "box/box-template.urdf"],
 "task-description": "pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.",
 "task-name": "palletizing-boxes"}
 
{"assets-used": ["stacking/stand.urdf", "stacking/block.urdf"],
 "task-description": "sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.",
 "task-name": "stack-block-pyramid"}
 
{"assets-used": ["container/container-template.urdf", "box/box-template.urdf"],
 "task-description": "pick up randomly sized boxes and place them tightly into a container.",
 "task-name": "packing-boxes"}
 
{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "pick up the red blocks and place them into the green bowls amidst other objects.",
 "task-name": "place-red-in-green"}
 
{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

=========
Here are some tasks that you have come up with before. Try to learn from these structures but avoid overlapping with these tasks. For instance, `bowl_ball_placement` and `sort_balls_in_bowls` are the same task. `pile_boxes_in_corner` and `stack_blocks_into_pallet` are similar tasks, `align-cylinder-in-corner` and `align-cylinder-corner` are similar.
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- color_gradient_tower: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}
- color-gradient-tower: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- precision_box_placement: {'task-name': 'precision-box-placement', 'task-description': "Pick up a small blue box and place it precisely within the bounds of a marked white zone on a pallet, ensuring the box does not touch the zone's edges.", 'assets-used': ['box/box-template.urdf', 'zone/zone.urdf', 'pallet/pallet.urdf']}
- color_coded_pallet_organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}





=========
Here are some bad example task instances with explanations.
{
    "task_name": "sort-color-blocks",
    "task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "box/box-template.urdf],
}
reasons: not interesting because it overlaps with the current task `put-block-in-bowl`.

{
    "task-name": "guided-ball-maze",
    "task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
    "assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
}
reasons: the language descriptions are too ambiguous. Navigation is also hard to complete. Also maze.urf does not exist.

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
}
reasons: this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere. Similarly tasks like `insert-ball-into-cylinder` and `cylinder-box-insertion` are invalid.

{
    "task-name": "ball-box-obstacle-course",
    "task-description": "Navigate a ball through an obstacle course created by randomly placed boxes and finally place it inside a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: Navigate the ball is not related to tabletop manipulation tasks.

{
    "task-name": "ball-in-box",
    "task-description": "Use a cable to guide a ball into an open box.",
    "assets-used": ["cable/cable.urdf", "ball/ball-template.urdf", "box/box-template.urdf"]
}
reasons: This task is too hard since it involves interaction of the cable and the ball and cannot be easily completed.

{
    "task-name": "ball-in-container",
    "task-description": "Use the spatula to lift a ball over a wall of boxes and drop it into a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: The only action primitives as pick and place. One cannot use a spatula to lift an object.

{
    "task-name": "line-ball-sorting",
    "task-description": "Move balls of different colors along a single green line, placing each ball in a designated colored box at the end of the line. The challenge includes precision in maintaining the ball on the line and the correct identification of the box color corresponding to each ball.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf"]
}
reasons: Piling or stacking balls are physically infeasible in the simulation.



=========
Now please describe the new task in natural languages and explain its novelty and challenges. Format the answer in a python dictionary with keys "task-name" and value type string, "task-description" (one specific sentence) and value type string, and "assets-used" and value type list of strings. Note that

- Do not use assets that are not in the list above. 
- Tasks that have more colors and shapes are interesting.
- Be as specific as possible about the number, shape, and color of each asset in the task descriptions. 
- The task need to obey physics and remain feasible.





>>> Answer: 
Here's a new task described in natural language, taking into account the provided guidelines and constraints:

```python
{
    "task-name": "gradient-tower-placement",
    "task-description": "Build two separate towers each made of three differently colored cylinders, placing them on a patterned zone marked with two distinct areas, one for each tower, while ensuring that the cylinders in each tower are arranged in a color gradient sequence from the lightest on top to the darkest at the base.",
    "assets-used": ["cylinder/cylinder-template.urdf", "zone/zone.urdf"]
}
```

Explanations of novelty and challenges:

- **Novelty**: This task requires the robot to recognize and sort cylinders based on their colors and to distinguish between different sections within a single patterned zone for correct placement, adding complexity in object recognition and spatial reasoning.
- **Challenges**: 
  - The task involves precision in placing the cylinders within specific areas of the patterned zone.
  - The robot needs to handle the delicate balance of the cylinders as they are stacked in a tower formation.
  - Sorting the cylinders to create a gradient effect from light to dark adds an extra layer of cognitive complexity.
  - The dual-tower aspect necessitates careful planning and sequencing of robot actions to ensure that both towers are constructed correctly and positioned without interfering with each other.

================= API Preview!

>>> Prompt: 
Before writing the code for the task "gradient-tower-placement". Here are some APIs that are defined. Please confirm that you understand these APIs.

"""
class Task():
    """Base Task class."""

    def __init__(self):
        self.ee = Suction
        self.mode = 'train'
        self.sixdof = False
        self.primitive = primitives.PickPlace()
        self.oracle_cams = cameras.Oracle.CONFIG

        # Evaluation epsilons (for pose evaluation metric).
        self.pos_eps = 0.01
        self.rot_eps = np.deg2rad(15)

        # Workspace bounds.
        self.pix_size = 0.003125
        self.bounds = np.array([[0.25, 0.75], [-0.5, 0.5], [0, 0.3]])
        self.zone_bounds = np.copy(self.bounds)

        self.goals = []
        self.lang_goals = []
        self.task_completed_desc = "task completed."
        self.progress = 0
        self._rewards = 0
        self.assets_root = None

    def reset(self, env):
        if not self.assets_root:
            raise ValueError('assets_root must be set for task, '
                             'call set_assets_root().')
        self.goals = []
        self.lang_goals = []
        self.progress = 0  # Task progression metric in range [0, 1].
        self._rewards = 0  # Cumulative returned rewards.

    # -------------------------------------------------------------------------
    # Oracle Agent
    # -------------------------------------------------------------------------

    def oracle(self, env):
        """Oracle agent."""
        OracleAgent = collections.namedtuple('OracleAgent', ['act'])

        def act(obs, info):
            """Calculate action."""

            # Oracle uses perfect RGB-D orthographic images and segmentation masks.
            _, hmap, obj_mask = self.get_true_image(env)

            # Unpack next goal step.
            objs, matches, targs, replace, rotations, _, _, _ = self.goals[0]

            # Match objects to targets without replacement.
            if not replace:

                # Modify a copy of the match matrix.
                matches = matches.copy()

                # Ignore already matched objects.
                for i in range(len(objs)):
                    object_id, (symmetry, _) = objs[i]
                    pose = p.getBasePositionAndOrientation(object_id)
                    targets_i = np.argwhere(matches[i, :]).reshape(-1)
                    for j in targets_i:
                        if self.is_match(pose, targs[j], symmetry):
                            matches[i, :] = 0
                            matches[:, j] = 0

            # Get objects to be picked (prioritize farthest from nearest neighbor).
            nn_dists = []
            nn_targets = []
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                xyz, _ = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                if len(targets_i) > 0:
                    targets_xyz = np.float32([targs[j][0] for j in targets_i])
                    dists = np.linalg.norm(
                        targets_xyz - np.float32(xyz).reshape(1, 3), axis=1)
                    nn = np.argmin(dists)
                    nn_dists.append(dists[nn])
                    nn_targets.append(targets_i[nn])

                # Handle ignored objects.
                else:
                    nn_dists.append(0)
                    nn_targets.append(-1)
            order = np.argsort(nn_dists)[::-1]

            # Filter out matched objects.
            order = [i for i in order if nn_dists[i] > 0]

            pick_mask = None
            for pick_i in order:
                pick_mask = np.uint8(obj_mask == objs[pick_i][0])

                # Erode to avoid picking on edges.
                # pick_mask = cv2.erode(pick_mask, np.ones((3, 3), np.uint8))

                if np.sum(pick_mask) > 0:
                    break

            # Trigger task reset if no object is visible.
            if pick_mask is None or np.sum(pick_mask) == 0:
                self.goals = []
                self.lang_goals = []
                print('Object for pick is not visible. Skipping demonstration.')
                return

            # Get picking pose.
            pick_prob = np.float32(pick_mask)
            pick_pix = utils.sample_distribution(pick_prob)
            # For "deterministic" demonstrations on insertion-easy, use this:
            # pick_pix = (160,80)
            pick_pos = utils.pix_to_xyz(pick_pix, hmap,
                                        self.bounds, self.pix_size)
            pick_pose = (np.asarray(pick_pos), np.asarray((0, 0, 0, 1)))

            # Get placing pose.
            targ_pose = targs[nn_targets[pick_i]]
            obj_pose = p.getBasePositionAndOrientation(objs[pick_i][0])
            if not self.sixdof:
                obj_euler = utils.quatXYZW_to_eulerXYZ(obj_pose[1])
                obj_quat = utils.eulerXYZ_to_quatXYZW((0, 0, obj_euler[2]))
                obj_pose = (obj_pose[0], obj_quat)
            world_to_pick = utils.invert(pick_pose)
            obj_to_pick = utils.multiply(world_to_pick, obj_pose)
            pick_to_obj = utils.invert(obj_to_pick)
            place_pose = utils.multiply(targ_pose, pick_to_obj)

            # Rotate end effector?
            if not rotations:
                place_pose = (place_pose[0], (0, 0, 0, 1))

            place_pose = (np.asarray(place_pose[0]), np.asarray(place_pose[1]))

            return {'pose0': pick_pose, 'pose1': place_pose}

        return OracleAgent(act)

    # -------------------------------------------------------------------------
    # Reward Function and Task Completion Metrics
    # -------------------------------------------------------------------------

    def reward(self):
        """Get delta rewards for current timestep.

        Returns:
          A tuple consisting of the scalar (delta) reward, plus `extras`
            dict which has extra task-dependent info from the process of
            computing rewards that gives us finer-grained details. Use
            `extras` for further data analysis.
        """
        reward, info = 0, {}

        # Unpack next goal step.
        objs, matches, targs, _, _, metric, params, max_reward = self.goals[0]

        # Evaluate by matching object poses.
        if metric == 'pose':
            step_reward = 0
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                pose = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                for j in targets_i:
                    target_pose = targs[j]
                    if self.is_match(pose, target_pose, symmetry):
                        step_reward += max_reward / len(objs)
                        print(f"object {i} match with target {j} rew: {step_reward}")
                        break

        # Evaluate by measuring object intersection with zone.
        elif metric == 'zone':
            zone_pts, total_pts = 0, 0
            obj_pts, zones = params
            for zone_idx, (zone_pose, zone_size) in enumerate(zones):

                # Count valid points in zone.
                for obj_idx, obj_id in enumerate(obj_pts):
                    pts = obj_pts[obj_id]
                    obj_pose = p.getBasePositionAndOrientation(obj_id)
                    world_to_zone = utils.invert(zone_pose)
                    obj_to_zone = utils.multiply(world_to_zone, obj_pose)
                    pts = np.float32(utils.apply(obj_to_zone, pts))
                    if len(zone_size) > 1:
                        valid_pts = np.logical_and.reduce([
                            pts[0, :] > -zone_size[0] / 2, pts[0, :] < zone_size[0] / 2,
                            pts[1, :] > -zone_size[1] / 2, pts[1, :] < zone_size[1] / 2,
                            pts[2, :] < self.zone_bounds[2, 1]])

                    # if zone_idx == matches[obj_idx].argmax():
                    zone_pts += np.sum(np.float32(valid_pts))
                    total_pts += pts.shape[1]
            step_reward = max_reward * (zone_pts / total_pts)

        # Get cumulative rewards and return delta.
        reward = self.progress + step_reward - self._rewards
        self._rewards = self.progress + step_reward

        # Move to next goal step if current goal step is complete.
        if np.abs(max_reward - step_reward) < 0.01:
            self.progress += max_reward  # Update task progress.
            self.goals.pop(0)
            if len(self.lang_goals) > 0:
                self.lang_goals.pop(0)

        return reward, info

    def done(self):
        """Check if the task is done or has failed.

        Returns:
          True if the episode should be considered a success, which we
            use for measuring successes, which is particularly helpful for tasks
            where one may get successes on the very last time step, e.g., getting
            the cloth coverage threshold on the last alllowed action.
            However, for bag-items-easy and bag-items-hard (which use the
            'bag-items' metric), it may be necessary to filter out demos that did
            not attain sufficiently high reward in external code. Currently, this
            is done in `main.py` and its ignore_this_demo() method.
        """
        return (len(self.goals) == 0) or (self._rewards > 0.99)
        # return zone_done or defs_done or goal_done

    # -------------------------------------------------------------------------
    # Environment Helper Functions
    # -------------------------------------------------------------------------

    def is_match(self, pose0, pose1, symmetry):
        """Check if pose0 and pose1 match within a threshold."""

        # Get translational error.
        diff_pos = np.float32(pose0[0][:2]) - np.float32(pose1[0][:2])
        dist_pos = np.linalg.norm(diff_pos)

        # Get rotational error around z-axis (account for symmetries).
        diff_rot = 0
        if symmetry > 0:
            rot0 = np.array(utils.quatXYZW_to_eulerXYZ(pose0[1]))[2]
            rot1 = np.array(utils.quatXYZW_to_eulerXYZ(pose1[1]))[2]
            diff_rot = np.abs(rot0 - rot1) % symmetry
            if diff_rot > (symmetry / 2):
                diff_rot = symmetry - diff_rot

        return (dist_pos < self.pos_eps) and (diff_rot < self.rot_eps)

    def get_random_pose(self, env, obj_size):
        """Get random collision-free object pose within workspace bounds."""

        # Get erosion size of object in pixels.
        max_size = np.sqrt(obj_size[0] ** 2 + obj_size[1] ** 2)
        erode_size = int(np.round(max_size / self.pix_size))

        _, hmap, obj_mask = self.get_true_image(env)

        # Randomly sample an object pose within free-space pixels.
        free = np.ones(obj_mask.shape, dtype=np.uint8)
        for obj_ids in env.obj_ids.values():
            for obj_id in obj_ids:
                free[obj_mask == obj_id] = 0
        free[0, :], free[:, 0], free[-1, :], free[:, -1] = 0, 0, 0, 0
        free = cv2.erode(free, np.ones((erode_size, erode_size), np.uint8))

        # if np.sum(free) == 0:
        #     return None, None

        if np.sum(free) == 0:
            # avoid returning None, None
            # return None, None
            pix = (obj_mask.shape[0] // 2, obj_mask.shape[1] // 2)
        else:
            pix = utils.sample_distribution(np.float32(free))
        pos = utils.pix_to_xyz(pix, hmap, self.bounds, self.pix_size)
        pos = (pos[0], pos[1], obj_size[2] / 2)
        theta = np.random.rand() * 2 * np.pi
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta))
        return pos, rot

    def get_lang_goal(self):
        if len(self.lang_goals) == 0:
            return self.task_completed_desc
        else:
            return self.lang_goals[0]

    def get_reward(self):
        return float(self._rewards)

    # -------------------------------------------------------------------------
    # Helper Functions
    # -------------------------------------------------------------------------

    def fill_template(self, template, replace):
        """Read a file and replace key strings."""
        full_template_path = os.path.join(self.assets_root, template)
        with open(full_template_path, 'r') as file:
            fdata = file.read()
        for field in replace:
            for i in range(len(replace[field])):
                fdata = fdata.replace(f'{field}{i}', str(replace[field][i]))
        alphabet = string.ascii_lowercase + string.digits
        rname = ''.join(random.choices(alphabet, k=16))
        tmpdir = tempfile.gettempdir()
        template_filename = os.path.split(template)[-1]
        fname = os.path.join(tmpdir, f'{template_filename}.{rname}')
        with open(fname, 'w') as file:
            file.write(fdata)
        return fname

    def get_random_size(self, min_x, max_x, min_y, max_y, min_z, max_z):
        """Get random box size."""
        size = np.random.rand(3)
        size[0] = size[0] * (max_x - min_x) + min_x
        size[1] = size[1] * (max_y - min_y) + min_y
        size[2] = size[2] * (max_z - min_z) + min_z
        return tuple(size)

    def color_random_brown(self, obj):
        shade = np.random.rand() + 0.5
        color = np.float32([shade * 156, shade * 117, shade * 95, 255]) / 255
        p.changeVisualShape(obj, -1, rgbaColor=color)

  """""
  
  # Environment Class
  def add_object(self, urdf, pose, category='rigid'):
    """List of (fixed, rigid, or deformable) objects in env."""
    fixed_base = 1 if category == 'fixed' else 0
    obj_id = pybullet_utils.load_urdf(
        p,
        os.path.join(self.assets_root, urdf),
        pose[0],
        pose[1],
        useFixedBase=fixed_base)
    self.obj_ids[category].append(obj_id)
    return obj_id
"""

=========
Note that the objects need to obey physics and not collide with each other, and the object goal poses need to be above the table with lower bound x=0.25, y=-0.5 and upper bound x=0.75, y=0.5. When there are multiple objects for a multi-step pick-and-place task, there are often multiple subgoals. Once the task and environment are generated, an agent with a pick and place primitive will follow the defined goal to accomplish the tasks. 

Additionally, make sure you understand and summarize the ``self.goals`` variables, which has a list of 8-tuple with (objs, matches, targ_poses, replace, rotations, metric, params, step_max_reward, symmetries).
- objs (List of obj_id): object ID.
- matches (Binary Matrix): a binary matrix that denotes which object is matched with which target. This matrix has dimension len(objs) x len(targs).
- targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation). 
- replace (Boolean): whether each object can match with one unique target. This is important if we have one target and multiple objects. If it's set to be false, then any object matching with the target will satisfy.
- rotations (Boolean): whether the placement action has a rotation degree of freedom. 
- metric (`pose` or `zone`): `pose` or `zone` that the object needs to be transported to. Example: `pose`. 
- params (List of (zone_target, zone_size)): a list of (zone_target, zone_size) for each zone if the metric is `zone`. 
- step_max_reward (float): the total reward of matching all the objects with all the target poses. It is not dependent on the number of objects but dependent on the number of goals. 
- symmetries: the radians that the object is symmetric around z axis.
- language_goal: the low-level language instructions that denote the goal of this step.
 


>>> Answer: 
I understand the provided APIs and their functionalities. Here's a summary of my understanding:

The `Task` class serves as a base class for defining a robotic task in a simulated environment. It initializes with default parameters for the end effector, mode, six degrees of freedom (DoF) capability, a pick-and-place primitive, and camera configurations. It also sets up evaluation metrics for pose accuracy, workspace bounds, and other task-related variables.

The `reset` method is used to initialize or reset the task, setting up goals and other task-related variables.

The `oracle` method provides an oracle agent that can generate actions for the robot to perform the task perfectly. It uses perfect knowledge of the environment to determine the best pick and place actions to achieve the task goals.

The `reward` method calculates the reward for the current timestep based on the task's progress and the current state of the environment. It uses different metrics such as pose accuracy or zone coverage to evaluate the performance.

The `done` method checks whether the task has been completed or has failed, which is used to determine the end of an episode.

The `is_match` helper function checks if two poses match within a specified threshold, considering translational and rotational errors.

The `get_random_pose` helper function generates a random collision-free pose for an object within the workspace bounds.

The `get_lang_goal` method returns the current language goal, which is a low-level language instruction describing the task's goal.

The `get_reward` method returns the current cumulative reward for the task.

The `fill_template` helper function is used to read a file template and replace key strings with specified values.

The `get_random_size` helper function generates a random size for an object within specified bounds.

The `color_random_brown` method applies a random brown color to an object.

The `add_object` method in the environment class is used to add objects to the simulation environment, specifying their pose and whether they are fixed, rigid, or deformable.

The `self.goals` variable is a list of 8-tuples that define the subgoals for a multi-step pick-and-place task. Each tuple contains information about the objects involved, their target poses, whether objects can match with multiple targets, whether rotations are considered in placements, the evaluation metric, parameters for zone evaluation, the maximum reward for completing the step, and the symmetries of the objects.

Understanding these APIs is crucial for writing the code for the "gradient-tower-placement" task, as they provide the necessary functions and methods to interact with the simulation environment, control the robot, and evaluate its performance.

================= Code Generation!

>>> Prompt: 
Now I will provide you some reference code and you can write the code for the task "gradient-tower-placement".


"""
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class PackingShapes(Task):
    """pick up randomly sized shapes and place them tightly into a container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 1
        self.homogeneous = False

        self.lang_template = "pack the {obj} in the brown box"
        self.task_completed_desc = "done packing shapes."
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        # Shape Names:
        shapes = utils.assembling_kit_shapes

        n_objects = 5
        if self.mode == 'train':
            obj_shapes = np.random.choice(self.train_set, n_objects, replace=False)
        else:
            if self.homogeneous:
                obj_shapes = [np.random.choice(self.test_set, replace=False)] * n_objects
            else:
                obj_shapes = np.random.choice(self.test_set, n_objects, replace=False)

        # Shuffle colors to avoid always picking an object of the same color
        colors, color_names = utils.get_colors(mode=self.mode)

        # Add container box.
        zone_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, zone_pose, 'fixed')

        # Add objects.
        objects = []
        template = 'kitting/object-template.urdf'
        for i in range(n_objects):
            shape = obj_shapes[i]

            # x, y, z dimensions for the asset size
            size = (0.08, 0.08, 0.02)
            pose= self.get_random_pose(env, size)
            fname = f'{shape:02d}.obj'
            fname = os.path.join(self.assets_root, 'kitting', fname)
            scale = [0.003, 0.003, 0.001]  # .0005
            replace = {'FNAME': (fname,),
                       'SCALE': scale,
                       'COLOR': colors[i]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            block_id = env.add_object(urdf, pose)
            objects.append(block_id)

        # Pick the first shape.
        num_objects_to_pick = 1
        for i in range(num_objects_to_pick):
            # IMPORTANT: Specify (obj_pts, [(zone_pose, zone_size)]) for target `zone`. obj_pts is a dict
            language_goal = self.lang_template.format(obj=shapes[obj_shapes[i]])
            self.add_goal(objs=[objects[i]], matches=np.int32([[1]]), targ_poses=[zone_pose], replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1 / num_objects_to_pick,
                language_goal=language_goal)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PlaceRedInGreen(Task):
    """pick up the red blocks and place them into the green bowls amidst other objects."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = "put the red blocks in a green bowl"
        self.task_completed_desc = "done placing blocks in bowls."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_blocks = np.random.randint(1, n_bowls + 1)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, obj_size=bowl_size)
            env.add_object(urdf=bowl_urdf, pose=bowl_pose, category='fixed')
            bowl_poses.append(bowl_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        for _ in range(n_blocks):
            block_pose = self.get_random_pose(env, obj_size=block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Goal: each red block is in a different green bowl.
        self.add_goal(objs=blocks, matches=np.ones((len(blocks), len(bowl_poses))), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

        # Colors of distractor objects.
        bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'green']
        block_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'red']

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = block_colors if is_block else bowl_colors
            pose = self.get_random_pose(env, obj_size=size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1
"""
"""
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils


class SweepingPiles(Task):
    """Push piles of small objects into a target goal zone marked on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = "push the pile of blocks into the green square"
        self.task_completed_desc = "done sweeping."
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add goal zone.
        zone_size = (0.12, 0.12, 0)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add pile of small blocks with `make_piles` function
        obj_ids = self.make_piles(env)

        # Add goal
        self.add_goal(objs=obj_ids, matches=np.ones((50, 1)), targ_poses=[zone_pose], replace=True,
                rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class StackBlockPyramid(Task):
    """Build a pyramid of colored blocks in a color sequence"""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = "make the {row} row with {blocks}"
        self.task_completed_desc = "done stacking block pyramid."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['red']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, blue, purple).
        language_goal = self.lang_template.format(blocks="the green, blue and purple blocks", row="bottom")
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (middle row: yellow, orange).
        language_goal = self.lang_template.format(blocks="the yellow and orange blocks", row="middle")      
        self.add_goal(objs=objs[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (top row: red).
        language_goal = self.lang_template.format(blocks="the red block", row="top")
        self.add_goal(objs=objs[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2]*1, language_goal=language_goal)
"""



Do not use libraries, functions, and assets that you don't know. For each object, try to describe its color, size, category in the task first before you write the code. You do not need extra helper functions. Comment the code liberally to explain what each piece does and why it's written that way. If you have only one goal, `step_max_reward` in `add_goal` should be 1. Use functions `make_piles` and `make_ropes` for creating piles and cables. To use spatula together with the push primitives, import the libraries 
"""
from cliport.tasks import primitives;
from cliport.tasks.grippers import Spatula
"""
and then use `self.primitive = primitives.push` and `self.ee = Spatula`.
Note that the number of language goals usually match the number of motion goals, since they should correspond to each other.

Before generate code, you have a few considerations to focus on:
1. You are strictly prohibited from using function interfaces that do not appear in the above sample code. For example, the module cliport.tasks.primitives does not have pick_plack or place functions, only the push function interface is available.
2. Module 'cliport.tasks.primitives' has no attribute 'pick_place', you mustn't use it.
3. There are two types of your Gripper, one is Spatula and the other is Suction.You need to choose a different end-effector depending on your task requirements. If you need to move an object on the Z axis, then you need to use the Suction type. If you just need to translate an object in a 2D plane, then you can use either Spatula or Suction type.
4. You must determine the type of end-effector you need to use based on the type of task you have. You can choose by adding self.ee=Spatula or self.ee=Suction to the __init__(self) function, the default self.ee is Suction.
5. If you want to use Suction, you must import module using "from cliport.tasks.grippers import Suction". Else if you want to use Spatula, you must import module using "from cliport.tasks.grippers import Spatula".
6. The x-coordinate of the object is in the range [0.25, 0.75], the y-coordinate is in the range [-0.5,0.5] and the z-coordinate is in the range [0, 0.3].
7. The initial position of all objects needs to get its random initial position through the get_random_pose function.
8. The self.max_steps parameter value should be greater than the number of calls to self.add_goal, and preferably equal to twice the number of calls to self.add_goal. For example, if you call self.add_goal twice in one task, then self.max_steps is better set to 4.

If you want to generate the color of the object, you have to obey following rules:
1. You must use the utils.COLORS['COLOR_NAME'] function interface to generate an RGB three-channel value for a color.
2. The available colors for 'COLOR_NAME' are blue, red, green, orange, yellow, purple, pink, cyan, brown, white, gray, indigo, violet, black, silver and gold.
3. If you want to generate a red object, then its RGB three-channel color can be obtained through utils.COLORS['red'].
All object’s colors generation must follow color generation method above.

If you want to generate the target pose of the object(third parameter of function 'self.add_goal' targ_poses), you have to obey following rules:
1. The target pose of an object is represented by the three-dimensional spatial coordinates of the object and its orientation quaternion.
2. The target pose of an object must be represented by [(x,y,z),(q1,q2,q3,q4)]. Where (x,y,z) are the three-dimensional coordinates of the object and (q1,q2,q3,q4) denote the quaternions of the object's target pose.
3. The target pose of an object must be generated by you or use the initial pose of an object as the target pose of the current object.
4. Here's an example, to generate the target pose of a Y object, we have the initial pose information of an X object. So target pose of Y can be represented by pose_y=[(x,y,z),(q1,q2,q3,q4)] or pose_y=initial_pose_x.(Where x,y,z,q1,q2,q3,q4 are specific values.)
5. targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation).
6. The targ_poses you generate must contain translation[x,y,z], but rotation[q0,q1,q2,q3] you may or may not generate.
All object's target pose generation must follow method above.

Now write the code for the task "gradient-tower-placement" in python code block starting with ```python.  Reminder: {'task-name': 'gradient-tower-placement', 'task-description': 'Build two separate towers each made of three differently colored cylinders, placing them on a patterned zone marked with two distinct areas, one for each tower, while ensuring that the cylinders in each tower are arranged in a color gradient sequence from the lightest on top to the darkest at the base.', 'assets-used': ['cylinder/cylinder-template.urdf', 'zone/zone.urdf']} 


>>> Answer: 
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class GradientTowerPlacement(Task):
    """Build two separate towers each made of three differently colored cylinders,
    placing them on a patterned zone marked with two distinct areas, one for each tower,
    while ensuring that the cylinders in each tower are arranged in a color gradient sequence
    from the lightest on top to the darkest at the base."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 steps per tower, so 6 in total
        self.lang_template = "build a tower with the {colors} cylinders"
        self.task_completed_desc = "done building gradient towers."
        self.ee = Suction  # We need to move objects on the Z axis, so we use Suction

    def reset(self, env):
        super().reset(env)

        # Define the colors for the cylinders in gradient order (lightest to darkest)
        gradient_colors = ['silver', 'gray', 'black']

        # Define the size of the cylinders
        cylinder_size = (0.04, 0.04, 0.12)  # (radius, radius, height)

        # Add the patterned zone with two distinct areas for the towers
        zone_size = (0.24, 0.12, 0)  # Size of the entire zone
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Split the zone into two areas, one for each tower
        tower_zone_poses = [
            (zone_pose[0][0] - 0.08, zone_pose[0][1], zone_pose[0][2]),
            (zone_pose[0][0] + 0.08, zone_pose[0][1], zone_pose[0][2])
        ]

        # Add cylinders and define their target poses within the zone
        cylinders = []
        target_poses = []
        for i in range(2):  # Two towers
            for j, color_name in enumerate(gradient_colors):
                # Get the color RGB values
                color = utils.COLORS[color_name]

                # Generate a random pose for the cylinder
                pose = self.get_random_pose(env, cylinder_size)

                # Create the cylinder URDF using the template
                cylinder_urdf = self.fill_template('cylinder/cylinder-template.urdf', {'COLOR': color})

                # Add the cylinder to the environment
                cylinder_id = env.add_object(cylinder_urdf, pose)
                cylinders.append(cylinder_id)

                # Define the target pose for the cylinder in the tower
                # The Z coordinate is offset by the cylinder height times the index
                target_pose = (tower_zone_poses[i][0], tower_zone_poses[i][1], zone_pose[0][2] + cylinder_size[2] * j)
                target_poses.append((target_pose, (0, 0, 0, 1)))  # No rotation needed

        # Add goals for each cylinder
        for i in range(len(cylinders)):
            # Define the language goal for the current step
            if i < 3:
                colors_text = ', '.join(gradient_colors[:i+1])
                language_goal = self.lang_template.format(colors=colors_text)
            else:
                colors_text = ', '.join(gradient_colors[:i-2])
                language_goal = self.lang_template.format(colors=colors_text)

            # Add the goal for the current cylinder
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[target_poses[i]],
                          replace=False, rotations=False, metric='pose', params=None,
                          step_max_reward=1/len(cylinders), language_goal=language_goal)
```

================= TRIAL: 9

================= Code Reflect!

>>> Prompt: 


Do you think your task is sufficently interesting to be added as a new task for future task given that we already have the following task name and descriptions? Moreover, does the simulation code achieve the goal and the language descriptions in the task? Be as rigorous and high-standard as possible.

Reminder:
your task:
{'task-name': 'gradient-tower-placement', 'task-description': 'Build two separate towers each made of three differently colored cylinders, placing them on a patterned zone marked with two distinct areas, one for each tower, while ensuring that the cylinders in each tower are arranged in a color gradient sequence from the lightest on top to the darkest at the base.', 'assets-used': ['cylinder/cylinder-template.urdf', 'zone/zone.urdf']}

import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class GradientTowerPlacement(Task):
    """Build two separate towers each made of three differently colored cylinders,
    placing them on a patterned zone marked with two distinct areas, one for each tower,
    while ensuring that the cylinders in each tower are arranged in a color gradient sequence
    from the lightest on top to the darkest at the base."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 steps per tower, so 6 in total
        self.lang_template = "build a tower with the {colors} cylinders"
        self.task_completed_desc = "done building gradient towers."
        self.ee = Suction  # We need to move objects on the Z axis, so we use Suction

    def reset(self, env):
        super().reset(env)

        # Define the colors for the cylinders in gradient order (lightest to darkest)
        gradient_colors = ['silver', 'gray', 'black']

        # Define the size of the cylinders
        cylinder_size = (0.04, 0.04, 0.12)  # (radius, radius, height)

        # Add the patterned zone with two distinct areas for the towers
        zone_size = (0.24, 0.12, 0)  # Size of the entire zone
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Split the zone into two areas, one for each tower
        tower_zone_poses = [
            (zone_pose[0][0] - 0.08, zone_pose[0][1], zone_pose[0][2]),
            (zone_pose[0][0] + 0.08, zone_pose[0][1], zone_pose[0][2])
        ]

        # Add cylinders and define their target poses within the zone
        cylinders = []
        target_poses = []
        for i in range(2):  # Two towers
            for j, color_name in enumerate(gradient_colors):
                # Get the color RGB values
                color = utils.COLORS[color_name]

                # Generate a random pose for the cylinder
                pose = self.get_random_pose(env, cylinder_size)

                # Create the cylinder URDF using the template
                cylinder_urdf = self.fill_template('cylinder/cylinder-template.urdf', {'COLOR': color})

                # Add the cylinder to the environment
                cylinder_id = env.add_object(cylinder_urdf, pose)
                cylinders.append(cylinder_id)

                # Define the target pose for the cylinder in the tower
                # The Z coordinate is offset by the cylinder height times the index
                target_pose = (tower_zone_poses[i][0], tower_zone_poses[i][1], zone_pose[0][2] + cylinder_size[2] * j)
                target_poses.append((target_pose, (0, 0, 0, 1)))  # No rotation needed

        # Add goals for each cylinder
        for i in range(len(cylinders)):
            # Define the language goal for the current step
            if i < 3:
                colors_text = ', '.join(gradient_colors[:i+1])
                language_goal = self.lang_template.format(colors=colors_text)
            else:
                colors_text = ', '.join(gradient_colors[:i-2])
                language_goal = self.lang_template.format(colors=colors_text)

            # Add the goal for the current cylinder
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[target_poses[i]],
                          replace=False, rotations=False, metric='pose', params=None,
                          step_max_reward=1/len(cylinders), language_goal=language_goal)

current task list:
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- stack-block-pyramid: {'assets-used': ['stacking/stand.urdf', 'stacking/block.urdf'], 'task-description': 'sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.', 'task-name': 'stack-block-pyramid'}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- cylinder_hurdle_arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- color_coded_pallet_organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color-coded-pallet-organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- cylinder_tower_balancing: {'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}
- cylinder-tower-balancing: {'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}
- color_gradient_tower: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color-gradient-tower: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- precision_box_placement: {'task-name': 'precision-box-placement', 'task-description': "Pick up a small blue box and place it precisely within the bounds of a marked white zone on a pallet, ensuring the box does not touch the zone's edges.", 'assets-used': ['box/box-template.urdf', 'zone/zone.urdf', 'pallet/pallet.urdf']}




=========
Reply explain your reasons and then say True or False, formatted in a python dictionary, do not miss commas or add extra spaces. Here are some examples.

{
	"task_name": "sort-color-blocks",
	"task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "yellow-bowl.urdf", "box/box-template.urdf],
	"reasons": "not interesting because it overlaps with the current task `put-block-in-bowl`"
	"add_to_the_task_list": "False",
}

{
  	"task-name": "guided-ball-maze",
  	"task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
  	"assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
   	"reasons": "the language descriptions are too ambiguous. Navigation is also hard to complete."
  	"add_to_the_task_list": "False",  
}

{
 	"task-name": "sort-blocks-by-zone",
 	"task-description": "Sort different colored blocks into their corresponding colored zones marked on the tabletop.",
 	"assets-used": ["zone/zone.urdf", "stacking/block.urdf"],
	"reasons": "the task is not covered in the current list and is an interesting combination of zone and block objects." 
	"add_to_the_task_list": "True",
}

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
    "reasons": "this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "arrange-blocks-on-pallet",
    "task-description": "arrange the blocks on the pallet in the order: red, orange, yellow, green, blue, and purple.",
    "assets-used": ["stacking/block.urdf", "pallet/pallelt.urdf"],
    "reasons": "this task overlaps with `arrange-boxes-on-pallet` by merely changing the blocks to boxes.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "cylinder-color-alignment",
    "task-description": "Pick up cylinders of different colors and align them inside a box in the order of the colors displayed on the single green line on the tabletop.",
    "assets-used": ["cylinder/cylinder-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf   
    "reasons": "the execution code only has one goal, i.e. it will only move one cylinder on top of the box, which is not that interesting.", 
    "add_to_the_task_list": "False","]
}

{
    "task-name": "build-bridge",
    "task-description": "Construct a bridge using two yellow blocks and three blue blocks. Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between. Then, place the blue block horizontally on top of the yellow blocks.",
     "assets-used": ["block/block.urdf", "ball/ball-template.urdf"]
    "reasons": "this task is an interesting and long-horizon task for pick and place primitives. Training manipulation agent with this skill will be a useful building block for next skills.", 
    "add_to_the_task_list": "True",
}

=========

Please incorporate these feedbacks when you design new task!



>>> Answer: 
{
    "task-name": "gradient-tower-placement",
    "task-description": "Build two separate towers each made of three differently colored cylinders, placing them on a patterned zone marked with two distinct areas, one for each tower, while ensuring that the cylinders in each tower are arranged in a color gradient sequence from the lightest on top to the darkest at the base.",
    "assets-used": ["cylinder/cylinder-template.urdf", "zone/zone.urdf"],
    "reasons": "The task is sufficiently distinct from 'color-gradient-tower' as it requires building two separate towers with a specific color gradient, which adds complexity and requires more precise control. However, the simulation code appears to have an issue with the language goal description generation. The language goals for cylinders in the second tower (indexes 3 to 5) are incorrectly using 'gradient_colors[:i-2]' instead of a slice of the gradient_colors list that corresponds to the second tower. This needs to be corrected to accurately reflect the task's requirements. Additionally, the task's uniqueness could be further emphasized by specifying that the two towers must be built simultaneously or within a specific time constraint to differentiate it from similar tasks.",
    "add_to_the_task_list": "False",
}

================= Task and Asset Design!

>>> Prompt: 
You are an AI in robot simulation code and task design. I will provide you some example tasks, code implementation, and some guidelines for how to generate tasks and then you will help me generate a new task. My goal is to design diverse and feasible tasks for tabletop manipulation. I will first ask you to describe the task in natural languages and then will let you write the code for it. 

=========
Here are all the assets. Use only these assets in the task and code design. 
"""
insertion/:
ell.urdf  fixture.urdf

bowl/:
bowl.urdf

box/:
box-template.urdf

stacking/:
block.urdf  stand.urdf

zone/:
zone.obj  zone.urdf

pallet/:
pallet.obj  pallet.urdf

ball/:
ball-template.urdf

cylinder/:
cylinder-template.urdf

bowl/:
bowl.urdf

# assets not for picking
corner/:
corner-template.urdf

line/:
single-green-line-template.urdf

container/:
container-template.urdf
"""
 
=========
Here are some examples of good tasks. Try to learn from these structures but avoid overlapping wiht them.

{"assets-used": ["zone/zone.urdf", "block/small.urdf"],
 "task-description": "Push piles of small objects into a target goal zone marked on the tabletop.",
 "task-name": "sweeping-piles"}

{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "Place all blocks of a specified color in a bowl of specified color.",
 "task-name": "put-block-in-bowl"}
 
{"assets-used": ["insertion/ell.urdf", "insertion/fixture.urdf"],
 "task-description": "pick up the L-shaped red block and place it into the L-shaped fixture.",
 "task-name": "block-insertion"}
 
{"assets-used": ["kitting/kit.urdf", "kitting/object-template.urdf"],
 "task-description": "pick up different objects and arrange them on a board marked with corresponding silhouettes.",
 "task-name": "assembling-kits"}
 
{"assets-used": ["pallet/pallet.urdf", "box/box-template.urdf"],
 "task-description": "pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.",
 "task-name": "palletizing-boxes"}
 
{"assets-used": ["stacking/stand.urdf", "stacking/block.urdf"],
 "task-description": "sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.",
 "task-name": "stack-block-pyramid"}
 
{"assets-used": ["container/container-template.urdf", "box/box-template.urdf"],
 "task-description": "pick up randomly sized boxes and place them tightly into a container.",
 "task-name": "packing-boxes"}
 
{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "pick up the red blocks and place them into the green bowls amidst other objects.",
 "task-name": "place-red-in-green"}
 
{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

=========
Here are some tasks that you have come up with before. Try to learn from these structures but avoid overlapping with these tasks. For instance, `bowl_ball_placement` and `sort_balls_in_bowls` are the same task. `pile_boxes_in_corner` and `stack_blocks_into_pallet` are similar tasks, `align-cylinder-in-corner` and `align-cylinder-corner` are similar.
- cylinder_hurdle_arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- stack-block-pyramid: {'assets-used': ['stacking/stand.urdf', 'stacking/block.urdf'], 'task-description': 'sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.', 'task-name': 'stack-block-pyramid'}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- cylinder-tower-balancing: {'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}
- gradient_tower_placement: {'task-name': 'gradient-tower-placement', 'task-description': 'Build two separate towers each made of three differently colored cylinders, placing them on a patterned zone marked with two distinct areas, one for each tower, while ensuring that the cylinders in each tower are arranged in a color gradient sequence from the lightest on top to the darkest at the base.', 'assets-used': ['cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- cylinder_tower_balancing: {'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}





=========
Here are some bad example task instances with explanations.
{
    "task_name": "sort-color-blocks",
    "task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "box/box-template.urdf],
}
reasons: not interesting because it overlaps with the current task `put-block-in-bowl`.

{
    "task-name": "guided-ball-maze",
    "task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
    "assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
}
reasons: the language descriptions are too ambiguous. Navigation is also hard to complete. Also maze.urf does not exist.

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
}
reasons: this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere. Similarly tasks like `insert-ball-into-cylinder` and `cylinder-box-insertion` are invalid.

{
    "task-name": "ball-box-obstacle-course",
    "task-description": "Navigate a ball through an obstacle course created by randomly placed boxes and finally place it inside a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: Navigate the ball is not related to tabletop manipulation tasks.

{
    "task-name": "ball-in-box",
    "task-description": "Use a cable to guide a ball into an open box.",
    "assets-used": ["cable/cable.urdf", "ball/ball-template.urdf", "box/box-template.urdf"]
}
reasons: This task is too hard since it involves interaction of the cable and the ball and cannot be easily completed.

{
    "task-name": "ball-in-container",
    "task-description": "Use the spatula to lift a ball over a wall of boxes and drop it into a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: The only action primitives as pick and place. One cannot use a spatula to lift an object.

{
    "task-name": "line-ball-sorting",
    "task-description": "Move balls of different colors along a single green line, placing each ball in a designated colored box at the end of the line. The challenge includes precision in maintaining the ball on the line and the correct identification of the box color corresponding to each ball.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf"]
}
reasons: Piling or stacking balls are physically infeasible in the simulation.



=========
Now please describe the new task in natural languages and explain its novelty and challenges. Format the answer in a python dictionary with keys "task-name" and value type string, "task-description" (one specific sentence) and value type string, and "assets-used" and value type list of strings. Note that

- Do not use assets that are not in the list above. 
- Tasks that have more colors and shapes are interesting.
- Be as specific as possible about the number, shape, and color of each asset in the task descriptions. 
- The task need to obey physics and remain feasible.





>>> Answer: 
Based on your guidelines and the assets provided, here's a new task:

```python
{
    "task-name": "precision-placement-pyramid",
    "task-description": "Carefully place one red, one green, and one blue cylinder in a vertical arrangement to form a small pyramid within a demarcated zone on the tabletop, with the red cylinder at the base, green in the middle, and blue at the apex.",
    "assets-used": ["cylinder/cylinder-template.urdf", "zone/zone.urdf"]
}
```

Novelty:
This task introduces precision in both color recognition and placement within a specific spatial area. Unlike previous tasks which involve stacking on stands or fitting into fixtures, this task requires the robot to balance cylinders on top of each other on a flat surface, which increases the challenge of maintaining stability.

Challenges:
- The robot must identify and sort cylinders by color, then stack them in a specific order.
- The stability of the pyramid, especially on a flat surface without any guides or interlocking parts, requires precise control of force and alignment during placement.
- The task requires the robot to plan and execute a sequence of actions that account for the changing center of mass as each cylinder is added to the pyramid.
- The demarcated zone also adds a constraint to the workspace, necessitating careful spatial reasoning and manipulation.

================= API Preview!

>>> Prompt: 
Before writing the code for the task "precision-placement-pyramid". Here are some APIs that are defined. Please confirm that you understand these APIs.

"""
class Task():
    """Base Task class."""

    def __init__(self):
        self.ee = Suction
        self.mode = 'train'
        self.sixdof = False
        self.primitive = primitives.PickPlace()
        self.oracle_cams = cameras.Oracle.CONFIG

        # Evaluation epsilons (for pose evaluation metric).
        self.pos_eps = 0.01
        self.rot_eps = np.deg2rad(15)

        # Workspace bounds.
        self.pix_size = 0.003125
        self.bounds = np.array([[0.25, 0.75], [-0.5, 0.5], [0, 0.3]])
        self.zone_bounds = np.copy(self.bounds)

        self.goals = []
        self.lang_goals = []
        self.task_completed_desc = "task completed."
        self.progress = 0
        self._rewards = 0
        self.assets_root = None

    def reset(self, env):
        if not self.assets_root:
            raise ValueError('assets_root must be set for task, '
                             'call set_assets_root().')
        self.goals = []
        self.lang_goals = []
        self.progress = 0  # Task progression metric in range [0, 1].
        self._rewards = 0  # Cumulative returned rewards.

    # -------------------------------------------------------------------------
    # Oracle Agent
    # -------------------------------------------------------------------------

    def oracle(self, env):
        """Oracle agent."""
        OracleAgent = collections.namedtuple('OracleAgent', ['act'])

        def act(obs, info):
            """Calculate action."""

            # Oracle uses perfect RGB-D orthographic images and segmentation masks.
            _, hmap, obj_mask = self.get_true_image(env)

            # Unpack next goal step.
            objs, matches, targs, replace, rotations, _, _, _ = self.goals[0]

            # Match objects to targets without replacement.
            if not replace:

                # Modify a copy of the match matrix.
                matches = matches.copy()

                # Ignore already matched objects.
                for i in range(len(objs)):
                    object_id, (symmetry, _) = objs[i]
                    pose = p.getBasePositionAndOrientation(object_id)
                    targets_i = np.argwhere(matches[i, :]).reshape(-1)
                    for j in targets_i:
                        if self.is_match(pose, targs[j], symmetry):
                            matches[i, :] = 0
                            matches[:, j] = 0

            # Get objects to be picked (prioritize farthest from nearest neighbor).
            nn_dists = []
            nn_targets = []
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                xyz, _ = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                if len(targets_i) > 0:
                    targets_xyz = np.float32([targs[j][0] for j in targets_i])
                    dists = np.linalg.norm(
                        targets_xyz - np.float32(xyz).reshape(1, 3), axis=1)
                    nn = np.argmin(dists)
                    nn_dists.append(dists[nn])
                    nn_targets.append(targets_i[nn])

                # Handle ignored objects.
                else:
                    nn_dists.append(0)
                    nn_targets.append(-1)
            order = np.argsort(nn_dists)[::-1]

            # Filter out matched objects.
            order = [i for i in order if nn_dists[i] > 0]

            pick_mask = None
            for pick_i in order:
                pick_mask = np.uint8(obj_mask == objs[pick_i][0])

                # Erode to avoid picking on edges.
                # pick_mask = cv2.erode(pick_mask, np.ones((3, 3), np.uint8))

                if np.sum(pick_mask) > 0:
                    break

            # Trigger task reset if no object is visible.
            if pick_mask is None or np.sum(pick_mask) == 0:
                self.goals = []
                self.lang_goals = []
                print('Object for pick is not visible. Skipping demonstration.')
                return

            # Get picking pose.
            pick_prob = np.float32(pick_mask)
            pick_pix = utils.sample_distribution(pick_prob)
            # For "deterministic" demonstrations on insertion-easy, use this:
            # pick_pix = (160,80)
            pick_pos = utils.pix_to_xyz(pick_pix, hmap,
                                        self.bounds, self.pix_size)
            pick_pose = (np.asarray(pick_pos), np.asarray((0, 0, 0, 1)))

            # Get placing pose.
            targ_pose = targs[nn_targets[pick_i]]
            obj_pose = p.getBasePositionAndOrientation(objs[pick_i][0])
            if not self.sixdof:
                obj_euler = utils.quatXYZW_to_eulerXYZ(obj_pose[1])
                obj_quat = utils.eulerXYZ_to_quatXYZW((0, 0, obj_euler[2]))
                obj_pose = (obj_pose[0], obj_quat)
            world_to_pick = utils.invert(pick_pose)
            obj_to_pick = utils.multiply(world_to_pick, obj_pose)
            pick_to_obj = utils.invert(obj_to_pick)
            place_pose = utils.multiply(targ_pose, pick_to_obj)

            # Rotate end effector?
            if not rotations:
                place_pose = (place_pose[0], (0, 0, 0, 1))

            place_pose = (np.asarray(place_pose[0]), np.asarray(place_pose[1]))

            return {'pose0': pick_pose, 'pose1': place_pose}

        return OracleAgent(act)

    # -------------------------------------------------------------------------
    # Reward Function and Task Completion Metrics
    # -------------------------------------------------------------------------

    def reward(self):
        """Get delta rewards for current timestep.

        Returns:
          A tuple consisting of the scalar (delta) reward, plus `extras`
            dict which has extra task-dependent info from the process of
            computing rewards that gives us finer-grained details. Use
            `extras` for further data analysis.
        """
        reward, info = 0, {}

        # Unpack next goal step.
        objs, matches, targs, _, _, metric, params, max_reward = self.goals[0]

        # Evaluate by matching object poses.
        if metric == 'pose':
            step_reward = 0
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                pose = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                for j in targets_i:
                    target_pose = targs[j]
                    if self.is_match(pose, target_pose, symmetry):
                        step_reward += max_reward / len(objs)
                        print(f"object {i} match with target {j} rew: {step_reward}")
                        break

        # Evaluate by measuring object intersection with zone.
        elif metric == 'zone':
            zone_pts, total_pts = 0, 0
            obj_pts, zones = params
            for zone_idx, (zone_pose, zone_size) in enumerate(zones):

                # Count valid points in zone.
                for obj_idx, obj_id in enumerate(obj_pts):
                    pts = obj_pts[obj_id]
                    obj_pose = p.getBasePositionAndOrientation(obj_id)
                    world_to_zone = utils.invert(zone_pose)
                    obj_to_zone = utils.multiply(world_to_zone, obj_pose)
                    pts = np.float32(utils.apply(obj_to_zone, pts))
                    if len(zone_size) > 1:
                        valid_pts = np.logical_and.reduce([
                            pts[0, :] > -zone_size[0] / 2, pts[0, :] < zone_size[0] / 2,
                            pts[1, :] > -zone_size[1] / 2, pts[1, :] < zone_size[1] / 2,
                            pts[2, :] < self.zone_bounds[2, 1]])

                    # if zone_idx == matches[obj_idx].argmax():
                    zone_pts += np.sum(np.float32(valid_pts))
                    total_pts += pts.shape[1]
            step_reward = max_reward * (zone_pts / total_pts)

        # Get cumulative rewards and return delta.
        reward = self.progress + step_reward - self._rewards
        self._rewards = self.progress + step_reward

        # Move to next goal step if current goal step is complete.
        if np.abs(max_reward - step_reward) < 0.01:
            self.progress += max_reward  # Update task progress.
            self.goals.pop(0)
            if len(self.lang_goals) > 0:
                self.lang_goals.pop(0)

        return reward, info

    def done(self):
        """Check if the task is done or has failed.

        Returns:
          True if the episode should be considered a success, which we
            use for measuring successes, which is particularly helpful for tasks
            where one may get successes on the very last time step, e.g., getting
            the cloth coverage threshold on the last alllowed action.
            However, for bag-items-easy and bag-items-hard (which use the
            'bag-items' metric), it may be necessary to filter out demos that did
            not attain sufficiently high reward in external code. Currently, this
            is done in `main.py` and its ignore_this_demo() method.
        """
        return (len(self.goals) == 0) or (self._rewards > 0.99)
        # return zone_done or defs_done or goal_done

    # -------------------------------------------------------------------------
    # Environment Helper Functions
    # -------------------------------------------------------------------------

    def is_match(self, pose0, pose1, symmetry):
        """Check if pose0 and pose1 match within a threshold."""

        # Get translational error.
        diff_pos = np.float32(pose0[0][:2]) - np.float32(pose1[0][:2])
        dist_pos = np.linalg.norm(diff_pos)

        # Get rotational error around z-axis (account for symmetries).
        diff_rot = 0
        if symmetry > 0:
            rot0 = np.array(utils.quatXYZW_to_eulerXYZ(pose0[1]))[2]
            rot1 = np.array(utils.quatXYZW_to_eulerXYZ(pose1[1]))[2]
            diff_rot = np.abs(rot0 - rot1) % symmetry
            if diff_rot > (symmetry / 2):
                diff_rot = symmetry - diff_rot

        return (dist_pos < self.pos_eps) and (diff_rot < self.rot_eps)

    def get_random_pose(self, env, obj_size):
        """Get random collision-free object pose within workspace bounds."""

        # Get erosion size of object in pixels.
        max_size = np.sqrt(obj_size[0] ** 2 + obj_size[1] ** 2)
        erode_size = int(np.round(max_size / self.pix_size))

        _, hmap, obj_mask = self.get_true_image(env)

        # Randomly sample an object pose within free-space pixels.
        free = np.ones(obj_mask.shape, dtype=np.uint8)
        for obj_ids in env.obj_ids.values():
            for obj_id in obj_ids:
                free[obj_mask == obj_id] = 0
        free[0, :], free[:, 0], free[-1, :], free[:, -1] = 0, 0, 0, 0
        free = cv2.erode(free, np.ones((erode_size, erode_size), np.uint8))

        # if np.sum(free) == 0:
        #     return None, None

        if np.sum(free) == 0:
            # avoid returning None, None
            # return None, None
            pix = (obj_mask.shape[0] // 2, obj_mask.shape[1] // 2)
        else:
            pix = utils.sample_distribution(np.float32(free))
        pos = utils.pix_to_xyz(pix, hmap, self.bounds, self.pix_size)
        pos = (pos[0], pos[1], obj_size[2] / 2)
        theta = np.random.rand() * 2 * np.pi
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta))
        return pos, rot

    def get_lang_goal(self):
        if len(self.lang_goals) == 0:
            return self.task_completed_desc
        else:
            return self.lang_goals[0]

    def get_reward(self):
        return float(self._rewards)

    # -------------------------------------------------------------------------
    # Helper Functions
    # -------------------------------------------------------------------------

    def fill_template(self, template, replace):
        """Read a file and replace key strings."""
        full_template_path = os.path.join(self.assets_root, template)
        with open(full_template_path, 'r') as file:
            fdata = file.read()
        for field in replace:
            for i in range(len(replace[field])):
                fdata = fdata.replace(f'{field}{i}', str(replace[field][i]))
        alphabet = string.ascii_lowercase + string.digits
        rname = ''.join(random.choices(alphabet, k=16))
        tmpdir = tempfile.gettempdir()
        template_filename = os.path.split(template)[-1]
        fname = os.path.join(tmpdir, f'{template_filename}.{rname}')
        with open(fname, 'w') as file:
            file.write(fdata)
        return fname

    def get_random_size(self, min_x, max_x, min_y, max_y, min_z, max_z):
        """Get random box size."""
        size = np.random.rand(3)
        size[0] = size[0] * (max_x - min_x) + min_x
        size[1] = size[1] * (max_y - min_y) + min_y
        size[2] = size[2] * (max_z - min_z) + min_z
        return tuple(size)

    def color_random_brown(self, obj):
        shade = np.random.rand() + 0.5
        color = np.float32([shade * 156, shade * 117, shade * 95, 255]) / 255
        p.changeVisualShape(obj, -1, rgbaColor=color)

  """""
  
  # Environment Class
  def add_object(self, urdf, pose, category='rigid'):
    """List of (fixed, rigid, or deformable) objects in env."""
    fixed_base = 1 if category == 'fixed' else 0
    obj_id = pybullet_utils.load_urdf(
        p,
        os.path.join(self.assets_root, urdf),
        pose[0],
        pose[1],
        useFixedBase=fixed_base)
    self.obj_ids[category].append(obj_id)
    return obj_id
"""

=========
Note that the objects need to obey physics and not collide with each other, and the object goal poses need to be above the table with lower bound x=0.25, y=-0.5 and upper bound x=0.75, y=0.5. When there are multiple objects for a multi-step pick-and-place task, there are often multiple subgoals. Once the task and environment are generated, an agent with a pick and place primitive will follow the defined goal to accomplish the tasks. 

Additionally, make sure you understand and summarize the ``self.goals`` variables, which has a list of 8-tuple with (objs, matches, targ_poses, replace, rotations, metric, params, step_max_reward, symmetries).
- objs (List of obj_id): object ID.
- matches (Binary Matrix): a binary matrix that denotes which object is matched with which target. This matrix has dimension len(objs) x len(targs).
- targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation). 
- replace (Boolean): whether each object can match with one unique target. This is important if we have one target and multiple objects. If it's set to be false, then any object matching with the target will satisfy.
- rotations (Boolean): whether the placement action has a rotation degree of freedom. 
- metric (`pose` or `zone`): `pose` or `zone` that the object needs to be transported to. Example: `pose`. 
- params (List of (zone_target, zone_size)): a list of (zone_target, zone_size) for each zone if the metric is `zone`. 
- step_max_reward (float): the total reward of matching all the objects with all the target poses. It is not dependent on the number of objects but dependent on the number of goals. 
- symmetries: the radians that the object is symmetric around z axis.
- language_goal: the low-level language instructions that denote the goal of this step.
 


>>> Answer: 
I understand the provided APIs and the structure of the `Task` class, as well as the `add_object` function in the environment class. Here's a summary of my understanding:

The `Task` class is a base class for defining robotic tasks in a simulation environment. It includes methods for resetting the task, providing an oracle (perfect agent) for demonstrations, calculating rewards, checking task completion, and various helper functions for interacting with the environment.

Key attributes and methods include:

- `ee`: The end effector used for the task (e.g., Suction).
- `mode`: The mode of the task, such as 'train'.
- `sixdof`: A boolean indicating if the task allows six degrees of freedom.
- `primitive`: The action primitive used for the task (e.g., PickPlace).
- `oracle_cams`: Configuration for oracle cameras.
- `pos_eps` and `rot_eps`: Positional and rotational thresholds for evaluating task success.
- `bounds`: Workspace bounds for the task.
- `zone_bounds`: Specific bounds for the placement zone.
- `goals`: A list of subgoals for the task, each represented as an 8-tuple.
- `lang_goals`: Language-based goals for the task.
- `progress`: A metric indicating task progression.
- `assets_root`: The root directory for task assets.

The `add_object` function in the environment class is used to add objects to the simulation. It takes the URDF file path, pose, and category of the object (e.g., 'rigid', 'fixed') and returns the object ID.

The `self.goals` variable is a list of subgoals for the task, where each subgoal is an 8-tuple containing:

- `objs`: A list of object IDs.
- `matches`: A binary matrix indicating potential matches between objects and target poses.
- `targ_poses`: A list of target poses, each with a translation and rotation.
- `replace`: A boolean indicating if objects can match with multiple targets or just one.
- `rotations`: A boolean indicating if the placement action includes rotation.
- `metric`: The evaluation metric, either 'pose' for specific poses or 'zone' for areas.
- `params`: Additional parameters, such as zone targets and sizes if the metric is 'zone'.
- `step_max_reward`: The maximum reward for completing the subgoal.
- `symmetries`: The symmetry of the objects around the z-axis in radians.
- `language_goal`: The language instruction describing the subgoal.

With this understanding, I can proceed to write the code for the "precision-placement-pyramid" task, ensuring that the objects obey physics, do not collide, and are placed within the specified bounds. The task will involve creating subgoals for stacking the cylinders in the correct order and position to form a pyramid.

================= Code Generation!

>>> Prompt: 
Now I will provide you some reference code and you can write the code for the task "precision-placement-pyramid".


"""
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class PackingShapes(Task):
    """pick up randomly sized shapes and place them tightly into a container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 1
        self.homogeneous = False

        self.lang_template = "pack the {obj} in the brown box"
        self.task_completed_desc = "done packing shapes."
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        # Shape Names:
        shapes = utils.assembling_kit_shapes

        n_objects = 5
        if self.mode == 'train':
            obj_shapes = np.random.choice(self.train_set, n_objects, replace=False)
        else:
            if self.homogeneous:
                obj_shapes = [np.random.choice(self.test_set, replace=False)] * n_objects
            else:
                obj_shapes = np.random.choice(self.test_set, n_objects, replace=False)

        # Shuffle colors to avoid always picking an object of the same color
        colors, color_names = utils.get_colors(mode=self.mode)

        # Add container box.
        zone_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, zone_pose, 'fixed')

        # Add objects.
        objects = []
        template = 'kitting/object-template.urdf'
        for i in range(n_objects):
            shape = obj_shapes[i]

            # x, y, z dimensions for the asset size
            size = (0.08, 0.08, 0.02)
            pose= self.get_random_pose(env, size)
            fname = f'{shape:02d}.obj'
            fname = os.path.join(self.assets_root, 'kitting', fname)
            scale = [0.003, 0.003, 0.001]  # .0005
            replace = {'FNAME': (fname,),
                       'SCALE': scale,
                       'COLOR': colors[i]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            block_id = env.add_object(urdf, pose)
            objects.append(block_id)

        # Pick the first shape.
        num_objects_to_pick = 1
        for i in range(num_objects_to_pick):
            # IMPORTANT: Specify (obj_pts, [(zone_pose, zone_size)]) for target `zone`. obj_pts is a dict
            language_goal = self.lang_template.format(obj=shapes[obj_shapes[i]])
            self.add_goal(objs=[objects[i]], matches=np.int32([[1]]), targ_poses=[zone_pose], replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1 / num_objects_to_pick,
                language_goal=language_goal)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PlaceRedInGreen(Task):
    """pick up the red blocks and place them into the green bowls amidst other objects."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = "put the red blocks in a green bowl"
        self.task_completed_desc = "done placing blocks in bowls."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_blocks = np.random.randint(1, n_bowls + 1)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, obj_size=bowl_size)
            env.add_object(urdf=bowl_urdf, pose=bowl_pose, category='fixed')
            bowl_poses.append(bowl_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        for _ in range(n_blocks):
            block_pose = self.get_random_pose(env, obj_size=block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Goal: each red block is in a different green bowl.
        self.add_goal(objs=blocks, matches=np.ones((len(blocks), len(bowl_poses))), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

        # Colors of distractor objects.
        bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'green']
        block_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'red']

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = block_colors if is_block else bowl_colors
            pose = self.get_random_pose(env, obj_size=size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1
"""
"""
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils


class SweepingPiles(Task):
    """Push piles of small objects into a target goal zone marked on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = "push the pile of blocks into the green square"
        self.task_completed_desc = "done sweeping."
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add goal zone.
        zone_size = (0.12, 0.12, 0)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add pile of small blocks with `make_piles` function
        obj_ids = self.make_piles(env)

        # Add goal
        self.add_goal(objs=obj_ids, matches=np.ones((50, 1)), targ_poses=[zone_pose], replace=True,
                rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class StackBlockPyramid(Task):
    """Build a pyramid of colored blocks in a color sequence"""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = "make the {row} row with {blocks}"
        self.task_completed_desc = "done stacking block pyramid."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['red']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, blue, purple).
        language_goal = self.lang_template.format(blocks="the green, blue and purple blocks", row="bottom")
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (middle row: yellow, orange).
        language_goal = self.lang_template.format(blocks="the yellow and orange blocks", row="middle")      
        self.add_goal(objs=objs[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (top row: red).
        language_goal = self.lang_template.format(blocks="the red block", row="top")
        self.add_goal(objs=objs[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2]*1, language_goal=language_goal)
"""



Do not use libraries, functions, and assets that you don't know. For each object, try to describe its color, size, category in the task first before you write the code. You do not need extra helper functions. Comment the code liberally to explain what each piece does and why it's written that way. If you have only one goal, `step_max_reward` in `add_goal` should be 1. Use functions `make_piles` and `make_ropes` for creating piles and cables. To use spatula together with the push primitives, import the libraries 
"""
from cliport.tasks import primitives;
from cliport.tasks.grippers import Spatula
"""
and then use `self.primitive = primitives.push` and `self.ee = Spatula`.
Note that the number of language goals usually match the number of motion goals, since they should correspond to each other.

Before generate code, you have a few considerations to focus on:
1. You are strictly prohibited from using function interfaces that do not appear in the above sample code. For example, the module cliport.tasks.primitives does not have pick_plack or place functions, only the push function interface is available.
2. Module 'cliport.tasks.primitives' has no attribute 'pick_place', you mustn't use it.
3. There are two types of your Gripper, one is Spatula and the other is Suction.You need to choose a different end-effector depending on your task requirements. If you need to move an object on the Z axis, then you need to use the Suction type. If you just need to translate an object in a 2D plane, then you can use either Spatula or Suction type.
4. You must determine the type of end-effector you need to use based on the type of task you have. You can choose by adding self.ee=Spatula or self.ee=Suction to the __init__(self) function, the default self.ee is Suction.
5. If you want to use Suction, you must import module using "from cliport.tasks.grippers import Suction". Else if you want to use Spatula, you must import module using "from cliport.tasks.grippers import Spatula".
6. The x-coordinate of the object is in the range [0.25, 0.75], the y-coordinate is in the range [-0.5,0.5] and the z-coordinate is in the range [0, 0.3].
7. The initial position of all objects needs to get its random initial position through the get_random_pose function.
8. The self.max_steps parameter value should be greater than the number of calls to self.add_goal, and preferably equal to twice the number of calls to self.add_goal. For example, if you call self.add_goal twice in one task, then self.max_steps is better set to 4.

If you want to generate the color of the object, you have to obey following rules:
1. You must use the utils.COLORS['COLOR_NAME'] function interface to generate an RGB three-channel value for a color.
2. The available colors for 'COLOR_NAME' are blue, red, green, orange, yellow, purple, pink, cyan, brown, white, gray, indigo, violet, black, silver and gold.
3. If you want to generate a red object, then its RGB three-channel color can be obtained through utils.COLORS['red'].
All object’s colors generation must follow color generation method above.

If you want to generate the target pose of the object(third parameter of function 'self.add_goal' targ_poses), you have to obey following rules:
1. The target pose of an object is represented by the three-dimensional spatial coordinates of the object and its orientation quaternion.
2. The target pose of an object must be represented by [(x,y,z),(q1,q2,q3,q4)]. Where (x,y,z) are the three-dimensional coordinates of the object and (q1,q2,q3,q4) denote the quaternions of the object's target pose.
3. The target pose of an object must be generated by you or use the initial pose of an object as the target pose of the current object.
4. Here's an example, to generate the target pose of a Y object, we have the initial pose information of an X object. So target pose of Y can be represented by pose_y=[(x,y,z),(q1,q2,q3,q4)] or pose_y=initial_pose_x.(Where x,y,z,q1,q2,q3,q4 are specific values.)
5. targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation).
6. The targ_poses you generate must contain translation[x,y,z], but rotation[q0,q1,q2,q3] you may or may not generate.
All object's target pose generation must follow method above.

Now write the code for the task "precision-placement-pyramid" in python code block starting with ```python.  Reminder: {'task-name': 'precision-placement-pyramid', 'task-description': 'Carefully place one red, one green, and one blue cylinder in a vertical arrangement to form a small pyramid within a demarcated zone on the tabletop, with the red cylinder at the base, green in the middle, and blue at the apex.', 'assets-used': ['cylinder/cylinder-template.urdf', 'zone/zone.urdf']} 


>>> Answer: 
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PrecisionPlacementPyramid(Task):
    """
    Carefully place one red, one green, and one blue cylinder in a vertical arrangement
    to form a small pyramid within a demarcated zone on the tabletop, with the red cylinder
    at the base, green in the middle, and blue at the apex.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice the number of goals
        self.lang_template = "place the {color} cylinder {position} in the pyramid"
        self.task_completed_desc = "done building the pyramid."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define cylinder size and colors
        cylinder_size = (0.04, 0.04, 0.12)  # Diameter, Diameter, Height
        cylinder_urdf = 'cylinder/cylinder-template.urdf'
        colors = {'red': utils.COLORS['red'], 'green': utils.COLORS['green'], 'blue': utils.COLORS['blue']}

        # Add goal zone
        zone_size = (0.15, 0.15, 0)  # Size of the zone where the pyramid will be built
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add cylinders and store their IDs
        cylinder_ids = {}
        for color_name, color_rgb in colors.items():
            # Get a random pose for the cylinder
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            # Replace the color in the URDF template
            replace = {'COLOR': color_rgb}
            # Fill the URDF template with the specific color
            urdf = self.fill_template(cylinder_urdf, replace)
            # Add the cylinder to the environment
            cylinder_id = env.add_object(urdf, cylinder_pose)
            cylinder_ids[color_name] = cylinder_id

        # Define the target poses for each cylinder in the pyramid
        base_height = cylinder_size[2] / 2
        second_height = cylinder_size[2] + base_height
        apex_height = cylinder_size[2] / 2 + second_height

        # Target poses are directly above the center of the zone, at the correct height for each layer
        target_poses = {
            'red': (zone_pose[0], (0, 0, base_height)),
            'green': (zone_pose[0], (0, 0, second_height)),
            'blue': (zone_pose[0], (0, 0, apex_height))
        }

        # Add goals for each cylinder
        for color, cylinder_id in cylinder_ids.items():
            # Language goal describes the color and position of the cylinder in the pyramid
            language_goal = self.lang_template.format(color=color, position="at the base" if color == 'red' else "in the middle" if color == 'green' else "at the apex")
            # Add the goal with the target pose and language goal
            self.add_goal(objs=[cylinder_id], matches=np.ones((1, 1)), targ_poses=[target_poses[color]],
                          replace=False, rotations=False, metric='pose', params=None, step_max_reward=1,
                          language_goal=language_goal)
```

This code defines a task where three colored cylinders must be placed in a specific order to form a pyramid within a designated zone. The `Suction` end-effector is used to move the cylinders vertically. The `zone` object defines the target area, and each cylinder's goal is added with a corresponding language goal that describes the task. The target poses for the cylinders are calculated based on the zone's pose and the cylinders' heights. The `add_goal` method is used to define the desired final state for each cylinder, with the `step_max_reward` set to 1 since there is only one goal for each cylinder.

================= TRIAL: 10

================= Task and Asset Design!

>>> Prompt: 
You are an AI in robot simulation code and task design. I will provide you some example tasks, code implementation, and some guidelines for how to generate tasks and then you will help me generate a new task. My goal is to design diverse and feasible tasks for tabletop manipulation. I will first ask you to describe the task in natural languages and then will let you write the code for it. 

=========
Here are all the assets. Use only these assets in the task and code design. 
"""
insertion/:
ell.urdf  fixture.urdf

bowl/:
bowl.urdf

box/:
box-template.urdf

stacking/:
block.urdf  stand.urdf

zone/:
zone.obj  zone.urdf

pallet/:
pallet.obj  pallet.urdf

ball/:
ball-template.urdf

cylinder/:
cylinder-template.urdf

bowl/:
bowl.urdf

# assets not for picking
corner/:
corner-template.urdf

line/:
single-green-line-template.urdf

container/:
container-template.urdf
"""
 
=========
Here are some examples of good tasks. Try to learn from these structures but avoid overlapping wiht them.

{"assets-used": ["zone/zone.urdf", "block/small.urdf"],
 "task-description": "Push piles of small objects into a target goal zone marked on the tabletop.",
 "task-name": "sweeping-piles"}

{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "Place all blocks of a specified color in a bowl of specified color.",
 "task-name": "put-block-in-bowl"}
 
{"assets-used": ["insertion/ell.urdf", "insertion/fixture.urdf"],
 "task-description": "pick up the L-shaped red block and place it into the L-shaped fixture.",
 "task-name": "block-insertion"}
 
{"assets-used": ["kitting/kit.urdf", "kitting/object-template.urdf"],
 "task-description": "pick up different objects and arrange them on a board marked with corresponding silhouettes.",
 "task-name": "assembling-kits"}
 
{"assets-used": ["pallet/pallet.urdf", "box/box-template.urdf"],
 "task-description": "pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.",
 "task-name": "palletizing-boxes"}
 
{"assets-used": ["stacking/stand.urdf", "stacking/block.urdf"],
 "task-description": "sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.",
 "task-name": "stack-block-pyramid"}
 
{"assets-used": ["container/container-template.urdf", "box/box-template.urdf"],
 "task-description": "pick up randomly sized boxes and place them tightly into a container.",
 "task-name": "packing-boxes"}
 
{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "pick up the red blocks and place them into the green bowls amidst other objects.",
 "task-name": "place-red-in-green"}
 
{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

=========
Here are some tasks that you have come up with before. Try to learn from these structures but avoid overlapping with these tasks. For instance, `bowl_ball_placement` and `sort_balls_in_bowls` are the same task. `pile_boxes_in_corner` and `stack_blocks_into_pallet` are similar tasks, `align-cylinder-in-corner` and `align-cylinder-corner` are similar.
- color-coded-pallet-organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}
- precision_box_placement: {'task-name': 'precision-box-placement', 'task-description': "Pick up a small blue box and place it precisely within the bounds of a marked white zone on a pallet, ensuring the box does not touch the zone's edges.", 'assets-used': ['box/box-template.urdf', 'zone/zone.urdf', 'pallet/pallet.urdf']}
- gradient_tower_placement: {'task-name': 'gradient-tower-placement', 'task-description': 'Build two separate towers each made of three differently colored cylinders, placing them on a patterned zone marked with two distinct areas, one for each tower, while ensuring that the cylinders in each tower are arranged in a color gradient sequence from the lightest on top to the darkest at the base.', 'assets-used': ['cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color_gradient_tower: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}





=========
Here are some bad example task instances with explanations.
{
    "task_name": "sort-color-blocks",
    "task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "box/box-template.urdf],
}
reasons: not interesting because it overlaps with the current task `put-block-in-bowl`.

{
    "task-name": "guided-ball-maze",
    "task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
    "assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
}
reasons: the language descriptions are too ambiguous. Navigation is also hard to complete. Also maze.urf does not exist.

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
}
reasons: this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere. Similarly tasks like `insert-ball-into-cylinder` and `cylinder-box-insertion` are invalid.

{
    "task-name": "ball-box-obstacle-course",
    "task-description": "Navigate a ball through an obstacle course created by randomly placed boxes and finally place it inside a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: Navigate the ball is not related to tabletop manipulation tasks.

{
    "task-name": "ball-in-box",
    "task-description": "Use a cable to guide a ball into an open box.",
    "assets-used": ["cable/cable.urdf", "ball/ball-template.urdf", "box/box-template.urdf"]
}
reasons: This task is too hard since it involves interaction of the cable and the ball and cannot be easily completed.

{
    "task-name": "ball-in-container",
    "task-description": "Use the spatula to lift a ball over a wall of boxes and drop it into a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: The only action primitives as pick and place. One cannot use a spatula to lift an object.

{
    "task-name": "line-ball-sorting",
    "task-description": "Move balls of different colors along a single green line, placing each ball in a designated colored box at the end of the line. The challenge includes precision in maintaining the ball on the line and the correct identification of the box color corresponding to each ball.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf"]
}
reasons: Piling or stacking balls are physically infeasible in the simulation.



=========
Now please describe the new task in natural languages and explain its novelty and challenges. Format the answer in a python dictionary with keys "task-name" and value type string, "task-description" (one specific sentence) and value type string, and "assets-used" and value type list of strings. Note that

- Do not use assets that are not in the list above. 
- Tasks that have more colors and shapes are interesting.
- Be as specific as possible about the number, shape, and color of each asset in the task descriptions. 
- The task need to obey physics and remain feasible.





>>> Answer: 
Here is a description of a new tabletop manipulation task:

```python
{
    "task-name": "bowl-cylinder-arrangement",
    "task-description": "Arrange six cylinders of varying colors inside a large bowl, ensuring that no two cylinders of the same color are adjacent to each other.",
    "assets-used": ["bowl/bowl.urdf", "cylinder/cylinder-template.urdf"]
}
```

Explanation of the task's novelty and challenges:

- **Novelty**: This task requires both color discrimination and spatial reasoning. The robot will have to identify the colors of the cylinders and place them in such a way that the same colors do not touch, which is unlike any of the example tasks provided.

- **Challenges**: 
  - The robot will need to recognize and track the colors of each cylinder and their positions relative to each other, which will require a vision system that can differentiate colors.
  - The placement of the cylinders within the bowl must be planned so as to avoid any two cylinders of the same color being next to each other, requiring a higher level of planning.
  - The task simulates a real-world scenario of arranging objects within confined spaces without violating specific constraints, which is a common challenge in robotics.

- **Physics and Feasibility**: 
  - The task is physically feasible as the bowl is large enough to contain multiple cylinders.
  - The robot will use standard pick-and-place manipulation strategies, which are typical for tabletop tasks.
  - Adjustments may be needed during the process as the cylinders are placed and the available space within the bowl changes.

This task can be further enhanced by adding constraints on the order of placement or integrating time constraints, but the current description provides a feasible and challenging scenario for a tabletop manipulation task.

================= API Preview!

>>> Prompt: 
Before writing the code for the task "bowl-cylinder-arrangement". Here are some APIs that are defined. Please confirm that you understand these APIs.

"""
class Task():
    """Base Task class."""

    def __init__(self):
        self.ee = Suction
        self.mode = 'train'
        self.sixdof = False
        self.primitive = primitives.PickPlace()
        self.oracle_cams = cameras.Oracle.CONFIG

        # Evaluation epsilons (for pose evaluation metric).
        self.pos_eps = 0.01
        self.rot_eps = np.deg2rad(15)

        # Workspace bounds.
        self.pix_size = 0.003125
        self.bounds = np.array([[0.25, 0.75], [-0.5, 0.5], [0, 0.3]])
        self.zone_bounds = np.copy(self.bounds)

        self.goals = []
        self.lang_goals = []
        self.task_completed_desc = "task completed."
        self.progress = 0
        self._rewards = 0
        self.assets_root = None

    def reset(self, env):
        if not self.assets_root:
            raise ValueError('assets_root must be set for task, '
                             'call set_assets_root().')
        self.goals = []
        self.lang_goals = []
        self.progress = 0  # Task progression metric in range [0, 1].
        self._rewards = 0  # Cumulative returned rewards.

    # -------------------------------------------------------------------------
    # Oracle Agent
    # -------------------------------------------------------------------------

    def oracle(self, env):
        """Oracle agent."""
        OracleAgent = collections.namedtuple('OracleAgent', ['act'])

        def act(obs, info):
            """Calculate action."""

            # Oracle uses perfect RGB-D orthographic images and segmentation masks.
            _, hmap, obj_mask = self.get_true_image(env)

            # Unpack next goal step.
            objs, matches, targs, replace, rotations, _, _, _ = self.goals[0]

            # Match objects to targets without replacement.
            if not replace:

                # Modify a copy of the match matrix.
                matches = matches.copy()

                # Ignore already matched objects.
                for i in range(len(objs)):
                    object_id, (symmetry, _) = objs[i]
                    pose = p.getBasePositionAndOrientation(object_id)
                    targets_i = np.argwhere(matches[i, :]).reshape(-1)
                    for j in targets_i:
                        if self.is_match(pose, targs[j], symmetry):
                            matches[i, :] = 0
                            matches[:, j] = 0

            # Get objects to be picked (prioritize farthest from nearest neighbor).
            nn_dists = []
            nn_targets = []
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                xyz, _ = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                if len(targets_i) > 0:
                    targets_xyz = np.float32([targs[j][0] for j in targets_i])
                    dists = np.linalg.norm(
                        targets_xyz - np.float32(xyz).reshape(1, 3), axis=1)
                    nn = np.argmin(dists)
                    nn_dists.append(dists[nn])
                    nn_targets.append(targets_i[nn])

                # Handle ignored objects.
                else:
                    nn_dists.append(0)
                    nn_targets.append(-1)
            order = np.argsort(nn_dists)[::-1]

            # Filter out matched objects.
            order = [i for i in order if nn_dists[i] > 0]

            pick_mask = None
            for pick_i in order:
                pick_mask = np.uint8(obj_mask == objs[pick_i][0])

                # Erode to avoid picking on edges.
                # pick_mask = cv2.erode(pick_mask, np.ones((3, 3), np.uint8))

                if np.sum(pick_mask) > 0:
                    break

            # Trigger task reset if no object is visible.
            if pick_mask is None or np.sum(pick_mask) == 0:
                self.goals = []
                self.lang_goals = []
                print('Object for pick is not visible. Skipping demonstration.')
                return

            # Get picking pose.
            pick_prob = np.float32(pick_mask)
            pick_pix = utils.sample_distribution(pick_prob)
            # For "deterministic" demonstrations on insertion-easy, use this:
            # pick_pix = (160,80)
            pick_pos = utils.pix_to_xyz(pick_pix, hmap,
                                        self.bounds, self.pix_size)
            pick_pose = (np.asarray(pick_pos), np.asarray((0, 0, 0, 1)))

            # Get placing pose.
            targ_pose = targs[nn_targets[pick_i]]
            obj_pose = p.getBasePositionAndOrientation(objs[pick_i][0])
            if not self.sixdof:
                obj_euler = utils.quatXYZW_to_eulerXYZ(obj_pose[1])
                obj_quat = utils.eulerXYZ_to_quatXYZW((0, 0, obj_euler[2]))
                obj_pose = (obj_pose[0], obj_quat)
            world_to_pick = utils.invert(pick_pose)
            obj_to_pick = utils.multiply(world_to_pick, obj_pose)
            pick_to_obj = utils.invert(obj_to_pick)
            place_pose = utils.multiply(targ_pose, pick_to_obj)

            # Rotate end effector?
            if not rotations:
                place_pose = (place_pose[0], (0, 0, 0, 1))

            place_pose = (np.asarray(place_pose[0]), np.asarray(place_pose[1]))

            return {'pose0': pick_pose, 'pose1': place_pose}

        return OracleAgent(act)

    # -------------------------------------------------------------------------
    # Reward Function and Task Completion Metrics
    # -------------------------------------------------------------------------

    def reward(self):
        """Get delta rewards for current timestep.

        Returns:
          A tuple consisting of the scalar (delta) reward, plus `extras`
            dict which has extra task-dependent info from the process of
            computing rewards that gives us finer-grained details. Use
            `extras` for further data analysis.
        """
        reward, info = 0, {}

        # Unpack next goal step.
        objs, matches, targs, _, _, metric, params, max_reward = self.goals[0]

        # Evaluate by matching object poses.
        if metric == 'pose':
            step_reward = 0
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                pose = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                for j in targets_i:
                    target_pose = targs[j]
                    if self.is_match(pose, target_pose, symmetry):
                        step_reward += max_reward / len(objs)
                        print(f"object {i} match with target {j} rew: {step_reward}")
                        break

        # Evaluate by measuring object intersection with zone.
        elif metric == 'zone':
            zone_pts, total_pts = 0, 0
            obj_pts, zones = params
            for zone_idx, (zone_pose, zone_size) in enumerate(zones):

                # Count valid points in zone.
                for obj_idx, obj_id in enumerate(obj_pts):
                    pts = obj_pts[obj_id]
                    obj_pose = p.getBasePositionAndOrientation(obj_id)
                    world_to_zone = utils.invert(zone_pose)
                    obj_to_zone = utils.multiply(world_to_zone, obj_pose)
                    pts = np.float32(utils.apply(obj_to_zone, pts))
                    if len(zone_size) > 1:
                        valid_pts = np.logical_and.reduce([
                            pts[0, :] > -zone_size[0] / 2, pts[0, :] < zone_size[0] / 2,
                            pts[1, :] > -zone_size[1] / 2, pts[1, :] < zone_size[1] / 2,
                            pts[2, :] < self.zone_bounds[2, 1]])

                    # if zone_idx == matches[obj_idx].argmax():
                    zone_pts += np.sum(np.float32(valid_pts))
                    total_pts += pts.shape[1]
            step_reward = max_reward * (zone_pts / total_pts)

        # Get cumulative rewards and return delta.
        reward = self.progress + step_reward - self._rewards
        self._rewards = self.progress + step_reward

        # Move to next goal step if current goal step is complete.
        if np.abs(max_reward - step_reward) < 0.01:
            self.progress += max_reward  # Update task progress.
            self.goals.pop(0)
            if len(self.lang_goals) > 0:
                self.lang_goals.pop(0)

        return reward, info

    def done(self):
        """Check if the task is done or has failed.

        Returns:
          True if the episode should be considered a success, which we
            use for measuring successes, which is particularly helpful for tasks
            where one may get successes on the very last time step, e.g., getting
            the cloth coverage threshold on the last alllowed action.
            However, for bag-items-easy and bag-items-hard (which use the
            'bag-items' metric), it may be necessary to filter out demos that did
            not attain sufficiently high reward in external code. Currently, this
            is done in `main.py` and its ignore_this_demo() method.
        """
        return (len(self.goals) == 0) or (self._rewards > 0.99)
        # return zone_done or defs_done or goal_done

    # -------------------------------------------------------------------------
    # Environment Helper Functions
    # -------------------------------------------------------------------------

    def is_match(self, pose0, pose1, symmetry):
        """Check if pose0 and pose1 match within a threshold."""

        # Get translational error.
        diff_pos = np.float32(pose0[0][:2]) - np.float32(pose1[0][:2])
        dist_pos = np.linalg.norm(diff_pos)

        # Get rotational error around z-axis (account for symmetries).
        diff_rot = 0
        if symmetry > 0:
            rot0 = np.array(utils.quatXYZW_to_eulerXYZ(pose0[1]))[2]
            rot1 = np.array(utils.quatXYZW_to_eulerXYZ(pose1[1]))[2]
            diff_rot = np.abs(rot0 - rot1) % symmetry
            if diff_rot > (symmetry / 2):
                diff_rot = symmetry - diff_rot

        return (dist_pos < self.pos_eps) and (diff_rot < self.rot_eps)

    def get_random_pose(self, env, obj_size):
        """Get random collision-free object pose within workspace bounds."""

        # Get erosion size of object in pixels.
        max_size = np.sqrt(obj_size[0] ** 2 + obj_size[1] ** 2)
        erode_size = int(np.round(max_size / self.pix_size))

        _, hmap, obj_mask = self.get_true_image(env)

        # Randomly sample an object pose within free-space pixels.
        free = np.ones(obj_mask.shape, dtype=np.uint8)
        for obj_ids in env.obj_ids.values():
            for obj_id in obj_ids:
                free[obj_mask == obj_id] = 0
        free[0, :], free[:, 0], free[-1, :], free[:, -1] = 0, 0, 0, 0
        free = cv2.erode(free, np.ones((erode_size, erode_size), np.uint8))

        # if np.sum(free) == 0:
        #     return None, None

        if np.sum(free) == 0:
            # avoid returning None, None
            # return None, None
            pix = (obj_mask.shape[0] // 2, obj_mask.shape[1] // 2)
        else:
            pix = utils.sample_distribution(np.float32(free))
        pos = utils.pix_to_xyz(pix, hmap, self.bounds, self.pix_size)
        pos = (pos[0], pos[1], obj_size[2] / 2)
        theta = np.random.rand() * 2 * np.pi
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta))
        return pos, rot

    def get_lang_goal(self):
        if len(self.lang_goals) == 0:
            return self.task_completed_desc
        else:
            return self.lang_goals[0]

    def get_reward(self):
        return float(self._rewards)

    # -------------------------------------------------------------------------
    # Helper Functions
    # -------------------------------------------------------------------------

    def fill_template(self, template, replace):
        """Read a file and replace key strings."""
        full_template_path = os.path.join(self.assets_root, template)
        with open(full_template_path, 'r') as file:
            fdata = file.read()
        for field in replace:
            for i in range(len(replace[field])):
                fdata = fdata.replace(f'{field}{i}', str(replace[field][i]))
        alphabet = string.ascii_lowercase + string.digits
        rname = ''.join(random.choices(alphabet, k=16))
        tmpdir = tempfile.gettempdir()
        template_filename = os.path.split(template)[-1]
        fname = os.path.join(tmpdir, f'{template_filename}.{rname}')
        with open(fname, 'w') as file:
            file.write(fdata)
        return fname

    def get_random_size(self, min_x, max_x, min_y, max_y, min_z, max_z):
        """Get random box size."""
        size = np.random.rand(3)
        size[0] = size[0] * (max_x - min_x) + min_x
        size[1] = size[1] * (max_y - min_y) + min_y
        size[2] = size[2] * (max_z - min_z) + min_z
        return tuple(size)

    def color_random_brown(self, obj):
        shade = np.random.rand() + 0.5
        color = np.float32([shade * 156, shade * 117, shade * 95, 255]) / 255
        p.changeVisualShape(obj, -1, rgbaColor=color)

  """""
  
  # Environment Class
  def add_object(self, urdf, pose, category='rigid'):
    """List of (fixed, rigid, or deformable) objects in env."""
    fixed_base = 1 if category == 'fixed' else 0
    obj_id = pybullet_utils.load_urdf(
        p,
        os.path.join(self.assets_root, urdf),
        pose[0],
        pose[1],
        useFixedBase=fixed_base)
    self.obj_ids[category].append(obj_id)
    return obj_id
"""

=========
Note that the objects need to obey physics and not collide with each other, and the object goal poses need to be above the table with lower bound x=0.25, y=-0.5 and upper bound x=0.75, y=0.5. When there are multiple objects for a multi-step pick-and-place task, there are often multiple subgoals. Once the task and environment are generated, an agent with a pick and place primitive will follow the defined goal to accomplish the tasks. 

Additionally, make sure you understand and summarize the ``self.goals`` variables, which has a list of 8-tuple with (objs, matches, targ_poses, replace, rotations, metric, params, step_max_reward, symmetries).
- objs (List of obj_id): object ID.
- matches (Binary Matrix): a binary matrix that denotes which object is matched with which target. This matrix has dimension len(objs) x len(targs).
- targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation). 
- replace (Boolean): whether each object can match with one unique target. This is important if we have one target and multiple objects. If it's set to be false, then any object matching with the target will satisfy.
- rotations (Boolean): whether the placement action has a rotation degree of freedom. 
- metric (`pose` or `zone`): `pose` or `zone` that the object needs to be transported to. Example: `pose`. 
- params (List of (zone_target, zone_size)): a list of (zone_target, zone_size) for each zone if the metric is `zone`. 
- step_max_reward (float): the total reward of matching all the objects with all the target poses. It is not dependent on the number of objects but dependent on the number of goals. 
- symmetries: the radians that the object is symmetric around z axis.
- language_goal: the low-level language instructions that denote the goal of this step.
 


>>> Answer: 
I understand the provided APIs and the structure of the `Task` class, as well as the environment class method `add_object`. Here's a summary of my understanding:

### Task Class
The `Task` class is a base class for defining robotic tasks in a simulation environment. It includes methods for resetting the task, providing an oracle (perfect knowledge) agent for demonstrations, calculating rewards, checking task completion, and various helper functions for interacting with the environment.

Key attributes and methods include:
- `ee`: The end effector used for the task (e.g., `Suction`).
- `mode`: The mode of the task, such as 'train'.
- `sixdof`: A boolean indicating if the task allows six degrees of freedom.
- `primitive`: The action primitive used for the task (e.g., `PickPlace`).
- `oracle_cams`: Configuration for oracle cameras.
- `bounds`: The workspace bounds within which the task must be completed.
- `goals`: A list of subgoals for the task, each described by an 8-tuple.
- `reset(env)`: Resets the task environment.
- `oracle(env)`: Provides an oracle agent for the task.
- `reward()`: Calculates the reward for the current timestep.
- `done()`: Checks if the task is completed or has failed.
- `is_match(pose0, pose1, symmetry)`: Checks if two poses match within a threshold.
- `get_random_pose(env, obj_size)`: Gets a random collision-free object pose within workspace bounds.
- `fill_template(template, replace)`: Fills a template file with specified values.
- `get_random_size(min_x, max_x, min_y, max_y, min_z, max_z)`: Gets a random object size within specified bounds.
- `color_random_brown(obj)`: Colors an object with a random shade of brown.

### Environment Class Method
- `add_object(urdf, pose, category)`: Adds an object to the environment with the specified URDF file, pose, and category (e.g., 'rigid').

### `self.goals` Variable
The `self.goals` variable is a list of subgoals for the task, where each subgoal is an 8-tuple containing the following elements:
- `objs`: A list of object IDs.
- `matches`: A binary matrix indicating which objects are matched with which targets.
- `targ_poses`: A list of target poses, each a tuple of translation and rotation.
- `replace`: A boolean indicating if objects can match with one unique target.
- `rotations`: A boolean indicating if the placement action includes rotation.
- `metric`: The metric used for the task ('pose' or 'zone').
- `params`: Additional parameters for the task, such as zone targets and sizes if the metric is 'zone'.
- `step_max_reward`: The total reward for matching all objects with all target poses.
- `symmetries`: The radians of symmetry around the z-axis for the objects.
- `language_goal`: Low-level language instructions that denote the goal of the current step.

Understanding these APIs and the structure of the `Task` class is crucial for implementing the "bowl-cylinder-arrangement" task, as it will involve setting up the environment, defining the subgoals, and ensuring that the task's constraints are met by the agent's actions.

================= Code Generation!

>>> Prompt: 
Now I will provide you some reference code and you can write the code for the task "bowl-cylinder-arrangement".


"""
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class PackingShapes(Task):
    """pick up randomly sized shapes and place them tightly into a container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 1
        self.homogeneous = False

        self.lang_template = "pack the {obj} in the brown box"
        self.task_completed_desc = "done packing shapes."
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        # Shape Names:
        shapes = utils.assembling_kit_shapes

        n_objects = 5
        if self.mode == 'train':
            obj_shapes = np.random.choice(self.train_set, n_objects, replace=False)
        else:
            if self.homogeneous:
                obj_shapes = [np.random.choice(self.test_set, replace=False)] * n_objects
            else:
                obj_shapes = np.random.choice(self.test_set, n_objects, replace=False)

        # Shuffle colors to avoid always picking an object of the same color
        colors, color_names = utils.get_colors(mode=self.mode)

        # Add container box.
        zone_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, zone_pose, 'fixed')

        # Add objects.
        objects = []
        template = 'kitting/object-template.urdf'
        for i in range(n_objects):
            shape = obj_shapes[i]

            # x, y, z dimensions for the asset size
            size = (0.08, 0.08, 0.02)
            pose= self.get_random_pose(env, size)
            fname = f'{shape:02d}.obj'
            fname = os.path.join(self.assets_root, 'kitting', fname)
            scale = [0.003, 0.003, 0.001]  # .0005
            replace = {'FNAME': (fname,),
                       'SCALE': scale,
                       'COLOR': colors[i]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            block_id = env.add_object(urdf, pose)
            objects.append(block_id)

        # Pick the first shape.
        num_objects_to_pick = 1
        for i in range(num_objects_to_pick):
            # IMPORTANT: Specify (obj_pts, [(zone_pose, zone_size)]) for target `zone`. obj_pts is a dict
            language_goal = self.lang_template.format(obj=shapes[obj_shapes[i]])
            self.add_goal(objs=[objects[i]], matches=np.int32([[1]]), targ_poses=[zone_pose], replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1 / num_objects_to_pick,
                language_goal=language_goal)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PlaceRedInGreen(Task):
    """pick up the red blocks and place them into the green bowls amidst other objects."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = "put the red blocks in a green bowl"
        self.task_completed_desc = "done placing blocks in bowls."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_blocks = np.random.randint(1, n_bowls + 1)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, obj_size=bowl_size)
            env.add_object(urdf=bowl_urdf, pose=bowl_pose, category='fixed')
            bowl_poses.append(bowl_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        for _ in range(n_blocks):
            block_pose = self.get_random_pose(env, obj_size=block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Goal: each red block is in a different green bowl.
        self.add_goal(objs=blocks, matches=np.ones((len(blocks), len(bowl_poses))), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

        # Colors of distractor objects.
        bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'green']
        block_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'red']

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = block_colors if is_block else bowl_colors
            pose = self.get_random_pose(env, obj_size=size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1
"""
"""
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils


class SweepingPiles(Task):
    """Push piles of small objects into a target goal zone marked on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = "push the pile of blocks into the green square"
        self.task_completed_desc = "done sweeping."
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add goal zone.
        zone_size = (0.12, 0.12, 0)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add pile of small blocks with `make_piles` function
        obj_ids = self.make_piles(env)

        # Add goal
        self.add_goal(objs=obj_ids, matches=np.ones((50, 1)), targ_poses=[zone_pose], replace=True,
                rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class StackBlockPyramid(Task):
    """Build a pyramid of colored blocks in a color sequence"""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = "make the {row} row with {blocks}"
        self.task_completed_desc = "done stacking block pyramid."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['red']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, blue, purple).
        language_goal = self.lang_template.format(blocks="the green, blue and purple blocks", row="bottom")
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (middle row: yellow, orange).
        language_goal = self.lang_template.format(blocks="the yellow and orange blocks", row="middle")      
        self.add_goal(objs=objs[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (top row: red).
        language_goal = self.lang_template.format(blocks="the red block", row="top")
        self.add_goal(objs=objs[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2]*1, language_goal=language_goal)
"""



Do not use libraries, functions, and assets that you don't know. For each object, try to describe its color, size, category in the task first before you write the code. You do not need extra helper functions. Comment the code liberally to explain what each piece does and why it's written that way. If you have only one goal, `step_max_reward` in `add_goal` should be 1. Use functions `make_piles` and `make_ropes` for creating piles and cables. To use spatula together with the push primitives, import the libraries 
"""
from cliport.tasks import primitives;
from cliport.tasks.grippers import Spatula
"""
and then use `self.primitive = primitives.push` and `self.ee = Spatula`.
Note that the number of language goals usually match the number of motion goals, since they should correspond to each other.

Before generate code, you have a few considerations to focus on:
1. You are strictly prohibited from using function interfaces that do not appear in the above sample code. For example, the module cliport.tasks.primitives does not have pick_plack or place functions, only the push function interface is available.
2. Module 'cliport.tasks.primitives' has no attribute 'pick_place', you mustn't use it.
3. There are two types of your Gripper, one is Spatula and the other is Suction.You need to choose a different end-effector depending on your task requirements. If you need to move an object on the Z axis, then you need to use the Suction type. If you just need to translate an object in a 2D plane, then you can use either Spatula or Suction type.
4. You must determine the type of end-effector you need to use based on the type of task you have. You can choose by adding self.ee=Spatula or self.ee=Suction to the __init__(self) function, the default self.ee is Suction.
5. If you want to use Suction, you must import module using "from cliport.tasks.grippers import Suction". Else if you want to use Spatula, you must import module using "from cliport.tasks.grippers import Spatula".
6. The x-coordinate of the object is in the range [0.25, 0.75], the y-coordinate is in the range [-0.5,0.5] and the z-coordinate is in the range [0, 0.3].
7. The initial position of all objects needs to get its random initial position through the get_random_pose function.
8. The self.max_steps parameter value should be greater than the number of calls to self.add_goal, and preferably equal to twice the number of calls to self.add_goal. For example, if you call self.add_goal twice in one task, then self.max_steps is better set to 4.

If you want to generate the color of the object, you have to obey following rules:
1. You must use the utils.COLORS['COLOR_NAME'] function interface to generate an RGB three-channel value for a color.
2. The available colors for 'COLOR_NAME' are blue, red, green, orange, yellow, purple, pink, cyan, brown, white, gray, indigo, violet, black, silver and gold.
3. If you want to generate a red object, then its RGB three-channel color can be obtained through utils.COLORS['red'].
All object’s colors generation must follow color generation method above.

If you want to generate the target pose of the object(third parameter of function 'self.add_goal' targ_poses), you have to obey following rules:
1. The target pose of an object is represented by the three-dimensional spatial coordinates of the object and its orientation quaternion.
2. The target pose of an object must be represented by [(x,y,z),(q1,q2,q3,q4)]. Where (x,y,z) are the three-dimensional coordinates of the object and (q1,q2,q3,q4) denote the quaternions of the object's target pose.
3. The target pose of an object must be generated by you or use the initial pose of an object as the target pose of the current object.
4. Here's an example, to generate the target pose of a Y object, we have the initial pose information of an X object. So target pose of Y can be represented by pose_y=[(x,y,z),(q1,q2,q3,q4)] or pose_y=initial_pose_x.(Where x,y,z,q1,q2,q3,q4 are specific values.)
5. targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation).
6. The targ_poses you generate must contain translation[x,y,z], but rotation[q0,q1,q2,q3] you may or may not generate.
All object's target pose generation must follow method above.

Now write the code for the task "bowl-cylinder-arrangement" in python code block starting with ```python.  Reminder: {'task-name': 'bowl-cylinder-arrangement', 'task-description': 'Arrange six cylinders of varying colors inside a large bowl, ensuring that no two cylinders of the same color are adjacent to each other.', 'assets-used': ['bowl/bowl.urdf', 'cylinder/cylinder-template.urdf']} 


>>> Answer: 
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BowlCylinderArrangement(Task):
    """
    Arrange six cylinders of varying colors inside a large bowl, ensuring that no two cylinders of the same color are adjacent to each other.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 12  # We expect to arrange 6 cylinders, so max_steps is set to twice that number
        self.lang_template = "put a {color} cylinder in the bowl without placing it next to another {color} cylinder"
        self.task_completed_desc = "done arranging cylinders in the bowl."
        self.ee = Suction  # Using Suction end-effector to pick and place cylinders

    def reset(self, env):
        super().reset(env)

        # Add a large bowl to the environment
        bowl_size = (0.18, 0.18, 0.06)  # Size of the bowl (x, y, z)
        bowl_pose = self.get_random_pose(env, bowl_size)  # Random pose for the bowl
        bowl_urdf = 'bowl/bowl.urdf'
        env.add_object(bowl_urdf, bowl_pose, 'fixed')  # Add bowl as a fixed object

        # Define colors for the cylinders
        colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange']
        color_rgb = [utils.COLORS[color] for color in colors]  # Get RGB values for the colors

        # Add six cylinders with varying colors to the environment
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_size = (0.05, 0.05, 0.1)  # Size of the cylinders (x, y, z)
        cylinders = []
        for i, color in enumerate(colors):
            # Get a random pose for the cylinder
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            # Fill the URDF template with the specific color and size for the cylinder
            replace = {'COLOR': color_rgb[i], 'SIZE': cylinder_size}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder to the environment and store its ID
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            cylinders.append(cylinder_id)

        # Define the goal for the task
        # Each cylinder must be placed in the bowl without adjacent cylinders having the same color
        for i, cylinder_id in enumerate(cylinders):
            # Define the language goal for placing this cylinder
            language_goal = self.lang_template.format(color=colors[i])
            # Add the goal for this cylinder
            self.add_goal(objs=[cylinder_id], matches=np.ones((1, 1)), targ_poses=[bowl_pose], replace=True,
                          rotations=False, metric='zone', params=[(bowl_pose, bowl_size)], step_max_reward=1/6,
                          language_goal=language_goal)

        # Note: The task does not enforce the adjacency constraint in the code.
        # This constraint will need to be handled by the agent's policy or reward function.
```

This code defines a task where six cylinders of different colors must be arranged inside a bowl. The `BowlCylinderArrangement` class inherits from the `Task` class and sets up the environment by adding a bowl and six cylinders. Each cylinder is assigned a unique color and a goal is added for each cylinder to be placed in the bowl. The `Suction` end-effector is used to pick and place the cylinders. The language goals are defined for each cylinder placement, and the `step_max_reward` is divided equally among the six goals. The adjacency constraint mentioned in the task description is not enforced in the code and would need to be considered in the agent's policy or reward function.

================= TRIAL: 11

================= Task and Asset Design!

>>> Prompt: 
You are an AI in robot simulation code and task design. I will provide you some example tasks, code implementation, and some guidelines for how to generate tasks and then you will help me generate a new task. My goal is to design diverse and feasible tasks for tabletop manipulation. I will first ask you to describe the task in natural languages and then will let you write the code for it. 

=========
Here are all the assets. Use only these assets in the task and code design. 
"""
insertion/:
ell.urdf  fixture.urdf

bowl/:
bowl.urdf

box/:
box-template.urdf

stacking/:
block.urdf  stand.urdf

zone/:
zone.obj  zone.urdf

pallet/:
pallet.obj  pallet.urdf

ball/:
ball-template.urdf

cylinder/:
cylinder-template.urdf

bowl/:
bowl.urdf

# assets not for picking
corner/:
corner-template.urdf

line/:
single-green-line-template.urdf

container/:
container-template.urdf
"""
 
=========
Here are some examples of good tasks. Try to learn from these structures but avoid overlapping wiht them.

{"assets-used": ["zone/zone.urdf", "block/small.urdf"],
 "task-description": "Push piles of small objects into a target goal zone marked on the tabletop.",
 "task-name": "sweeping-piles"}

{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "Place all blocks of a specified color in a bowl of specified color.",
 "task-name": "put-block-in-bowl"}
 
{"assets-used": ["insertion/ell.urdf", "insertion/fixture.urdf"],
 "task-description": "pick up the L-shaped red block and place it into the L-shaped fixture.",
 "task-name": "block-insertion"}
 
{"assets-used": ["kitting/kit.urdf", "kitting/object-template.urdf"],
 "task-description": "pick up different objects and arrange them on a board marked with corresponding silhouettes.",
 "task-name": "assembling-kits"}
 
{"assets-used": ["pallet/pallet.urdf", "box/box-template.urdf"],
 "task-description": "pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.",
 "task-name": "palletizing-boxes"}
 
{"assets-used": ["stacking/stand.urdf", "stacking/block.urdf"],
 "task-description": "sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.",
 "task-name": "stack-block-pyramid"}
 
{"assets-used": ["container/container-template.urdf", "box/box-template.urdf"],
 "task-description": "pick up randomly sized boxes and place them tightly into a container.",
 "task-name": "packing-boxes"}
 
{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "pick up the red blocks and place them into the green bowls amidst other objects.",
 "task-name": "place-red-in-green"}
 
{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

=========
Here are some tasks that you have come up with before. Try to learn from these structures but avoid overlapping with these tasks. For instance, `bowl_ball_placement` and `sort_balls_in_bowls` are the same task. `pile_boxes_in_corner` and `stack_blocks_into_pallet` are similar tasks, `align-cylinder-in-corner` and `align-cylinder-corner` are similar.
- cylinder-tower-balancing: {'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- color-gradient-tower: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color-coded-pallet-organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}
- gradient_tower_placement: {'task-name': 'gradient-tower-placement', 'task-description': 'Build two separate towers each made of three differently colored cylinders, placing them on a patterned zone marked with two distinct areas, one for each tower, while ensuring that the cylinders in each tower are arranged in a color gradient sequence from the lightest on top to the darkest at the base.', 'assets-used': ['cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color_coded_pallet_organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}





=========
Here are some bad example task instances with explanations.
{
    "task_name": "sort-color-blocks",
    "task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "box/box-template.urdf],
}
reasons: not interesting because it overlaps with the current task `put-block-in-bowl`.

{
    "task-name": "guided-ball-maze",
    "task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
    "assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
}
reasons: the language descriptions are too ambiguous. Navigation is also hard to complete. Also maze.urf does not exist.

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
}
reasons: this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere. Similarly tasks like `insert-ball-into-cylinder` and `cylinder-box-insertion` are invalid.

{
    "task-name": "ball-box-obstacle-course",
    "task-description": "Navigate a ball through an obstacle course created by randomly placed boxes and finally place it inside a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: Navigate the ball is not related to tabletop manipulation tasks.

{
    "task-name": "ball-in-box",
    "task-description": "Use a cable to guide a ball into an open box.",
    "assets-used": ["cable/cable.urdf", "ball/ball-template.urdf", "box/box-template.urdf"]
}
reasons: This task is too hard since it involves interaction of the cable and the ball and cannot be easily completed.

{
    "task-name": "ball-in-container",
    "task-description": "Use the spatula to lift a ball over a wall of boxes and drop it into a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: The only action primitives as pick and place. One cannot use a spatula to lift an object.

{
    "task-name": "line-ball-sorting",
    "task-description": "Move balls of different colors along a single green line, placing each ball in a designated colored box at the end of the line. The challenge includes precision in maintaining the ball on the line and the correct identification of the box color corresponding to each ball.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf"]
}
reasons: Piling or stacking balls are physically infeasible in the simulation.



=========
Now please describe the new task in natural languages and explain its novelty and challenges. Format the answer in a python dictionary with keys "task-name" and value type string, "task-description" (one specific sentence) and value type string, and "assets-used" and value type list of strings. Note that

- Do not use assets that are not in the list above. 
- Tasks that have more colors and shapes are interesting.
- Be as specific as possible about the number, shape, and color of each asset in the task descriptions. 
- The task need to obey physics and remain feasible.





>>> Answer: 
Based on the provided assets and guidelines, here is a new task for tabletop manipulation:

```python
{
    "task-name": "precision-cylinder-alignment",
    "task-description": "Arrange three cylinders of distinct colors in a precise linear formation within a narrow marked zone on the tabletop, with the smallest cylinder in the center and the larger ones at the ends, without any part of the cylinders overlapping or extending beyond the zone boundaries.",
    "assets-used": ["cylinder/cylinder-template.urdf", "line/single-green-line-template.urdf", "zone/zone.urdf"]
}
```

Explanation of novelty and challenges:
- **Novelty**: This task introduces the challenge of arranging objects (cylinders) in a straight line, which requires high precision in manipulation. The requirement to place the smallest cylinder in the center adds to the complexity due to its smaller size and increased difficulty to align precisely.
- **Challenges**:
  - Precise manipulation is required to align the cylinders in a straight line.
  - Spatial reasoning is needed to ensure the correct order of the cylinders by size and to prevent overlap.
  - The task requires careful movement to avoid having the cylinders extend beyond the narrow marked zone, which could lead to failure.
  - Color recognition is also needed to identify the correct cylinders, making the task visually interesting and adding to the cognitive load.

================= API Preview!

>>> Prompt: 
Before writing the code for the task "precision-cylinder-alignment". Here are some APIs that are defined. Please confirm that you understand these APIs.

"""
class Task():
    """Base Task class."""

    def __init__(self):
        self.ee = Suction
        self.mode = 'train'
        self.sixdof = False
        self.primitive = primitives.PickPlace()
        self.oracle_cams = cameras.Oracle.CONFIG

        # Evaluation epsilons (for pose evaluation metric).
        self.pos_eps = 0.01
        self.rot_eps = np.deg2rad(15)

        # Workspace bounds.
        self.pix_size = 0.003125
        self.bounds = np.array([[0.25, 0.75], [-0.5, 0.5], [0, 0.3]])
        self.zone_bounds = np.copy(self.bounds)

        self.goals = []
        self.lang_goals = []
        self.task_completed_desc = "task completed."
        self.progress = 0
        self._rewards = 0
        self.assets_root = None

    def reset(self, env):
        if not self.assets_root:
            raise ValueError('assets_root must be set for task, '
                             'call set_assets_root().')
        self.goals = []
        self.lang_goals = []
        self.progress = 0  # Task progression metric in range [0, 1].
        self._rewards = 0  # Cumulative returned rewards.

    # -------------------------------------------------------------------------
    # Oracle Agent
    # -------------------------------------------------------------------------

    def oracle(self, env):
        """Oracle agent."""
        OracleAgent = collections.namedtuple('OracleAgent', ['act'])

        def act(obs, info):
            """Calculate action."""

            # Oracle uses perfect RGB-D orthographic images and segmentation masks.
            _, hmap, obj_mask = self.get_true_image(env)

            # Unpack next goal step.
            objs, matches, targs, replace, rotations, _, _, _ = self.goals[0]

            # Match objects to targets without replacement.
            if not replace:

                # Modify a copy of the match matrix.
                matches = matches.copy()

                # Ignore already matched objects.
                for i in range(len(objs)):
                    object_id, (symmetry, _) = objs[i]
                    pose = p.getBasePositionAndOrientation(object_id)
                    targets_i = np.argwhere(matches[i, :]).reshape(-1)
                    for j in targets_i:
                        if self.is_match(pose, targs[j], symmetry):
                            matches[i, :] = 0
                            matches[:, j] = 0

            # Get objects to be picked (prioritize farthest from nearest neighbor).
            nn_dists = []
            nn_targets = []
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                xyz, _ = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                if len(targets_i) > 0:
                    targets_xyz = np.float32([targs[j][0] for j in targets_i])
                    dists = np.linalg.norm(
                        targets_xyz - np.float32(xyz).reshape(1, 3), axis=1)
                    nn = np.argmin(dists)
                    nn_dists.append(dists[nn])
                    nn_targets.append(targets_i[nn])

                # Handle ignored objects.
                else:
                    nn_dists.append(0)
                    nn_targets.append(-1)
            order = np.argsort(nn_dists)[::-1]

            # Filter out matched objects.
            order = [i for i in order if nn_dists[i] > 0]

            pick_mask = None
            for pick_i in order:
                pick_mask = np.uint8(obj_mask == objs[pick_i][0])

                # Erode to avoid picking on edges.
                # pick_mask = cv2.erode(pick_mask, np.ones((3, 3), np.uint8))

                if np.sum(pick_mask) > 0:
                    break

            # Trigger task reset if no object is visible.
            if pick_mask is None or np.sum(pick_mask) == 0:
                self.goals = []
                self.lang_goals = []
                print('Object for pick is not visible. Skipping demonstration.')
                return

            # Get picking pose.
            pick_prob = np.float32(pick_mask)
            pick_pix = utils.sample_distribution(pick_prob)
            # For "deterministic" demonstrations on insertion-easy, use this:
            # pick_pix = (160,80)
            pick_pos = utils.pix_to_xyz(pick_pix, hmap,
                                        self.bounds, self.pix_size)
            pick_pose = (np.asarray(pick_pos), np.asarray((0, 0, 0, 1)))

            # Get placing pose.
            targ_pose = targs[nn_targets[pick_i]]
            obj_pose = p.getBasePositionAndOrientation(objs[pick_i][0])
            if not self.sixdof:
                obj_euler = utils.quatXYZW_to_eulerXYZ(obj_pose[1])
                obj_quat = utils.eulerXYZ_to_quatXYZW((0, 0, obj_euler[2]))
                obj_pose = (obj_pose[0], obj_quat)
            world_to_pick = utils.invert(pick_pose)
            obj_to_pick = utils.multiply(world_to_pick, obj_pose)
            pick_to_obj = utils.invert(obj_to_pick)
            place_pose = utils.multiply(targ_pose, pick_to_obj)

            # Rotate end effector?
            if not rotations:
                place_pose = (place_pose[0], (0, 0, 0, 1))

            place_pose = (np.asarray(place_pose[0]), np.asarray(place_pose[1]))

            return {'pose0': pick_pose, 'pose1': place_pose}

        return OracleAgent(act)

    # -------------------------------------------------------------------------
    # Reward Function and Task Completion Metrics
    # -------------------------------------------------------------------------

    def reward(self):
        """Get delta rewards for current timestep.

        Returns:
          A tuple consisting of the scalar (delta) reward, plus `extras`
            dict which has extra task-dependent info from the process of
            computing rewards that gives us finer-grained details. Use
            `extras` for further data analysis.
        """
        reward, info = 0, {}

        # Unpack next goal step.
        objs, matches, targs, _, _, metric, params, max_reward = self.goals[0]

        # Evaluate by matching object poses.
        if metric == 'pose':
            step_reward = 0
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                pose = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                for j in targets_i:
                    target_pose = targs[j]
                    if self.is_match(pose, target_pose, symmetry):
                        step_reward += max_reward / len(objs)
                        print(f"object {i} match with target {j} rew: {step_reward}")
                        break

        # Evaluate by measuring object intersection with zone.
        elif metric == 'zone':
            zone_pts, total_pts = 0, 0
            obj_pts, zones = params
            for zone_idx, (zone_pose, zone_size) in enumerate(zones):

                # Count valid points in zone.
                for obj_idx, obj_id in enumerate(obj_pts):
                    pts = obj_pts[obj_id]
                    obj_pose = p.getBasePositionAndOrientation(obj_id)
                    world_to_zone = utils.invert(zone_pose)
                    obj_to_zone = utils.multiply(world_to_zone, obj_pose)
                    pts = np.float32(utils.apply(obj_to_zone, pts))
                    if len(zone_size) > 1:
                        valid_pts = np.logical_and.reduce([
                            pts[0, :] > -zone_size[0] / 2, pts[0, :] < zone_size[0] / 2,
                            pts[1, :] > -zone_size[1] / 2, pts[1, :] < zone_size[1] / 2,
                            pts[2, :] < self.zone_bounds[2, 1]])

                    # if zone_idx == matches[obj_idx].argmax():
                    zone_pts += np.sum(np.float32(valid_pts))
                    total_pts += pts.shape[1]
            step_reward = max_reward * (zone_pts / total_pts)

        # Get cumulative rewards and return delta.
        reward = self.progress + step_reward - self._rewards
        self._rewards = self.progress + step_reward

        # Move to next goal step if current goal step is complete.
        if np.abs(max_reward - step_reward) < 0.01:
            self.progress += max_reward  # Update task progress.
            self.goals.pop(0)
            if len(self.lang_goals) > 0:
                self.lang_goals.pop(0)

        return reward, info

    def done(self):
        """Check if the task is done or has failed.

        Returns:
          True if the episode should be considered a success, which we
            use for measuring successes, which is particularly helpful for tasks
            where one may get successes on the very last time step, e.g., getting
            the cloth coverage threshold on the last alllowed action.
            However, for bag-items-easy and bag-items-hard (which use the
            'bag-items' metric), it may be necessary to filter out demos that did
            not attain sufficiently high reward in external code. Currently, this
            is done in `main.py` and its ignore_this_demo() method.
        """
        return (len(self.goals) == 0) or (self._rewards > 0.99)
        # return zone_done or defs_done or goal_done

    # -------------------------------------------------------------------------
    # Environment Helper Functions
    # -------------------------------------------------------------------------

    def is_match(self, pose0, pose1, symmetry):
        """Check if pose0 and pose1 match within a threshold."""

        # Get translational error.
        diff_pos = np.float32(pose0[0][:2]) - np.float32(pose1[0][:2])
        dist_pos = np.linalg.norm(diff_pos)

        # Get rotational error around z-axis (account for symmetries).
        diff_rot = 0
        if symmetry > 0:
            rot0 = np.array(utils.quatXYZW_to_eulerXYZ(pose0[1]))[2]
            rot1 = np.array(utils.quatXYZW_to_eulerXYZ(pose1[1]))[2]
            diff_rot = np.abs(rot0 - rot1) % symmetry
            if diff_rot > (symmetry / 2):
                diff_rot = symmetry - diff_rot

        return (dist_pos < self.pos_eps) and (diff_rot < self.rot_eps)

    def get_random_pose(self, env, obj_size):
        """Get random collision-free object pose within workspace bounds."""

        # Get erosion size of object in pixels.
        max_size = np.sqrt(obj_size[0] ** 2 + obj_size[1] ** 2)
        erode_size = int(np.round(max_size / self.pix_size))

        _, hmap, obj_mask = self.get_true_image(env)

        # Randomly sample an object pose within free-space pixels.
        free = np.ones(obj_mask.shape, dtype=np.uint8)
        for obj_ids in env.obj_ids.values():
            for obj_id in obj_ids:
                free[obj_mask == obj_id] = 0
        free[0, :], free[:, 0], free[-1, :], free[:, -1] = 0, 0, 0, 0
        free = cv2.erode(free, np.ones((erode_size, erode_size), np.uint8))

        # if np.sum(free) == 0:
        #     return None, None

        if np.sum(free) == 0:
            # avoid returning None, None
            # return None, None
            pix = (obj_mask.shape[0] // 2, obj_mask.shape[1] // 2)
        else:
            pix = utils.sample_distribution(np.float32(free))
        pos = utils.pix_to_xyz(pix, hmap, self.bounds, self.pix_size)
        pos = (pos[0], pos[1], obj_size[2] / 2)
        theta = np.random.rand() * 2 * np.pi
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta))
        return pos, rot

    def get_lang_goal(self):
        if len(self.lang_goals) == 0:
            return self.task_completed_desc
        else:
            return self.lang_goals[0]

    def get_reward(self):
        return float(self._rewards)

    # -------------------------------------------------------------------------
    # Helper Functions
    # -------------------------------------------------------------------------

    def fill_template(self, template, replace):
        """Read a file and replace key strings."""
        full_template_path = os.path.join(self.assets_root, template)
        with open(full_template_path, 'r') as file:
            fdata = file.read()
        for field in replace:
            for i in range(len(replace[field])):
                fdata = fdata.replace(f'{field}{i}', str(replace[field][i]))
        alphabet = string.ascii_lowercase + string.digits
        rname = ''.join(random.choices(alphabet, k=16))
        tmpdir = tempfile.gettempdir()
        template_filename = os.path.split(template)[-1]
        fname = os.path.join(tmpdir, f'{template_filename}.{rname}')
        with open(fname, 'w') as file:
            file.write(fdata)
        return fname

    def get_random_size(self, min_x, max_x, min_y, max_y, min_z, max_z):
        """Get random box size."""
        size = np.random.rand(3)
        size[0] = size[0] * (max_x - min_x) + min_x
        size[1] = size[1] * (max_y - min_y) + min_y
        size[2] = size[2] * (max_z - min_z) + min_z
        return tuple(size)

    def color_random_brown(self, obj):
        shade = np.random.rand() + 0.5
        color = np.float32([shade * 156, shade * 117, shade * 95, 255]) / 255
        p.changeVisualShape(obj, -1, rgbaColor=color)

  """""
  
  # Environment Class
  def add_object(self, urdf, pose, category='rigid'):
    """List of (fixed, rigid, or deformable) objects in env."""
    fixed_base = 1 if category == 'fixed' else 0
    obj_id = pybullet_utils.load_urdf(
        p,
        os.path.join(self.assets_root, urdf),
        pose[0],
        pose[1],
        useFixedBase=fixed_base)
    self.obj_ids[category].append(obj_id)
    return obj_id
"""

=========
Note that the objects need to obey physics and not collide with each other, and the object goal poses need to be above the table with lower bound x=0.25, y=-0.5 and upper bound x=0.75, y=0.5. When there are multiple objects for a multi-step pick-and-place task, there are often multiple subgoals. Once the task and environment are generated, an agent with a pick and place primitive will follow the defined goal to accomplish the tasks. 

Additionally, make sure you understand and summarize the ``self.goals`` variables, which has a list of 8-tuple with (objs, matches, targ_poses, replace, rotations, metric, params, step_max_reward, symmetries).
- objs (List of obj_id): object ID.
- matches (Binary Matrix): a binary matrix that denotes which object is matched with which target. This matrix has dimension len(objs) x len(targs).
- targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation). 
- replace (Boolean): whether each object can match with one unique target. This is important if we have one target and multiple objects. If it's set to be false, then any object matching with the target will satisfy.
- rotations (Boolean): whether the placement action has a rotation degree of freedom. 
- metric (`pose` or `zone`): `pose` or `zone` that the object needs to be transported to. Example: `pose`. 
- params (List of (zone_target, zone_size)): a list of (zone_target, zone_size) for each zone if the metric is `zone`. 
- step_max_reward (float): the total reward of matching all the objects with all the target poses. It is not dependent on the number of objects but dependent on the number of goals. 
- symmetries: the radians that the object is symmetric around z axis.
- language_goal: the low-level language instructions that denote the goal of this step.
 


>>> Answer: 
I understand the provided APIs and the structure of the `self.goals` variable. Here's a summary:

The `Task` class is a base class for defining robotic tasks in a simulated environment. It includes methods for resetting the task, providing an oracle (perfect) agent for demonstrations, calculating rewards, checking task completion, and various helper functions for interacting with the environment.

The `self.goals` variable is a list of 8-tuples, each representing a subgoal in a multi-step pick-and-place task. Each subgoal is defined by the following elements:

1. `objs`: A list of object IDs (`obj_id`). These are the identifiers for the objects involved in the current subgoal.
2. `matches`: A binary matrix indicating which objects are matched with which targets. The dimensions of the matrix are `len(objs)` by `len(targs)`, where `len(objs)` is the number of objects and `len(targs)` is the number of target positions.
3. `targ_poses`: A list of target poses, where each pose is a tuple containing a translation vector `[x, y, z]` and a rotation quaternion `[q0, q1, q2, q3]`.
4. `replace`: A boolean indicating whether each object can match with only one unique target (`False`) or if objects can be matched with any target (`True`).
5. `rotations`: A boolean indicating whether the placement action includes a rotational degree of freedom.
6. `metric`: A string that specifies the evaluation metric for the task. It can be either `'pose'` for evaluating the pose of objects or `'zone'` for evaluating if objects are within a specified zone.
7. `params`: A list of parameters specific to the metric. For the `'zone'` metric, this includes a list of tuples, each containing a zone target and zone size.
8. `step_max_reward`: A float representing the total reward for completing the subgoal. This reward is not dependent on the number of objects but on the number of goals.
9. `symmetries`: The radians of rotational symmetry around the z-axis for the objects. This is used to determine if an object's orientation matches the target orientation within the allowed symmetry.
10. `language_goal`: A string providing low-level language instructions that describe the goal of the current step.

The `add_object` function in the `Environment` class is used to add objects to the simulation. It takes the URDF file path, the pose of the object, and the category of the object (e.g., 'rigid', 'fixed', 'deformable') as inputs and returns the object ID.

The task requires careful consideration of the physics and collision constraints, as well as the specified workspace bounds. The agent must use the provided pick-and-place primitive to move objects to their goal poses while adhering to the task's constraints and maximizing the reward.

================= Code Generation!

>>> Prompt: 
Now I will provide you some reference code and you can write the code for the task "precision-cylinder-alignment".


"""
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class PackingShapes(Task):
    """pick up randomly sized shapes and place them tightly into a container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 1
        self.homogeneous = False

        self.lang_template = "pack the {obj} in the brown box"
        self.task_completed_desc = "done packing shapes."
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        # Shape Names:
        shapes = utils.assembling_kit_shapes

        n_objects = 5
        if self.mode == 'train':
            obj_shapes = np.random.choice(self.train_set, n_objects, replace=False)
        else:
            if self.homogeneous:
                obj_shapes = [np.random.choice(self.test_set, replace=False)] * n_objects
            else:
                obj_shapes = np.random.choice(self.test_set, n_objects, replace=False)

        # Shuffle colors to avoid always picking an object of the same color
        colors, color_names = utils.get_colors(mode=self.mode)

        # Add container box.
        zone_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, zone_pose, 'fixed')

        # Add objects.
        objects = []
        template = 'kitting/object-template.urdf'
        for i in range(n_objects):
            shape = obj_shapes[i]

            # x, y, z dimensions for the asset size
            size = (0.08, 0.08, 0.02)
            pose= self.get_random_pose(env, size)
            fname = f'{shape:02d}.obj'
            fname = os.path.join(self.assets_root, 'kitting', fname)
            scale = [0.003, 0.003, 0.001]  # .0005
            replace = {'FNAME': (fname,),
                       'SCALE': scale,
                       'COLOR': colors[i]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            block_id = env.add_object(urdf, pose)
            objects.append(block_id)

        # Pick the first shape.
        num_objects_to_pick = 1
        for i in range(num_objects_to_pick):
            # IMPORTANT: Specify (obj_pts, [(zone_pose, zone_size)]) for target `zone`. obj_pts is a dict
            language_goal = self.lang_template.format(obj=shapes[obj_shapes[i]])
            self.add_goal(objs=[objects[i]], matches=np.int32([[1]]), targ_poses=[zone_pose], replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1 / num_objects_to_pick,
                language_goal=language_goal)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PlaceRedInGreen(Task):
    """pick up the red blocks and place them into the green bowls amidst other objects."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = "put the red blocks in a green bowl"
        self.task_completed_desc = "done placing blocks in bowls."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_blocks = np.random.randint(1, n_bowls + 1)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, obj_size=bowl_size)
            env.add_object(urdf=bowl_urdf, pose=bowl_pose, category='fixed')
            bowl_poses.append(bowl_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        for _ in range(n_blocks):
            block_pose = self.get_random_pose(env, obj_size=block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Goal: each red block is in a different green bowl.
        self.add_goal(objs=blocks, matches=np.ones((len(blocks), len(bowl_poses))), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

        # Colors of distractor objects.
        bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'green']
        block_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'red']

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = block_colors if is_block else bowl_colors
            pose = self.get_random_pose(env, obj_size=size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1
"""
"""
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils


class SweepingPiles(Task):
    """Push piles of small objects into a target goal zone marked on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = "push the pile of blocks into the green square"
        self.task_completed_desc = "done sweeping."
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add goal zone.
        zone_size = (0.12, 0.12, 0)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add pile of small blocks with `make_piles` function
        obj_ids = self.make_piles(env)

        # Add goal
        self.add_goal(objs=obj_ids, matches=np.ones((50, 1)), targ_poses=[zone_pose], replace=True,
                rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class StackBlockPyramid(Task):
    """Build a pyramid of colored blocks in a color sequence"""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = "make the {row} row with {blocks}"
        self.task_completed_desc = "done stacking block pyramid."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['red']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, blue, purple).
        language_goal = self.lang_template.format(blocks="the green, blue and purple blocks", row="bottom")
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (middle row: yellow, orange).
        language_goal = self.lang_template.format(blocks="the yellow and orange blocks", row="middle")      
        self.add_goal(objs=objs[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (top row: red).
        language_goal = self.lang_template.format(blocks="the red block", row="top")
        self.add_goal(objs=objs[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2]*1, language_goal=language_goal)
"""



Do not use libraries, functions, and assets that you don't know. For each object, try to describe its color, size, category in the task first before you write the code. You do not need extra helper functions. Comment the code liberally to explain what each piece does and why it's written that way. If you have only one goal, `step_max_reward` in `add_goal` should be 1. Use functions `make_piles` and `make_ropes` for creating piles and cables. To use spatula together with the push primitives, import the libraries 
"""
from cliport.tasks import primitives;
from cliport.tasks.grippers import Spatula
"""
and then use `self.primitive = primitives.push` and `self.ee = Spatula`.
Note that the number of language goals usually match the number of motion goals, since they should correspond to each other.

Before generate code, you have a few considerations to focus on:
1. You are strictly prohibited from using function interfaces that do not appear in the above sample code. For example, the module cliport.tasks.primitives does not have pick_plack or place functions, only the push function interface is available.
2. Module 'cliport.tasks.primitives' has no attribute 'pick_place', you mustn't use it.
3. There are two types of your Gripper, one is Spatula and the other is Suction.You need to choose a different end-effector depending on your task requirements. If you need to move an object on the Z axis, then you need to use the Suction type. If you just need to translate an object in a 2D plane, then you can use either Spatula or Suction type.
4. You must determine the type of end-effector you need to use based on the type of task you have. You can choose by adding self.ee=Spatula or self.ee=Suction to the __init__(self) function, the default self.ee is Suction.
5. If you want to use Suction, you must import module using "from cliport.tasks.grippers import Suction". Else if you want to use Spatula, you must import module using "from cliport.tasks.grippers import Spatula".
6. The x-coordinate of the object is in the range [0.25, 0.75], the y-coordinate is in the range [-0.5,0.5] and the z-coordinate is in the range [0, 0.3].
7. The initial position of all objects needs to get its random initial position through the get_random_pose function.
8. The self.max_steps parameter value should be greater than the number of calls to self.add_goal, and preferably equal to twice the number of calls to self.add_goal. For example, if you call self.add_goal twice in one task, then self.max_steps is better set to 4.

If you want to generate the color of the object, you have to obey following rules:
1. You must use the utils.COLORS['COLOR_NAME'] function interface to generate an RGB three-channel value for a color.
2. The available colors for 'COLOR_NAME' are blue, red, green, orange, yellow, purple, pink, cyan, brown, white, gray, indigo, violet, black, silver and gold.
3. If you want to generate a red object, then its RGB three-channel color can be obtained through utils.COLORS['red'].
All object’s colors generation must follow color generation method above.

If you want to generate the target pose of the object(third parameter of function 'self.add_goal' targ_poses), you have to obey following rules:
1. The target pose of an object is represented by the three-dimensional spatial coordinates of the object and its orientation quaternion.
2. The target pose of an object must be represented by [(x,y,z),(q1,q2,q3,q4)]. Where (x,y,z) are the three-dimensional coordinates of the object and (q1,q2,q3,q4) denote the quaternions of the object's target pose.
3. The target pose of an object must be generated by you or use the initial pose of an object as the target pose of the current object.
4. Here's an example, to generate the target pose of a Y object, we have the initial pose information of an X object. So target pose of Y can be represented by pose_y=[(x,y,z),(q1,q2,q3,q4)] or pose_y=initial_pose_x.(Where x,y,z,q1,q2,q3,q4 are specific values.)
5. targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation).
6. The targ_poses you generate must contain translation[x,y,z], but rotation[q0,q1,q2,q3] you may or may not generate.
All object's target pose generation must follow method above.

Now write the code for the task "precision-cylinder-alignment" in python code block starting with ```python.  Reminder: {'task-name': 'precision-cylinder-alignment', 'task-description': 'Arrange three cylinders of distinct colors in a precise linear formation within a narrow marked zone on the tabletop, with the smallest cylinder in the center and the larger ones at the ends, without any part of the cylinders overlapping or extending beyond the zone boundaries.', 'assets-used': ['cylinder/cylinder-template.urdf', 'line/single-green-line-template.urdf', 'zone/zone.urdf']} 


>>> Answer: 
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PrecisionCylinderAlignment(Task):
    """Arrange three cylinders of distinct colors in a precise linear formation within a narrow marked zone."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is set to twice the number of goals
        self.lang_template = "align the {color} cylinder in the marked zone"
        self.task_completed_desc = "done aligning cylinders."
        self.ee = Suction  # Use Suction end-effector to move cylinders on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the colors for the three cylinders
        colors = ['red', 'green', 'blue']
        color_names = ['red', 'green', 'blue']
        cylinder_sizes = [(0.04, 0.04, 0.08),  # Small cylinder
                          (0.04, 0.04, 0.12),  # Medium cylinder
                          (0.04, 0.04, 0.16)]  # Large cylinder

        # Add the line zone where cylinders will be aligned
        line_size = (0.12, 0.02, 0)  # Size of the line zone
        line_pose = self.get_random_pose(env, line_size)  # Random pose for the line zone
        line_urdf = 'line/single-green-line-template.urdf'
        env.add_object(line_urdf, line_pose, 'fixed')

        # Add cylinders with distinct colors and sizes
        cylinder_urdf_template = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for i in range(3):
            # Get random pose for the cylinder
            pose = self.get_random_pose(env, cylinder_sizes[i])
            # Fill the URDF template with the specific size and color for the cylinder
            replace = {'SIZE': cylinder_sizes[i], 'COLOR': utils.COLORS[colors[i]]}
            cylinder_urdf = self.fill_template(cylinder_urdf_template, replace)
            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, pose)
            cylinders.append(cylinder_id)

        # Define the target poses for the cylinders within the line zone
        # The target poses are spaced evenly along the line zone
        targ_x_positions = [line_pose[0][0] - line_size[0] / 4,
                            line_pose[0][0],
                            line_pose[0][0] + line_size[0] / 4]
        targ_poses = [([x, line_pose[0][1], line_pose[0][2]], line_pose[1]) for x in targ_x_positions]

        # Add goals for each cylinder
        for i in range(3):
            language_goal = self.lang_template.format(color=color_names[i])
            self.add_goal(objs=[cylinders[i]], matches=np.int32([[1]]), targ_poses=[targ_poses[i]], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/3,
                          language_goal=language_goal)

# Note: The cylinders are placed in the environment with random initial poses.
# The target poses are calculated based on the position of the line zone, ensuring that the cylinders
# are aligned within the boundaries of the line zone. The Suction end-effector is used to pick and place
# the cylinders vertically. The `step_max_reward` is divided equally among the three goals.
```

In this task, we create a `PrecisionCylinderAlignment` class that inherits from the `Task` base class. We define three cylinders with distinct colors and sizes and add a line zone to the environment where the cylinders need to be aligned. The target poses for the cylinders are calculated to be evenly spaced along the line zone. We use the Suction end-effector to move the cylinders vertically and add goals for each cylinder to be placed in the correct position within the line zone. The reward is divided equally among the three goals.

================= TRIAL: 12

================= Task and Asset Design!

>>> Prompt: 
You are an AI in robot simulation code and task design. I will provide you some example tasks, code implementation, and some guidelines for how to generate tasks and then you will help me generate a new task. My goal is to design diverse and feasible tasks for tabletop manipulation. I will first ask you to describe the task in natural languages and then will let you write the code for it. 

=========
Here are all the assets. Use only these assets in the task and code design. 
"""
insertion/:
ell.urdf  fixture.urdf

bowl/:
bowl.urdf

box/:
box-template.urdf

stacking/:
block.urdf  stand.urdf

zone/:
zone.obj  zone.urdf

pallet/:
pallet.obj  pallet.urdf

ball/:
ball-template.urdf

cylinder/:
cylinder-template.urdf

bowl/:
bowl.urdf

# assets not for picking
corner/:
corner-template.urdf

line/:
single-green-line-template.urdf

container/:
container-template.urdf
"""
 
=========
Here are some examples of good tasks. Try to learn from these structures but avoid overlapping wiht them.

{"assets-used": ["zone/zone.urdf", "block/small.urdf"],
 "task-description": "Push piles of small objects into a target goal zone marked on the tabletop.",
 "task-name": "sweeping-piles"}

{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "Place all blocks of a specified color in a bowl of specified color.",
 "task-name": "put-block-in-bowl"}
 
{"assets-used": ["insertion/ell.urdf", "insertion/fixture.urdf"],
 "task-description": "pick up the L-shaped red block and place it into the L-shaped fixture.",
 "task-name": "block-insertion"}
 
{"assets-used": ["kitting/kit.urdf", "kitting/object-template.urdf"],
 "task-description": "pick up different objects and arrange them on a board marked with corresponding silhouettes.",
 "task-name": "assembling-kits"}
 
{"assets-used": ["pallet/pallet.urdf", "box/box-template.urdf"],
 "task-description": "pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.",
 "task-name": "palletizing-boxes"}
 
{"assets-used": ["stacking/stand.urdf", "stacking/block.urdf"],
 "task-description": "sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.",
 "task-name": "stack-block-pyramid"}
 
{"assets-used": ["container/container-template.urdf", "box/box-template.urdf"],
 "task-description": "pick up randomly sized boxes and place them tightly into a container.",
 "task-name": "packing-boxes"}
 
{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "pick up the red blocks and place them into the green bowls amidst other objects.",
 "task-name": "place-red-in-green"}
 
{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

=========
Here are some tasks that you have come up with before. Try to learn from these structures but avoid overlapping with these tasks. For instance, `bowl_ball_placement` and `sort_balls_in_bowls` are the same task. `pile_boxes_in_corner` and `stack_blocks_into_pallet` are similar tasks, `align-cylinder-in-corner` and `align-cylinder-corner` are similar.
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- color-gradient-tower: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color-coded-pallet-organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- cylinder_hurdle_arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- precision_box_placement: {'task-name': 'precision-box-placement', 'task-description': "Pick up a small blue box and place it precisely within the bounds of a marked white zone on a pallet, ensuring the box does not touch the zone's edges.", 'assets-used': ['box/box-template.urdf', 'zone/zone.urdf', 'pallet/pallet.urdf']}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}





=========
Here are some bad example task instances with explanations.
{
    "task_name": "sort-color-blocks",
    "task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "box/box-template.urdf],
}
reasons: not interesting because it overlaps with the current task `put-block-in-bowl`.

{
    "task-name": "guided-ball-maze",
    "task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
    "assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
}
reasons: the language descriptions are too ambiguous. Navigation is also hard to complete. Also maze.urf does not exist.

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
}
reasons: this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere. Similarly tasks like `insert-ball-into-cylinder` and `cylinder-box-insertion` are invalid.

{
    "task-name": "ball-box-obstacle-course",
    "task-description": "Navigate a ball through an obstacle course created by randomly placed boxes and finally place it inside a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: Navigate the ball is not related to tabletop manipulation tasks.

{
    "task-name": "ball-in-box",
    "task-description": "Use a cable to guide a ball into an open box.",
    "assets-used": ["cable/cable.urdf", "ball/ball-template.urdf", "box/box-template.urdf"]
}
reasons: This task is too hard since it involves interaction of the cable and the ball and cannot be easily completed.

{
    "task-name": "ball-in-container",
    "task-description": "Use the spatula to lift a ball over a wall of boxes and drop it into a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: The only action primitives as pick and place. One cannot use a spatula to lift an object.

{
    "task-name": "line-ball-sorting",
    "task-description": "Move balls of different colors along a single green line, placing each ball in a designated colored box at the end of the line. The challenge includes precision in maintaining the ball on the line and the correct identification of the box color corresponding to each ball.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf"]
}
reasons: Piling or stacking balls are physically infeasible in the simulation.



=========
Now please describe the new task in natural languages and explain its novelty and challenges. Format the answer in a python dictionary with keys "task-name" and value type string, "task-description" (one specific sentence) and value type string, and "assets-used" and value type list of strings. Note that

- Do not use assets that are not in the list above. 
- Tasks that have more colors and shapes are interesting.
- Be as specific as possible about the number, shape, and color of each asset in the task descriptions. 
- The task need to obey physics and remain feasible.





>>> Answer: 
Here is a description of a new task:

```python
{
    "task-name": "pyramid-precision-placement",
    "task-description": "Create a pyramid by precisely placing a small red box, a medium green cylinder, and a large blue ball on top of each other in ascending order of size on a marked zone on the tabletop.",
    "assets-used": ["box/box-template.urdf", "cylinder/cylinder-template.urdf", "ball/ball-template.urdf", "zone/zone.urdf"]
}
```

Explanation of its novelty and challenges:

- **Novelty**: This task integrates three different geometric shapes (a box, a cylinder, and a ball) which must be stacked in a specific order based on size, which is not a common stacking pattern. This adds the complexity of dealing with various center-of-mass considerations and stabilizing different contact surfaces.
  
- **Challenges**:
    - **Precision Placement**: Each object must be placed within a marked zone without touching the zone's edges, requiring high precision manipulation skills.
    - **Stability**: Stacking objects with different shapes is inherently challenging due to the differing contact points and potential instability, especially with a ball on top.
    - **Size Ascending Order**: The task requires an understanding of size and the ability to manipulate objects accordingly, with the smallest object at the bottom and the largest on top, contrary to the usual stability rules.
    - **Color Identification**: The robot will need to identify the color of each object and conform to the order specified in the task.
    - **Physics Feasibility**: While challenging, the task is physically feasible within a simulation environment that allows for fine manipulation of objects with a robotic arm or end effector.
    
This task combines multiple elements of tabletop manipulation, including sorting by color and size, stacking with precision, and dealing with the unique physics of different shapes interacting with each other.

================= API Preview!

>>> Prompt: 
Before writing the code for the task "pyramid-precision-placement". Here are some APIs that are defined. Please confirm that you understand these APIs.

"""
class Task():
    """Base Task class."""

    def __init__(self):
        self.ee = Suction
        self.mode = 'train'
        self.sixdof = False
        self.primitive = primitives.PickPlace()
        self.oracle_cams = cameras.Oracle.CONFIG

        # Evaluation epsilons (for pose evaluation metric).
        self.pos_eps = 0.01
        self.rot_eps = np.deg2rad(15)

        # Workspace bounds.
        self.pix_size = 0.003125
        self.bounds = np.array([[0.25, 0.75], [-0.5, 0.5], [0, 0.3]])
        self.zone_bounds = np.copy(self.bounds)

        self.goals = []
        self.lang_goals = []
        self.task_completed_desc = "task completed."
        self.progress = 0
        self._rewards = 0
        self.assets_root = None

    def reset(self, env):
        if not self.assets_root:
            raise ValueError('assets_root must be set for task, '
                             'call set_assets_root().')
        self.goals = []
        self.lang_goals = []
        self.progress = 0  # Task progression metric in range [0, 1].
        self._rewards = 0  # Cumulative returned rewards.

    # -------------------------------------------------------------------------
    # Oracle Agent
    # -------------------------------------------------------------------------

    def oracle(self, env):
        """Oracle agent."""
        OracleAgent = collections.namedtuple('OracleAgent', ['act'])

        def act(obs, info):
            """Calculate action."""

            # Oracle uses perfect RGB-D orthographic images and segmentation masks.
            _, hmap, obj_mask = self.get_true_image(env)

            # Unpack next goal step.
            objs, matches, targs, replace, rotations, _, _, _ = self.goals[0]

            # Match objects to targets without replacement.
            if not replace:

                # Modify a copy of the match matrix.
                matches = matches.copy()

                # Ignore already matched objects.
                for i in range(len(objs)):
                    object_id, (symmetry, _) = objs[i]
                    pose = p.getBasePositionAndOrientation(object_id)
                    targets_i = np.argwhere(matches[i, :]).reshape(-1)
                    for j in targets_i:
                        if self.is_match(pose, targs[j], symmetry):
                            matches[i, :] = 0
                            matches[:, j] = 0

            # Get objects to be picked (prioritize farthest from nearest neighbor).
            nn_dists = []
            nn_targets = []
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                xyz, _ = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                if len(targets_i) > 0:
                    targets_xyz = np.float32([targs[j][0] for j in targets_i])
                    dists = np.linalg.norm(
                        targets_xyz - np.float32(xyz).reshape(1, 3), axis=1)
                    nn = np.argmin(dists)
                    nn_dists.append(dists[nn])
                    nn_targets.append(targets_i[nn])

                # Handle ignored objects.
                else:
                    nn_dists.append(0)
                    nn_targets.append(-1)
            order = np.argsort(nn_dists)[::-1]

            # Filter out matched objects.
            order = [i for i in order if nn_dists[i] > 0]

            pick_mask = None
            for pick_i in order:
                pick_mask = np.uint8(obj_mask == objs[pick_i][0])

                # Erode to avoid picking on edges.
                # pick_mask = cv2.erode(pick_mask, np.ones((3, 3), np.uint8))

                if np.sum(pick_mask) > 0:
                    break

            # Trigger task reset if no object is visible.
            if pick_mask is None or np.sum(pick_mask) == 0:
                self.goals = []
                self.lang_goals = []
                print('Object for pick is not visible. Skipping demonstration.')
                return

            # Get picking pose.
            pick_prob = np.float32(pick_mask)
            pick_pix = utils.sample_distribution(pick_prob)
            # For "deterministic" demonstrations on insertion-easy, use this:
            # pick_pix = (160,80)
            pick_pos = utils.pix_to_xyz(pick_pix, hmap,
                                        self.bounds, self.pix_size)
            pick_pose = (np.asarray(pick_pos), np.asarray((0, 0, 0, 1)))

            # Get placing pose.
            targ_pose = targs[nn_targets[pick_i]]
            obj_pose = p.getBasePositionAndOrientation(objs[pick_i][0])
            if not self.sixdof:
                obj_euler = utils.quatXYZW_to_eulerXYZ(obj_pose[1])
                obj_quat = utils.eulerXYZ_to_quatXYZW((0, 0, obj_euler[2]))
                obj_pose = (obj_pose[0], obj_quat)
            world_to_pick = utils.invert(pick_pose)
            obj_to_pick = utils.multiply(world_to_pick, obj_pose)
            pick_to_obj = utils.invert(obj_to_pick)
            place_pose = utils.multiply(targ_pose, pick_to_obj)

            # Rotate end effector?
            if not rotations:
                place_pose = (place_pose[0], (0, 0, 0, 1))

            place_pose = (np.asarray(place_pose[0]), np.asarray(place_pose[1]))

            return {'pose0': pick_pose, 'pose1': place_pose}

        return OracleAgent(act)

    # -------------------------------------------------------------------------
    # Reward Function and Task Completion Metrics
    # -------------------------------------------------------------------------

    def reward(self):
        """Get delta rewards for current timestep.

        Returns:
          A tuple consisting of the scalar (delta) reward, plus `extras`
            dict which has extra task-dependent info from the process of
            computing rewards that gives us finer-grained details. Use
            `extras` for further data analysis.
        """
        reward, info = 0, {}

        # Unpack next goal step.
        objs, matches, targs, _, _, metric, params, max_reward = self.goals[0]

        # Evaluate by matching object poses.
        if metric == 'pose':
            step_reward = 0
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                pose = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                for j in targets_i:
                    target_pose = targs[j]
                    if self.is_match(pose, target_pose, symmetry):
                        step_reward += max_reward / len(objs)
                        print(f"object {i} match with target {j} rew: {step_reward}")
                        break

        # Evaluate by measuring object intersection with zone.
        elif metric == 'zone':
            zone_pts, total_pts = 0, 0
            obj_pts, zones = params
            for zone_idx, (zone_pose, zone_size) in enumerate(zones):

                # Count valid points in zone.
                for obj_idx, obj_id in enumerate(obj_pts):
                    pts = obj_pts[obj_id]
                    obj_pose = p.getBasePositionAndOrientation(obj_id)
                    world_to_zone = utils.invert(zone_pose)
                    obj_to_zone = utils.multiply(world_to_zone, obj_pose)
                    pts = np.float32(utils.apply(obj_to_zone, pts))
                    if len(zone_size) > 1:
                        valid_pts = np.logical_and.reduce([
                            pts[0, :] > -zone_size[0] / 2, pts[0, :] < zone_size[0] / 2,
                            pts[1, :] > -zone_size[1] / 2, pts[1, :] < zone_size[1] / 2,
                            pts[2, :] < self.zone_bounds[2, 1]])

                    # if zone_idx == matches[obj_idx].argmax():
                    zone_pts += np.sum(np.float32(valid_pts))
                    total_pts += pts.shape[1]
            step_reward = max_reward * (zone_pts / total_pts)

        # Get cumulative rewards and return delta.
        reward = self.progress + step_reward - self._rewards
        self._rewards = self.progress + step_reward

        # Move to next goal step if current goal step is complete.
        if np.abs(max_reward - step_reward) < 0.01:
            self.progress += max_reward  # Update task progress.
            self.goals.pop(0)
            if len(self.lang_goals) > 0:
                self.lang_goals.pop(0)

        return reward, info

    def done(self):
        """Check if the task is done or has failed.

        Returns:
          True if the episode should be considered a success, which we
            use for measuring successes, which is particularly helpful for tasks
            where one may get successes on the very last time step, e.g., getting
            the cloth coverage threshold on the last alllowed action.
            However, for bag-items-easy and bag-items-hard (which use the
            'bag-items' metric), it may be necessary to filter out demos that did
            not attain sufficiently high reward in external code. Currently, this
            is done in `main.py` and its ignore_this_demo() method.
        """
        return (len(self.goals) == 0) or (self._rewards > 0.99)
        # return zone_done or defs_done or goal_done

    # -------------------------------------------------------------------------
    # Environment Helper Functions
    # -------------------------------------------------------------------------

    def is_match(self, pose0, pose1, symmetry):
        """Check if pose0 and pose1 match within a threshold."""

        # Get translational error.
        diff_pos = np.float32(pose0[0][:2]) - np.float32(pose1[0][:2])
        dist_pos = np.linalg.norm(diff_pos)

        # Get rotational error around z-axis (account for symmetries).
        diff_rot = 0
        if symmetry > 0:
            rot0 = np.array(utils.quatXYZW_to_eulerXYZ(pose0[1]))[2]
            rot1 = np.array(utils.quatXYZW_to_eulerXYZ(pose1[1]))[2]
            diff_rot = np.abs(rot0 - rot1) % symmetry
            if diff_rot > (symmetry / 2):
                diff_rot = symmetry - diff_rot

        return (dist_pos < self.pos_eps) and (diff_rot < self.rot_eps)

    def get_random_pose(self, env, obj_size):
        """Get random collision-free object pose within workspace bounds."""

        # Get erosion size of object in pixels.
        max_size = np.sqrt(obj_size[0] ** 2 + obj_size[1] ** 2)
        erode_size = int(np.round(max_size / self.pix_size))

        _, hmap, obj_mask = self.get_true_image(env)

        # Randomly sample an object pose within free-space pixels.
        free = np.ones(obj_mask.shape, dtype=np.uint8)
        for obj_ids in env.obj_ids.values():
            for obj_id in obj_ids:
                free[obj_mask == obj_id] = 0
        free[0, :], free[:, 0], free[-1, :], free[:, -1] = 0, 0, 0, 0
        free = cv2.erode(free, np.ones((erode_size, erode_size), np.uint8))

        # if np.sum(free) == 0:
        #     return None, None

        if np.sum(free) == 0:
            # avoid returning None, None
            # return None, None
            pix = (obj_mask.shape[0] // 2, obj_mask.shape[1] // 2)
        else:
            pix = utils.sample_distribution(np.float32(free))
        pos = utils.pix_to_xyz(pix, hmap, self.bounds, self.pix_size)
        pos = (pos[0], pos[1], obj_size[2] / 2)
        theta = np.random.rand() * 2 * np.pi
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta))
        return pos, rot

    def get_lang_goal(self):
        if len(self.lang_goals) == 0:
            return self.task_completed_desc
        else:
            return self.lang_goals[0]

    def get_reward(self):
        return float(self._rewards)

    # -------------------------------------------------------------------------
    # Helper Functions
    # -------------------------------------------------------------------------

    def fill_template(self, template, replace):
        """Read a file and replace key strings."""
        full_template_path = os.path.join(self.assets_root, template)
        with open(full_template_path, 'r') as file:
            fdata = file.read()
        for field in replace:
            for i in range(len(replace[field])):
                fdata = fdata.replace(f'{field}{i}', str(replace[field][i]))
        alphabet = string.ascii_lowercase + string.digits
        rname = ''.join(random.choices(alphabet, k=16))
        tmpdir = tempfile.gettempdir()
        template_filename = os.path.split(template)[-1]
        fname = os.path.join(tmpdir, f'{template_filename}.{rname}')
        with open(fname, 'w') as file:
            file.write(fdata)
        return fname

    def get_random_size(self, min_x, max_x, min_y, max_y, min_z, max_z):
        """Get random box size."""
        size = np.random.rand(3)
        size[0] = size[0] * (max_x - min_x) + min_x
        size[1] = size[1] * (max_y - min_y) + min_y
        size[2] = size[2] * (max_z - min_z) + min_z
        return tuple(size)

    def color_random_brown(self, obj):
        shade = np.random.rand() + 0.5
        color = np.float32([shade * 156, shade * 117, shade * 95, 255]) / 255
        p.changeVisualShape(obj, -1, rgbaColor=color)

  """""
  
  # Environment Class
  def add_object(self, urdf, pose, category='rigid'):
    """List of (fixed, rigid, or deformable) objects in env."""
    fixed_base = 1 if category == 'fixed' else 0
    obj_id = pybullet_utils.load_urdf(
        p,
        os.path.join(self.assets_root, urdf),
        pose[0],
        pose[1],
        useFixedBase=fixed_base)
    self.obj_ids[category].append(obj_id)
    return obj_id
"""

=========
Note that the objects need to obey physics and not collide with each other, and the object goal poses need to be above the table with lower bound x=0.25, y=-0.5 and upper bound x=0.75, y=0.5. When there are multiple objects for a multi-step pick-and-place task, there are often multiple subgoals. Once the task and environment are generated, an agent with a pick and place primitive will follow the defined goal to accomplish the tasks. 

Additionally, make sure you understand and summarize the ``self.goals`` variables, which has a list of 8-tuple with (objs, matches, targ_poses, replace, rotations, metric, params, step_max_reward, symmetries).
- objs (List of obj_id): object ID.
- matches (Binary Matrix): a binary matrix that denotes which object is matched with which target. This matrix has dimension len(objs) x len(targs).
- targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation). 
- replace (Boolean): whether each object can match with one unique target. This is important if we have one target and multiple objects. If it's set to be false, then any object matching with the target will satisfy.
- rotations (Boolean): whether the placement action has a rotation degree of freedom. 
- metric (`pose` or `zone`): `pose` or `zone` that the object needs to be transported to. Example: `pose`. 
- params (List of (zone_target, zone_size)): a list of (zone_target, zone_size) for each zone if the metric is `zone`. 
- step_max_reward (float): the total reward of matching all the objects with all the target poses. It is not dependent on the number of objects but dependent on the number of goals. 
- symmetries: the radians that the object is symmetric around z axis.
- language_goal: the low-level language instructions that denote the goal of this step.
 


>>> Answer: 
I understand the provided APIs and the structure of the `Task` class, as well as the `add_object` method in the environment class. Here's a summary of my understanding:

### Task Class
- The `Task` class serves as a base class for defining robotic tasks in a simulation environment.
- It initializes with default parameters for the end effector (`ee`), mode, six degrees of freedom (`sixdof`), a pick-and-place primitive, and camera configurations.
- The `reset` method is used to reset the task state.
- The `oracle` method provides an oracle agent that can perform the task perfectly for demonstration or testing purposes.
- The `reward` method calculates the reward based on the current state of the task and the progress towards the goals.
- The `done` method checks if the task is completed or has failed.
- The `is_match` method checks if two poses match within a specified tolerance.
- The `get_random_pose` method generates a random collision-free pose within the workspace bounds.
- The `get_lang_goal` method retrieves the current language goal.
- The `get_reward` method returns the current cumulative reward.
- The `fill_template` method is a utility to fill a URDF template with specific values.
- The `get_random_size` method generates a random size for an object within specified bounds.
- The `color_random_brown` method assigns a random brown color to an object.

### Environment Class
- The `add_object` method is used to add objects to the simulation environment. It takes a URDF file path, a pose, and a category indicating whether the object is fixed, rigid, or deformable.

### self.goals Variable
- `self.goals` is a list of 8-tuples that define the subgoals for a multi-step pick-and-place task. Each tuple contains the following:
  - `objs`: A list of object IDs.
  - `matches`: A binary matrix indicating which objects are matched with which targets.
  - `targ_poses`: A list of target poses, each a tuple of translation and rotation.
  - `replace`: A boolean indicating whether objects can match with one unique target.
  - `rotations`: A boolean indicating whether the placement action includes rotation.
  - `metric`: A string indicating the evaluation metric ('pose' or 'zone').
  - `params`: Additional parameters, such as zone targets and sizes if the metric is 'zone'.
  - `step_max_reward`: The total reward for matching all objects with all target poses.
  - `symmetries`: The radians of symmetry around the z-axis for each object.
  - `language_goal`: Low-level language instructions describing the goal of the step.

Understanding these APIs and the structure of the `Task` class is crucial for writing the code for the "pyramid-precision-placement" task, as it will involve defining the task's specific goals, rewards, and completion criteria within this framework.

================= Code Generation!

>>> Prompt: 
Now I will provide you some reference code and you can write the code for the task "pyramid-precision-placement".


"""
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class PackingShapes(Task):
    """pick up randomly sized shapes and place them tightly into a container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 1
        self.homogeneous = False

        self.lang_template = "pack the {obj} in the brown box"
        self.task_completed_desc = "done packing shapes."
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        # Shape Names:
        shapes = utils.assembling_kit_shapes

        n_objects = 5
        if self.mode == 'train':
            obj_shapes = np.random.choice(self.train_set, n_objects, replace=False)
        else:
            if self.homogeneous:
                obj_shapes = [np.random.choice(self.test_set, replace=False)] * n_objects
            else:
                obj_shapes = np.random.choice(self.test_set, n_objects, replace=False)

        # Shuffle colors to avoid always picking an object of the same color
        colors, color_names = utils.get_colors(mode=self.mode)

        # Add container box.
        zone_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, zone_pose, 'fixed')

        # Add objects.
        objects = []
        template = 'kitting/object-template.urdf'
        for i in range(n_objects):
            shape = obj_shapes[i]

            # x, y, z dimensions for the asset size
            size = (0.08, 0.08, 0.02)
            pose= self.get_random_pose(env, size)
            fname = f'{shape:02d}.obj'
            fname = os.path.join(self.assets_root, 'kitting', fname)
            scale = [0.003, 0.003, 0.001]  # .0005
            replace = {'FNAME': (fname,),
                       'SCALE': scale,
                       'COLOR': colors[i]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            block_id = env.add_object(urdf, pose)
            objects.append(block_id)

        # Pick the first shape.
        num_objects_to_pick = 1
        for i in range(num_objects_to_pick):
            # IMPORTANT: Specify (obj_pts, [(zone_pose, zone_size)]) for target `zone`. obj_pts is a dict
            language_goal = self.lang_template.format(obj=shapes[obj_shapes[i]])
            self.add_goal(objs=[objects[i]], matches=np.int32([[1]]), targ_poses=[zone_pose], replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1 / num_objects_to_pick,
                language_goal=language_goal)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PlaceRedInGreen(Task):
    """pick up the red blocks and place them into the green bowls amidst other objects."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = "put the red blocks in a green bowl"
        self.task_completed_desc = "done placing blocks in bowls."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_blocks = np.random.randint(1, n_bowls + 1)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, obj_size=bowl_size)
            env.add_object(urdf=bowl_urdf, pose=bowl_pose, category='fixed')
            bowl_poses.append(bowl_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        for _ in range(n_blocks):
            block_pose = self.get_random_pose(env, obj_size=block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Goal: each red block is in a different green bowl.
        self.add_goal(objs=blocks, matches=np.ones((len(blocks), len(bowl_poses))), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

        # Colors of distractor objects.
        bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'green']
        block_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'red']

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = block_colors if is_block else bowl_colors
            pose = self.get_random_pose(env, obj_size=size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1
"""
"""
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils


class SweepingPiles(Task):
    """Push piles of small objects into a target goal zone marked on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = "push the pile of blocks into the green square"
        self.task_completed_desc = "done sweeping."
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add goal zone.
        zone_size = (0.12, 0.12, 0)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add pile of small blocks with `make_piles` function
        obj_ids = self.make_piles(env)

        # Add goal
        self.add_goal(objs=obj_ids, matches=np.ones((50, 1)), targ_poses=[zone_pose], replace=True,
                rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class StackBlockPyramid(Task):
    """Build a pyramid of colored blocks in a color sequence"""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = "make the {row} row with {blocks}"
        self.task_completed_desc = "done stacking block pyramid."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['red']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, blue, purple).
        language_goal = self.lang_template.format(blocks="the green, blue and purple blocks", row="bottom")
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (middle row: yellow, orange).
        language_goal = self.lang_template.format(blocks="the yellow and orange blocks", row="middle")      
        self.add_goal(objs=objs[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (top row: red).
        language_goal = self.lang_template.format(blocks="the red block", row="top")
        self.add_goal(objs=objs[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2]*1, language_goal=language_goal)
"""



Do not use libraries, functions, and assets that you don't know. For each object, try to describe its color, size, category in the task first before you write the code. You do not need extra helper functions. Comment the code liberally to explain what each piece does and why it's written that way. If you have only one goal, `step_max_reward` in `add_goal` should be 1. Use functions `make_piles` and `make_ropes` for creating piles and cables. To use spatula together with the push primitives, import the libraries 
"""
from cliport.tasks import primitives;
from cliport.tasks.grippers import Spatula
"""
and then use `self.primitive = primitives.push` and `self.ee = Spatula`.
Note that the number of language goals usually match the number of motion goals, since they should correspond to each other.

Before generate code, you have a few considerations to focus on:
1. You are strictly prohibited from using function interfaces that do not appear in the above sample code. For example, the module cliport.tasks.primitives does not have pick_plack or place functions, only the push function interface is available.
2. Module 'cliport.tasks.primitives' has no attribute 'pick_place', you mustn't use it.
3. There are two types of your Gripper, one is Spatula and the other is Suction.You need to choose a different end-effector depending on your task requirements. If you need to move an object on the Z axis, then you need to use the Suction type. If you just need to translate an object in a 2D plane, then you can use either Spatula or Suction type.
4. You must determine the type of end-effector you need to use based on the type of task you have. You can choose by adding self.ee=Spatula or self.ee=Suction to the __init__(self) function, the default self.ee is Suction.
5. If you want to use Suction, you must import module using "from cliport.tasks.grippers import Suction". Else if you want to use Spatula, you must import module using "from cliport.tasks.grippers import Spatula".
6. The x-coordinate of the object is in the range [0.25, 0.75], the y-coordinate is in the range [-0.5,0.5] and the z-coordinate is in the range [0, 0.3].
7. The initial position of all objects needs to get its random initial position through the get_random_pose function.
8. The self.max_steps parameter value should be greater than the number of calls to self.add_goal, and preferably equal to twice the number of calls to self.add_goal. For example, if you call self.add_goal twice in one task, then self.max_steps is better set to 4.

If you want to generate the color of the object, you have to obey following rules:
1. You must use the utils.COLORS['COLOR_NAME'] function interface to generate an RGB three-channel value for a color.
2. The available colors for 'COLOR_NAME' are blue, red, green, orange, yellow, purple, pink, cyan, brown, white, gray, indigo, violet, black, silver and gold.
3. If you want to generate a red object, then its RGB three-channel color can be obtained through utils.COLORS['red'].
All object’s colors generation must follow color generation method above.

If you want to generate the target pose of the object(third parameter of function 'self.add_goal' targ_poses), you have to obey following rules:
1. The target pose of an object is represented by the three-dimensional spatial coordinates of the object and its orientation quaternion.
2. The target pose of an object must be represented by [(x,y,z),(q1,q2,q3,q4)]. Where (x,y,z) are the three-dimensional coordinates of the object and (q1,q2,q3,q4) denote the quaternions of the object's target pose.
3. The target pose of an object must be generated by you or use the initial pose of an object as the target pose of the current object.
4. Here's an example, to generate the target pose of a Y object, we have the initial pose information of an X object. So target pose of Y can be represented by pose_y=[(x,y,z),(q1,q2,q3,q4)] or pose_y=initial_pose_x.(Where x,y,z,q1,q2,q3,q4 are specific values.)
5. targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation).
6. The targ_poses you generate must contain translation[x,y,z], but rotation[q0,q1,q2,q3] you may or may not generate.
All object's target pose generation must follow method above.

Now write the code for the task "pyramid-precision-placement" in python code block starting with ```python.  Reminder: {'task-name': 'pyramid-precision-placement', 'task-description': 'Create a pyramid by precisely placing a small red box, a medium green cylinder, and a large blue ball on top of each other in ascending order of size on a marked zone on the tabletop.', 'assets-used': ['box/box-template.urdf', 'cylinder/cylinder-template.urdf', 'ball/ball-template.urdf', 'zone/zone.urdf']} 


>>> Answer: 
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PyramidPrecisionPlacement(Task):
    """Create a pyramid by precisely placing a small red box, a medium green cylinder,
    and a large blue ball on top of each other in ascending order of size on a marked
    zone on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We have 3 objects to place, so max_steps is twice that number
        self.lang_template = "place the {object} on the {location}"
        self.task_completed_desc = "done creating the pyramid."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector

    def reset(self, env):
        super().reset(env)

        # Define the sizes for the box, cylinder, and ball
        box_size = (0.04, 0.04, 0.04)  # Small red box
        cylinder_size = (0.06, 0.06, 0.08)  # Medium green cylinder
        ball_size = (0.08, 0.08, 0.08)  # Large blue ball

        # Define the colors for the box, cylinder, and ball
        box_color = utils.COLORS['red']
        cylinder_color = utils.COLORS['green']
        ball_color = utils.COLORS['blue']

        # Add the zone where the pyramid will be built
        zone_size = (0.15, 0.15, 0)  # Size of the zone
        zone_pose = self.get_random_pose(env, zone_size)  # Random pose for the zone
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')  # Add the zone to the environment

        # Add the small red box
        box_pose = self.get_random_pose(env, box_size)  # Random pose for the box
        box_template = 'box/box-template.urdf'
        box_replace = {'DIM': box_size, 'COLOR': box_color}
        box_urdf = self.fill_template(box_template, box_replace)
        box_id = env.add_object(box_urdf, box_pose)

        # Add the medium green cylinder
        cylinder_pose = self.get_random_pose(env, cylinder_size)  # Random pose for the cylinder
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_replace = {'DIM': cylinder_size, 'COLOR': cylinder_color}
        cylinder_urdf = self.fill_template(cylinder_template, cylinder_replace)
        cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)

        # Add the large blue ball
        ball_pose = self.get_random_pose(env, ball_size)  # Random pose for the ball
        ball_template = 'ball/ball-template.urdf'
        ball_replace = {'DIM': ball_size, 'COLOR': ball_color}
        ball_urdf = self.fill_template(ball_template, ball_replace)
        ball_id = env.add_object(ball_urdf, ball_pose)

        # Define the target poses for each object on the zone
        # The poses are defined relative to the zone's pose
        box_target_pose = (zone_pose[0], (0, 0, 0, 1))  # Box directly on the zone
        cylinder_target_pose = utils.apply(zone_pose, (0, 0, box_size[2]))  # Cylinder on top of the box
        ball_target_pose = utils.apply(cylinder_target_pose, (0, 0, cylinder_size[2]))  # Ball on top of the cylinder

        # Add goals for each object
        # Goal 1: Place the small red box on the zone
        self.add_goal(objs=[box_id], matches=np.ones((1, 1)), targ_poses=[box_target_pose],
                      replace=True, rotations=True, metric='pose', params=None,
                      step_max_reward=1/3,
                      language_goal=self.lang_template.format(object="small red box", location="marked zone"))

        # Goal 2: Place the medium green cylinder on top of the small red box
        self.add_goal(objs=[cylinder_id], matches=np.ones((1, 1)), targ_poses=[cylinder_target_pose],
                      replace=True, rotations=True, metric='pose', params=None,
                      step_max_reward=1/3,
                      language_goal=self.lang_template.format(object="medium green cylinder", location="small red box"))

        # Goal 3: Place the large blue ball on top of the medium green cylinder
        self.add_goal(objs=[ball_id], matches=np.ones((1, 1)), targ_poses=[ball_target_pose],
                      replace=True, rotations=True, metric='pose', params=None,
                      step_max_reward=1/3,
                      language_goal=self.lang_template.format(object="large blue ball", location="medium green cylinder"))
```

This code defines a task where a robot must build a pyramid by placing objects of different sizes and colors on top of each other in a specific order. The task uses a Suction end-effector to move objects on the Z axis, and it defines the size and color of each object, as well as their initial and target poses. The `add_goal` method is used to specify the desired final state for each object, and language goals are provided to describe each step of the task.

================= TRIAL: 13

================= Task and Asset Design!

>>> Prompt: 
You are an AI in robot simulation code and task design. I will provide you some example tasks, code implementation, and some guidelines for how to generate tasks and then you will help me generate a new task. My goal is to design diverse and feasible tasks for tabletop manipulation. I will first ask you to describe the task in natural languages and then will let you write the code for it. 

=========
Here are all the assets. Use only these assets in the task and code design. 
"""
insertion/:
ell.urdf  fixture.urdf

bowl/:
bowl.urdf

box/:
box-template.urdf

stacking/:
block.urdf  stand.urdf

zone/:
zone.obj  zone.urdf

pallet/:
pallet.obj  pallet.urdf

ball/:
ball-template.urdf

cylinder/:
cylinder-template.urdf

bowl/:
bowl.urdf

# assets not for picking
corner/:
corner-template.urdf

line/:
single-green-line-template.urdf

container/:
container-template.urdf
"""
 
=========
Here are some examples of good tasks. Try to learn from these structures but avoid overlapping wiht them.

{"assets-used": ["zone/zone.urdf", "block/small.urdf"],
 "task-description": "Push piles of small objects into a target goal zone marked on the tabletop.",
 "task-name": "sweeping-piles"}

{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "Place all blocks of a specified color in a bowl of specified color.",
 "task-name": "put-block-in-bowl"}
 
{"assets-used": ["insertion/ell.urdf", "insertion/fixture.urdf"],
 "task-description": "pick up the L-shaped red block and place it into the L-shaped fixture.",
 "task-name": "block-insertion"}
 
{"assets-used": ["kitting/kit.urdf", "kitting/object-template.urdf"],
 "task-description": "pick up different objects and arrange them on a board marked with corresponding silhouettes.",
 "task-name": "assembling-kits"}
 
{"assets-used": ["pallet/pallet.urdf", "box/box-template.urdf"],
 "task-description": "pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.",
 "task-name": "palletizing-boxes"}
 
{"assets-used": ["stacking/stand.urdf", "stacking/block.urdf"],
 "task-description": "sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.",
 "task-name": "stack-block-pyramid"}
 
{"assets-used": ["container/container-template.urdf", "box/box-template.urdf"],
 "task-description": "pick up randomly sized boxes and place them tightly into a container.",
 "task-name": "packing-boxes"}
 
{"assets-used": ["bowl/bowl.urdf", "stacking/block.urdf"],
 "task-description": "pick up the red blocks and place them into the green bowls amidst other objects.",
 "task-name": "place-red-in-green"}
 
{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

{"assets-used": ["box/box-template.urdf", "corner/corner-template.urdf"],
 "task-description": "pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..",
 "task-name": "align-box-corner"}

=========
Here are some tasks that you have come up with before. Try to learn from these structures but avoid overlapping with these tasks. For instance, `bowl_ball_placement` and `sort_balls_in_bowls` are the same task. `pile_boxes_in_corner` and `stack_blocks_into_pallet` are similar tasks, `align-cylinder-in-corner` and `align-cylinder-corner` are similar.
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- color_gradient_tower: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- precision_box_placement: {'task-name': 'precision-box-placement', 'task-description': "Pick up a small blue box and place it precisely within the bounds of a marked white zone on a pallet, ensuring the box does not touch the zone's edges.", 'assets-used': ['box/box-template.urdf', 'zone/zone.urdf', 'pallet/pallet.urdf']}
- gradient_tower_placement: {'task-name': 'gradient-tower-placement', 'task-description': 'Build two separate towers each made of three differently colored cylinders, placing them on a patterned zone marked with two distinct areas, one for each tower, while ensuring that the cylinders in each tower are arranged in a color gradient sequence from the lightest on top to the darkest at the base.', 'assets-used': ['cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- cylinder_tower_balancing: {'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}
- color-gradient-tower: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}





=========
Here are some bad example task instances with explanations.
{
    "task_name": "sort-color-blocks",
    "task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "box/box-template.urdf],
}
reasons: not interesting because it overlaps with the current task `put-block-in-bowl`.

{
    "task-name": "guided-ball-maze",
    "task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
    "assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
}
reasons: the language descriptions are too ambiguous. Navigation is also hard to complete. Also maze.urf does not exist.

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
}
reasons: this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere. Similarly tasks like `insert-ball-into-cylinder` and `cylinder-box-insertion` are invalid.

{
    "task-name": "ball-box-obstacle-course",
    "task-description": "Navigate a ball through an obstacle course created by randomly placed boxes and finally place it inside a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: Navigate the ball is not related to tabletop manipulation tasks.

{
    "task-name": "ball-in-box",
    "task-description": "Use a cable to guide a ball into an open box.",
    "assets-used": ["cable/cable.urdf", "ball/ball-template.urdf", "box/box-template.urdf"]
}
reasons: This task is too hard since it involves interaction of the cable and the ball and cannot be easily completed.

{
    "task-name": "ball-in-container",
    "task-description": "Use the spatula to lift a ball over a wall of boxes and drop it into a container.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "container/container-template.urdf"]
}
reasons: The only action primitives as pick and place. One cannot use a spatula to lift an object.

{
    "task-name": "line-ball-sorting",
    "task-description": "Move balls of different colors along a single green line, placing each ball in a designated colored box at the end of the line. The challenge includes precision in maintaining the ball on the line and the correct identification of the box color corresponding to each ball.",
    "assets-used": ["ball/ball-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf"]
}
reasons: Piling or stacking balls are physically infeasible in the simulation.



=========
Now please describe the new task in natural languages and explain its novelty and challenges. Format the answer in a python dictionary with keys "task-name" and value type string, "task-description" (one specific sentence) and value type string, and "assets-used" and value type list of strings. Note that

- Do not use assets that are not in the list above. 
- Tasks that have more colors and shapes are interesting.
- Be as specific as possible about the number, shape, and color of each asset in the task descriptions. 
- The task need to obey physics and remain feasible.





>>> Answer: 
Here's a description of a new task that adheres to the provided guidelines:

```python
{
    "task-name": "palette-arrangement-challenge",
    "task-description": "Arrange a set of five differently colored blocks on a pallet, each in a specific zone marked with a corresponding color, ensuring that no block is touching another.",
    "assets-used": ["pallet/pallet.urdf", "zone/zone.urdf", "stacking/block.urdf"]
}
```

Novelty and Challenges:
- This task introduces the complexity of spatial arrangement on a pallet, which tests the robot's precision in placement.
- The requirement to match block colors with zones adds a color recognition challenge.
- Ensuring that no block is touching another requires careful planning and manipulation skills.
- The use of both a pallet and color-coded zones combines elements of stacking and color-based sorting, creating a unique scenario for tabletop manipulation.

================= API Preview!

>>> Prompt: 
Before writing the code for the task "palette-arrangement-challenge". Here are some APIs that are defined. Please confirm that you understand these APIs.

"""
class Task():
    """Base Task class."""

    def __init__(self):
        self.ee = Suction
        self.mode = 'train'
        self.sixdof = False
        self.primitive = primitives.PickPlace()
        self.oracle_cams = cameras.Oracle.CONFIG

        # Evaluation epsilons (for pose evaluation metric).
        self.pos_eps = 0.01
        self.rot_eps = np.deg2rad(15)

        # Workspace bounds.
        self.pix_size = 0.003125
        self.bounds = np.array([[0.25, 0.75], [-0.5, 0.5], [0, 0.3]])
        self.zone_bounds = np.copy(self.bounds)

        self.goals = []
        self.lang_goals = []
        self.task_completed_desc = "task completed."
        self.progress = 0
        self._rewards = 0
        self.assets_root = None

    def reset(self, env):
        if not self.assets_root:
            raise ValueError('assets_root must be set for task, '
                             'call set_assets_root().')
        self.goals = []
        self.lang_goals = []
        self.progress = 0  # Task progression metric in range [0, 1].
        self._rewards = 0  # Cumulative returned rewards.

    # -------------------------------------------------------------------------
    # Oracle Agent
    # -------------------------------------------------------------------------

    def oracle(self, env):
        """Oracle agent."""
        OracleAgent = collections.namedtuple('OracleAgent', ['act'])

        def act(obs, info):
            """Calculate action."""

            # Oracle uses perfect RGB-D orthographic images and segmentation masks.
            _, hmap, obj_mask = self.get_true_image(env)

            # Unpack next goal step.
            objs, matches, targs, replace, rotations, _, _, _ = self.goals[0]

            # Match objects to targets without replacement.
            if not replace:

                # Modify a copy of the match matrix.
                matches = matches.copy()

                # Ignore already matched objects.
                for i in range(len(objs)):
                    object_id, (symmetry, _) = objs[i]
                    pose = p.getBasePositionAndOrientation(object_id)
                    targets_i = np.argwhere(matches[i, :]).reshape(-1)
                    for j in targets_i:
                        if self.is_match(pose, targs[j], symmetry):
                            matches[i, :] = 0
                            matches[:, j] = 0

            # Get objects to be picked (prioritize farthest from nearest neighbor).
            nn_dists = []
            nn_targets = []
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                xyz, _ = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                if len(targets_i) > 0:
                    targets_xyz = np.float32([targs[j][0] for j in targets_i])
                    dists = np.linalg.norm(
                        targets_xyz - np.float32(xyz).reshape(1, 3), axis=1)
                    nn = np.argmin(dists)
                    nn_dists.append(dists[nn])
                    nn_targets.append(targets_i[nn])

                # Handle ignored objects.
                else:
                    nn_dists.append(0)
                    nn_targets.append(-1)
            order = np.argsort(nn_dists)[::-1]

            # Filter out matched objects.
            order = [i for i in order if nn_dists[i] > 0]

            pick_mask = None
            for pick_i in order:
                pick_mask = np.uint8(obj_mask == objs[pick_i][0])

                # Erode to avoid picking on edges.
                # pick_mask = cv2.erode(pick_mask, np.ones((3, 3), np.uint8))

                if np.sum(pick_mask) > 0:
                    break

            # Trigger task reset if no object is visible.
            if pick_mask is None or np.sum(pick_mask) == 0:
                self.goals = []
                self.lang_goals = []
                print('Object for pick is not visible. Skipping demonstration.')
                return

            # Get picking pose.
            pick_prob = np.float32(pick_mask)
            pick_pix = utils.sample_distribution(pick_prob)
            # For "deterministic" demonstrations on insertion-easy, use this:
            # pick_pix = (160,80)
            pick_pos = utils.pix_to_xyz(pick_pix, hmap,
                                        self.bounds, self.pix_size)
            pick_pose = (np.asarray(pick_pos), np.asarray((0, 0, 0, 1)))

            # Get placing pose.
            targ_pose = targs[nn_targets[pick_i]]
            obj_pose = p.getBasePositionAndOrientation(objs[pick_i][0])
            if not self.sixdof:
                obj_euler = utils.quatXYZW_to_eulerXYZ(obj_pose[1])
                obj_quat = utils.eulerXYZ_to_quatXYZW((0, 0, obj_euler[2]))
                obj_pose = (obj_pose[0], obj_quat)
            world_to_pick = utils.invert(pick_pose)
            obj_to_pick = utils.multiply(world_to_pick, obj_pose)
            pick_to_obj = utils.invert(obj_to_pick)
            place_pose = utils.multiply(targ_pose, pick_to_obj)

            # Rotate end effector?
            if not rotations:
                place_pose = (place_pose[0], (0, 0, 0, 1))

            place_pose = (np.asarray(place_pose[0]), np.asarray(place_pose[1]))

            return {'pose0': pick_pose, 'pose1': place_pose}

        return OracleAgent(act)

    # -------------------------------------------------------------------------
    # Reward Function and Task Completion Metrics
    # -------------------------------------------------------------------------

    def reward(self):
        """Get delta rewards for current timestep.

        Returns:
          A tuple consisting of the scalar (delta) reward, plus `extras`
            dict which has extra task-dependent info from the process of
            computing rewards that gives us finer-grained details. Use
            `extras` for further data analysis.
        """
        reward, info = 0, {}

        # Unpack next goal step.
        objs, matches, targs, _, _, metric, params, max_reward = self.goals[0]

        # Evaluate by matching object poses.
        if metric == 'pose':
            step_reward = 0
            for i in range(len(objs)):
                object_id, (symmetry, _) = objs[i]
                pose = p.getBasePositionAndOrientation(object_id)
                targets_i = np.argwhere(matches[i, :]).reshape(-1)
                for j in targets_i:
                    target_pose = targs[j]
                    if self.is_match(pose, target_pose, symmetry):
                        step_reward += max_reward / len(objs)
                        print(f"object {i} match with target {j} rew: {step_reward}")
                        break

        # Evaluate by measuring object intersection with zone.
        elif metric == 'zone':
            zone_pts, total_pts = 0, 0
            obj_pts, zones = params
            for zone_idx, (zone_pose, zone_size) in enumerate(zones):

                # Count valid points in zone.
                for obj_idx, obj_id in enumerate(obj_pts):
                    pts = obj_pts[obj_id]
                    obj_pose = p.getBasePositionAndOrientation(obj_id)
                    world_to_zone = utils.invert(zone_pose)
                    obj_to_zone = utils.multiply(world_to_zone, obj_pose)
                    pts = np.float32(utils.apply(obj_to_zone, pts))
                    if len(zone_size) > 1:
                        valid_pts = np.logical_and.reduce([
                            pts[0, :] > -zone_size[0] / 2, pts[0, :] < zone_size[0] / 2,
                            pts[1, :] > -zone_size[1] / 2, pts[1, :] < zone_size[1] / 2,
                            pts[2, :] < self.zone_bounds[2, 1]])

                    # if zone_idx == matches[obj_idx].argmax():
                    zone_pts += np.sum(np.float32(valid_pts))
                    total_pts += pts.shape[1]
            step_reward = max_reward * (zone_pts / total_pts)

        # Get cumulative rewards and return delta.
        reward = self.progress + step_reward - self._rewards
        self._rewards = self.progress + step_reward

        # Move to next goal step if current goal step is complete.
        if np.abs(max_reward - step_reward) < 0.01:
            self.progress += max_reward  # Update task progress.
            self.goals.pop(0)
            if len(self.lang_goals) > 0:
                self.lang_goals.pop(0)

        return reward, info

    def done(self):
        """Check if the task is done or has failed.

        Returns:
          True if the episode should be considered a success, which we
            use for measuring successes, which is particularly helpful for tasks
            where one may get successes on the very last time step, e.g., getting
            the cloth coverage threshold on the last alllowed action.
            However, for bag-items-easy and bag-items-hard (which use the
            'bag-items' metric), it may be necessary to filter out demos that did
            not attain sufficiently high reward in external code. Currently, this
            is done in `main.py` and its ignore_this_demo() method.
        """
        return (len(self.goals) == 0) or (self._rewards > 0.99)
        # return zone_done or defs_done or goal_done

    # -------------------------------------------------------------------------
    # Environment Helper Functions
    # -------------------------------------------------------------------------

    def is_match(self, pose0, pose1, symmetry):
        """Check if pose0 and pose1 match within a threshold."""

        # Get translational error.
        diff_pos = np.float32(pose0[0][:2]) - np.float32(pose1[0][:2])
        dist_pos = np.linalg.norm(diff_pos)

        # Get rotational error around z-axis (account for symmetries).
        diff_rot = 0
        if symmetry > 0:
            rot0 = np.array(utils.quatXYZW_to_eulerXYZ(pose0[1]))[2]
            rot1 = np.array(utils.quatXYZW_to_eulerXYZ(pose1[1]))[2]
            diff_rot = np.abs(rot0 - rot1) % symmetry
            if diff_rot > (symmetry / 2):
                diff_rot = symmetry - diff_rot

        return (dist_pos < self.pos_eps) and (diff_rot < self.rot_eps)

    def get_random_pose(self, env, obj_size):
        """Get random collision-free object pose within workspace bounds."""

        # Get erosion size of object in pixels.
        max_size = np.sqrt(obj_size[0] ** 2 + obj_size[1] ** 2)
        erode_size = int(np.round(max_size / self.pix_size))

        _, hmap, obj_mask = self.get_true_image(env)

        # Randomly sample an object pose within free-space pixels.
        free = np.ones(obj_mask.shape, dtype=np.uint8)
        for obj_ids in env.obj_ids.values():
            for obj_id in obj_ids:
                free[obj_mask == obj_id] = 0
        free[0, :], free[:, 0], free[-1, :], free[:, -1] = 0, 0, 0, 0
        free = cv2.erode(free, np.ones((erode_size, erode_size), np.uint8))

        # if np.sum(free) == 0:
        #     return None, None

        if np.sum(free) == 0:
            # avoid returning None, None
            # return None, None
            pix = (obj_mask.shape[0] // 2, obj_mask.shape[1] // 2)
        else:
            pix = utils.sample_distribution(np.float32(free))
        pos = utils.pix_to_xyz(pix, hmap, self.bounds, self.pix_size)
        pos = (pos[0], pos[1], obj_size[2] / 2)
        theta = np.random.rand() * 2 * np.pi
        rot = utils.eulerXYZ_to_quatXYZW((0, 0, theta))
        return pos, rot

    def get_lang_goal(self):
        if len(self.lang_goals) == 0:
            return self.task_completed_desc
        else:
            return self.lang_goals[0]

    def get_reward(self):
        return float(self._rewards)

    # -------------------------------------------------------------------------
    # Helper Functions
    # -------------------------------------------------------------------------

    def fill_template(self, template, replace):
        """Read a file and replace key strings."""
        full_template_path = os.path.join(self.assets_root, template)
        with open(full_template_path, 'r') as file:
            fdata = file.read()
        for field in replace:
            for i in range(len(replace[field])):
                fdata = fdata.replace(f'{field}{i}', str(replace[field][i]))
        alphabet = string.ascii_lowercase + string.digits
        rname = ''.join(random.choices(alphabet, k=16))
        tmpdir = tempfile.gettempdir()
        template_filename = os.path.split(template)[-1]
        fname = os.path.join(tmpdir, f'{template_filename}.{rname}')
        with open(fname, 'w') as file:
            file.write(fdata)
        return fname

    def get_random_size(self, min_x, max_x, min_y, max_y, min_z, max_z):
        """Get random box size."""
        size = np.random.rand(3)
        size[0] = size[0] * (max_x - min_x) + min_x
        size[1] = size[1] * (max_y - min_y) + min_y
        size[2] = size[2] * (max_z - min_z) + min_z
        return tuple(size)

    def color_random_brown(self, obj):
        shade = np.random.rand() + 0.5
        color = np.float32([shade * 156, shade * 117, shade * 95, 255]) / 255
        p.changeVisualShape(obj, -1, rgbaColor=color)

  """""
  
  # Environment Class
  def add_object(self, urdf, pose, category='rigid'):
    """List of (fixed, rigid, or deformable) objects in env."""
    fixed_base = 1 if category == 'fixed' else 0
    obj_id = pybullet_utils.load_urdf(
        p,
        os.path.join(self.assets_root, urdf),
        pose[0],
        pose[1],
        useFixedBase=fixed_base)
    self.obj_ids[category].append(obj_id)
    return obj_id
"""

=========
Note that the objects need to obey physics and not collide with each other, and the object goal poses need to be above the table with lower bound x=0.25, y=-0.5 and upper bound x=0.75, y=0.5. When there are multiple objects for a multi-step pick-and-place task, there are often multiple subgoals. Once the task and environment are generated, an agent with a pick and place primitive will follow the defined goal to accomplish the tasks. 

Additionally, make sure you understand and summarize the ``self.goals`` variables, which has a list of 8-tuple with (objs, matches, targ_poses, replace, rotations, metric, params, step_max_reward, symmetries).
- objs (List of obj_id): object ID.
- matches (Binary Matrix): a binary matrix that denotes which object is matched with which target. This matrix has dimension len(objs) x len(targs).
- targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation). 
- replace (Boolean): whether each object can match with one unique target. This is important if we have one target and multiple objects. If it's set to be false, then any object matching with the target will satisfy.
- rotations (Boolean): whether the placement action has a rotation degree of freedom. 
- metric (`pose` or `zone`): `pose` or `zone` that the object needs to be transported to. Example: `pose`. 
- params (List of (zone_target, zone_size)): a list of (zone_target, zone_size) for each zone if the metric is `zone`. 
- step_max_reward (float): the total reward of matching all the objects with all the target poses. It is not dependent on the number of objects but dependent on the number of goals. 
- symmetries: the radians that the object is symmetric around z axis.
- language_goal: the low-level language instructions that denote the goal of this step.
 


>>> Answer: 
I understand the provided APIs and the structure of the `Task` class, which serves as a base class for defining robotic tasks in a simulation environment. Here's a summary of the key components and the `self.goals` variable:

### Key Components of the `Task` Class:
- **Initialization**: Sets up the end effector, mode, six degrees of freedom (DoF) capability, primitive actions, camera configurations, and workspace bounds.
- **Reset**: Resets the task state and initializes goals and progress.
- **Oracle**: Provides an oracle agent that can act as a perfect demonstrator using ground truth data.
- **Reward Function**: Calculates the reward based on the current state and the goals.
- **Done**: Checks if the task is completed or has failed.
- **Environment Helper Functions**: Includes functions to check if poses match, get random collision-free poses, and other utility functions.
- **Helper Functions**: Contains functions to fill templates with data, get random sizes for objects, and apply random colors.

### The `self.goals` Variable:
`self.goals` is a list of 8-tuples, each representing a subgoal in a multi-step task. Each tuple contains the following elements:

1. **objs (List of obj_id)**: A list of object IDs that are involved in the current subgoal.
2. **matches (Binary Matrix)**: A binary matrix indicating which objects are matched with which target poses. The dimensions are `len(objs)` by `len(targ_poses)`.
3. **targ_poses (List of Poses)**: A list of target poses, where each pose is a tuple of translation (x, y, z) and rotation (quaternion q0, q1, q2, q3).
4. **replace (Boolean)**: Indicates whether objects can match with multiple targets (`True`) or if each target is unique to an object (`False`).
5. **rotations (Boolean)**: Specifies whether the placement action includes a rotational degree of freedom.
6. **metric (`pose` or `zone`)**: The metric used to evaluate the task, either by matching object poses (`pose`) or by measuring object intersection with a zone (`zone`).
7. **params (List of (zone_target, zone_size))**: If the metric is `zone`, this is a list of tuples, each containing a zone target pose and size.
8. **step_max_reward (float)**: The maximum reward for completing the current subgoal.
9. **symmetries**: The radians of rotational symmetry around the z-axis for the objects.
10. **language_goal**: A string providing low-level language instructions describing the goal of the current step.

Understanding these components is crucial for implementing the "palette-arrangement-challenge" task, as they provide the mechanisms to define the task's goals, evaluate progress, and interact with the simulation environment.

================= Code Generation!

>>> Prompt: 
Now I will provide you some reference code and you can write the code for the task "palette-arrangement-challenge".


"""
import os

import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils


class PackingShapes(Task):
    """pick up randomly sized shapes and place them tightly into a container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 1
        self.homogeneous = False

        self.lang_template = "pack the {obj} in the brown box"
        self.task_completed_desc = "done packing shapes."
        self.additional_reset()


    def reset(self, env):
        super().reset(env)

        # Shape Names:
        shapes = utils.assembling_kit_shapes

        n_objects = 5
        if self.mode == 'train':
            obj_shapes = np.random.choice(self.train_set, n_objects, replace=False)
        else:
            if self.homogeneous:
                obj_shapes = [np.random.choice(self.test_set, replace=False)] * n_objects
            else:
                obj_shapes = np.random.choice(self.test_set, n_objects, replace=False)

        # Shuffle colors to avoid always picking an object of the same color
        colors, color_names = utils.get_colors(mode=self.mode)

        # Add container box.
        zone_size = self.get_random_size(0.1, 0.15, 0.1, 0.15, 0.05, 0.05)
        zone_pose = self.get_random_pose(env, zone_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': zone_size, 'HALF': (zone_size[0] / 2, zone_size[1] / 2, zone_size[2] / 2)}
        # IMPORTANT: REPLACE THE TEMPLATE URDF with `fill_template`
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, zone_pose, 'fixed')

        # Add objects.
        objects = []
        template = 'kitting/object-template.urdf'
        for i in range(n_objects):
            shape = obj_shapes[i]

            # x, y, z dimensions for the asset size
            size = (0.08, 0.08, 0.02)
            pose= self.get_random_pose(env, size)
            fname = f'{shape:02d}.obj'
            fname = os.path.join(self.assets_root, 'kitting', fname)
            scale = [0.003, 0.003, 0.001]  # .0005
            replace = {'FNAME': (fname,),
                       'SCALE': scale,
                       'COLOR': colors[i]}

            # IMPORTANT: REPLACE THE TEMPLATE URDF
            urdf = self.fill_template(template, replace)
            block_id = env.add_object(urdf, pose)
            objects.append(block_id)

        # Pick the first shape.
        num_objects_to_pick = 1
        for i in range(num_objects_to_pick):
            # IMPORTANT: Specify (obj_pts, [(zone_pose, zone_size)]) for target `zone`. obj_pts is a dict
            language_goal = self.lang_template.format(obj=shapes[obj_shapes[i]])
            self.add_goal(objs=[objects[i]], matches=np.int32([[1]]), targ_poses=[zone_pose], replace=False,
                rotations=True, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1 / num_objects_to_pick,
                language_goal=language_goal)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p


class PlaceRedInGreen(Task):
    """pick up the red blocks and place them into the green bowls amidst other objects."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10
        self.lang_template = "put the red blocks in a green bowl"
        self.task_completed_desc = "done placing blocks in bowls."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)
        n_bowls = np.random.randint(1, 4)
        n_blocks = np.random.randint(1, n_bowls + 1)

        # Add bowls.
        # x, y, z dimensions for the asset size
        bowl_size = (0.12, 0.12, 0)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(n_bowls):
            bowl_pose = self.get_random_pose(env, obj_size=bowl_size)
            env.add_object(urdf=bowl_urdf, pose=bowl_pose, category='fixed')
            bowl_poses.append(bowl_pose)

        # Add blocks.
        # x, y, z dimensions for the asset size
        blocks = []
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'
        for _ in range(n_blocks):
            block_pose = self.get_random_pose(env, obj_size=block_size)
            block_id = env.add_object(block_urdf, block_pose)
            blocks.append(block_id)

        # Goal: each red block is in a different green bowl.
        self.add_goal(objs=blocks, matches=np.ones((len(blocks), len(bowl_poses))), targ_poses=bowl_poses, replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1, language_goal=self.lang_template)

        # Colors of distractor objects.
        bowl_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'green']
        block_colors = [utils.COLORS[c] for c in utils.COLORS if c != 'red']

        # Add distractors.
        n_distractors = 0
        while n_distractors < 6:
            is_block = np.random.rand() > 0.5
            urdf = block_urdf if is_block else bowl_urdf
            size = block_size if is_block else bowl_size
            colors = block_colors if is_block else bowl_colors
            pose = self.get_random_pose(env, obj_size=size)
            color = colors[n_distractors % len(colors)]

            obj_id = env.add_object(urdf, pose, color=color)
            n_distractors += 1
"""
"""
import numpy as np
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils


class SweepingPiles(Task):
    """Push piles of small objects into a target goal zone marked on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 20
        self.lang_template = "push the pile of blocks into the green square"
        self.task_completed_desc = "done sweeping."
        self.primitive = primitives.push
        self.ee = Spatula
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add goal zone.
        zone_size = (0.12, 0.12, 0)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add pile of small blocks with `make_piles` function
        obj_ids = self.make_piles(env)

        # Add goal
        self.add_goal(objs=obj_ids, matches=np.ones((50, 1)), targ_poses=[zone_pose], replace=True,
                rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1, language_goal=self.lang_template)
"""
"""
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
import pybullet as p

class StackBlockPyramid(Task):
    """Build a pyramid of colored blocks in a color sequence"""

    def __init__(self):
        super().__init__()
        self.max_steps = 12
        self.lang_template = "make the {row} row with {blocks}"
        self.task_completed_desc = "done stacking block pyramid."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Add base.
        base_size = (0.05, 0.15, 0.005)
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Block colors.
        colors = [
            utils.COLORS['purple'], utils.COLORS['blue'], utils.COLORS['green'],
            utils.COLORS['yellow'], utils.COLORS['orange'], utils.COLORS['red']
        ]

        # Add blocks.
        block_size = (0.04, 0.04, 0.04)
        block_urdf = 'stacking/block.urdf'

        objs = []
        for i in range(6):
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=colors[i])
            objs.append(block_id)

        # IMPORTANT Associate placement locations for goals.
        place_pos = [(0, -0.05, 0.03), (0, 0, 0.03),
                     (0, 0.05, 0.03), (0, -0.025, 0.08),
                     (0, 0.025, 0.08), (0, 0, 0.13)]
        targs = [(utils.apply(base_pose, i), base_pose[1]) for i in place_pos]

        # Goal: blocks are stacked in a pyramid (bottom row: green, blue, purple).
        language_goal = self.lang_template.format(blocks="the green, blue and purple blocks", row="bottom")
        self.add_goal(objs=objs[:3], matches=np.ones((3, 3)), targ_poses=targs[:3], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 2, symmetries=[np.pi/2]*3, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (middle row: yellow, orange).
        language_goal = self.lang_template.format(blocks="the yellow and orange blocks", row="middle")      
        self.add_goal(objs=objs[3:5], matches=np.ones((2, 2)), targ_poses=targs[3:5], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 3, symmetries=[np.pi/2]*2, language_goal=language_goal)

        # Goal: blocks are stacked in a pyramid (top row: red).
        language_goal = self.lang_template.format(blocks="the red block", row="top")
        self.add_goal(objs=objs[5:], matches=np.ones((1, 1)), targ_poses=targs[5:], replace=False,
                rotations=True, metric='pose', params=None, step_max_reward=1 / 6, symmetries=[np.pi/2]*1, language_goal=language_goal)
"""



Do not use libraries, functions, and assets that you don't know. For each object, try to describe its color, size, category in the task first before you write the code. You do not need extra helper functions. Comment the code liberally to explain what each piece does and why it's written that way. If you have only one goal, `step_max_reward` in `add_goal` should be 1. Use functions `make_piles` and `make_ropes` for creating piles and cables. To use spatula together with the push primitives, import the libraries 
"""
from cliport.tasks import primitives;
from cliport.tasks.grippers import Spatula
"""
and then use `self.primitive = primitives.push` and `self.ee = Spatula`.
Note that the number of language goals usually match the number of motion goals, since they should correspond to each other.

Before generate code, you have a few considerations to focus on:
1. You are strictly prohibited from using function interfaces that do not appear in the above sample code. For example, the module cliport.tasks.primitives does not have pick_plack or place functions, only the push function interface is available.
2. Module 'cliport.tasks.primitives' has no attribute 'pick_place', you mustn't use it.
3. There are two types of your Gripper, one is Spatula and the other is Suction.You need to choose a different end-effector depending on your task requirements. If you need to move an object on the Z axis, then you need to use the Suction type. If you just need to translate an object in a 2D plane, then you can use either Spatula or Suction type.
4. You must determine the type of end-effector you need to use based on the type of task you have. You can choose by adding self.ee=Spatula or self.ee=Suction to the __init__(self) function, the default self.ee is Suction.
5. If you want to use Suction, you must import module using "from cliport.tasks.grippers import Suction". Else if you want to use Spatula, you must import module using "from cliport.tasks.grippers import Spatula".
6. The x-coordinate of the object is in the range [0.25, 0.75], the y-coordinate is in the range [-0.5,0.5] and the z-coordinate is in the range [0, 0.3].
7. The initial position of all objects needs to get its random initial position through the get_random_pose function.
8. The self.max_steps parameter value should be greater than the number of calls to self.add_goal, and preferably equal to twice the number of calls to self.add_goal. For example, if you call self.add_goal twice in one task, then self.max_steps is better set to 4.

If you want to generate the color of the object, you have to obey following rules:
1. You must use the utils.COLORS['COLOR_NAME'] function interface to generate an RGB three-channel value for a color.
2. The available colors for 'COLOR_NAME' are blue, red, green, orange, yellow, purple, pink, cyan, brown, white, gray, indigo, violet, black, silver and gold.
3. If you want to generate a red object, then its RGB three-channel color can be obtained through utils.COLORS['red'].
All object’s colors generation must follow color generation method above.

If you want to generate the target pose of the object(third parameter of function 'self.add_goal' targ_poses), you have to obey following rules:
1. The target pose of an object is represented by the three-dimensional spatial coordinates of the object and its orientation quaternion.
2. The target pose of an object must be represented by [(x,y,z),(q1,q2,q3,q4)]. Where (x,y,z) are the three-dimensional coordinates of the object and (q1,q2,q3,q4) denote the quaternions of the object's target pose.
3. The target pose of an object must be generated by you or use the initial pose of an object as the target pose of the current object.
4. Here's an example, to generate the target pose of a Y object, we have the initial pose information of an X object. So target pose of Y can be represented by pose_y=[(x,y,z),(q1,q2,q3,q4)] or pose_y=initial_pose_x.(Where x,y,z,q1,q2,q3,q4 are specific values.)
5. targ_poses (List of Poses [(translation [x,y,z], rotation [q0,q1,q2,q3])] ): a list of target poses of tuple (translation, rotation).
6. The targ_poses you generate must contain translation[x,y,z], but rotation[q0,q1,q2,q3] you may or may not generate.
All object's target pose generation must follow method above.

Now write the code for the task "palette-arrangement-challenge" in python code block starting with ```python.  Reminder: {'task-name': 'palette-arrangement-challenge', 'task-description': 'Arrange a set of five differently colored blocks on a pallet, each in a specific zone marked with a corresponding color, ensuring that no block is touching another.', 'assets-used': ['pallet/pallet.urdf', 'zone/zone.urdf', 'stacking/block.urdf']} 


>>> Answer: 
```python
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PaletteArrangementChallenge(Task):
    """
    Arrange a set of five differently colored blocks on a pallet,
    each in a specific zone marked with a corresponding color,
    ensuring that no block is touching another.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Set to twice the number of goals
        self.ee = Suction  # Use Suction end-effector to move blocks in Z axis
        self.lang_template = "place the {color} block in the {color} zone"
        self.task_completed_desc = "done arranging the blocks on the palette."

    def reset(self, env):
        super().reset(env)

        # Define the colors for the blocks and zones
        block_colors = ['red', 'green', 'blue', 'yellow', 'purple']
        np.random.shuffle(block_colors)  # Shuffle to randomize block order

        # Add pallet
        pallet_size = (0.3, 0.3, 0.02)  # Size of the pallet
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object('pallet/pallet.urdf', pallet_pose, 'fixed')

        # Add zones on the pallet for each color
        zone_size = (0.05, 0.05, 0)  # Size of each zone
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for i, color in enumerate(block_colors):
            # Calculate zone position on the pallet
            x = 0.25 + (i % 2) * 0.1  # Alternate between two x positions
            y = -0.5 + (i // 2) * 0.1  # Stack zones along y-axis
            z = 0.02  # Height of the pallet
            zone_pose = ((x, y, z), (0, 0, 0, 1))  # No rotation for zones
            zone_id = env.add_object(zone_urdf, zone_pose, color=utils.COLORS[color])
            zone_poses.append(zone_pose)

        # Add blocks
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks
        block_urdf = 'stacking/block.urdf'
        blocks = []
        for color in block_colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Define goals for each block to be in the corresponding zone
        for i, (block_id, color) in enumerate(zip(blocks, block_colors)):
            language_goal = self.lang_template.format(color=color)
            self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[zone_poses[i]],
                          replace=False, rotations=False, metric='zone',
                          params=[(zone_poses[i], zone_size)], step_max_reward=1,
                          language_goal=language_goal)

        # Set the task to be completed after arranging all blocks
        self.max_steps = len(blocks) * 2  # Allow two steps per block
```

This code defines a task where five colored blocks must be arranged on a pallet, each in a specific zone marked with a corresponding color. The `Suction` end-effector is used to move the blocks vertically, and the task is set up to allow two steps per block for a total of ten steps. Each block has a goal defined by its color, and the blocks must be placed in the zones without touching each other. The zones are added to the pallet in a fixed pattern, and the blocks are randomly placed in the environment at the start of the task. The language goal for each step describes the action to be taken, such as "place the red block in the red zone".

================= TRIAL: 14

================= Code Reflect!

>>> Prompt: 


Do you think your task is sufficently interesting to be added as a new task for future task given that we already have the following task name and descriptions? Moreover, does the simulation code achieve the goal and the language descriptions in the task? Be as rigorous and high-standard as possible.

Reminder:
your task:
{'task-name': 'palette-arrangement-challenge', 'task-description': 'Arrange a set of five differently colored blocks on a pallet, each in a specific zone marked with a corresponding color, ensuring that no block is touching another.', 'assets-used': ['pallet/pallet.urdf', 'zone/zone.urdf', 'stacking/block.urdf']}

import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PaletteArrangementChallenge(Task):
    """
    Arrange a set of five differently colored blocks on a pallet,
    each in a specific zone marked with a corresponding color,
    ensuring that no block is touching another.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Set to twice the number of goals
        self.ee = Suction  # Use Suction end-effector to move blocks in Z axis
        self.lang_template = "place the {color} block in the {color} zone"
        self.task_completed_desc = "done arranging the blocks on the palette."

    def reset(self, env):
        super().reset(env)

        # Define the colors for the blocks and zones
        block_colors = ['red', 'green', 'blue', 'yellow', 'purple']
        np.random.shuffle(block_colors)  # Shuffle to randomize block order

        # Add pallet
        pallet_size = (0.3, 0.3, 0.02)  # Size of the pallet
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object('pallet/pallet.urdf', pallet_pose, 'fixed')

        # Add zones on the pallet for each color
        zone_size = (0.05, 0.05, 0)  # Size of each zone
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for i, color in enumerate(block_colors):
            # Calculate zone position on the pallet
            x = 0.25 + (i % 2) * 0.1  # Alternate between two x positions
            y = -0.5 + (i // 2) * 0.1  # Stack zones along y-axis
            z = 0.02  # Height of the pallet
            zone_pose = ((x, y, z), (0, 0, 0, 1))  # No rotation for zones
            zone_id = env.add_object(zone_urdf, zone_pose, color=utils.COLORS[color])
            zone_poses.append(zone_pose)

        # Add blocks
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks
        block_urdf = 'stacking/block.urdf'
        blocks = []
        for color in block_colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Define goals for each block to be in the corresponding zone
        for i, (block_id, color) in enumerate(zip(blocks, block_colors)):
            language_goal = self.lang_template.format(color=color)
            self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[zone_poses[i]],
                          replace=False, rotations=False, metric='zone',
                          params=[(zone_poses[i], zone_size)], step_max_reward=1,
                          language_goal=language_goal)

        # Set the task to be completed after arranging all blocks
        self.max_steps = len(blocks) * 2  # Allow two steps per block

current task list:
- sweeping-piles: {'assets-used': ['zone/zone.urdf', 'block/small.urdf'], 'task-description': 'push piles of small objects into a target goal zone marked on the tabletop.', 'task-name': 'sweeping-piles'}
- place-red-in-green: {'assets-used': ['bowl/bowl.urdf', 'stacking/block.urdf'], 'task-description': 'pick up the red blocks and place them into the green bowls amidst other objects.', 'task-name': 'place-red-in-green'}
- align-box-corner: {'assets-used': ['box/box-template.urdf', 'corner/corner-template.urdf'], 'task-description': 'pick up the randomly sized box and align one of its corners to the L-shaped marker on the tabletop..', 'task-name': 'align-box-corner'}
- stack-block-pyramid: {'assets-used': ['stacking/stand.urdf', 'stacking/block.urdf'], 'task-description': 'sequentially stack 6 blocks into a pyramid of 3-2-1 with rainbow colored ordering.', 'task-name': 'stack-block-pyramid'}
- palletizing-boxes: {'assets-used': ['pallet/pallet.urdf', 'box/box-template.urdf'], 'task-description': 'pick up homogeneous fixed-sized boxes and stack them in transposed layers on the pallet.', 'task-name': 'palletizing-boxes'}
- assembling-kits: {'assets-used': ['kitting/kit.urdf', 'kitting/object-template.urdf'], 'task-description': 'pick up different objects and arrange them on a board marked with corresponding silhouettes.', 'task-name': 'assembling-kits'}
- packing-boxes: {'assets-used': ['container/container-template.urdf', 'box/box-template.urdf'], 'task-description': 'pick up randomly sized boxes and place them tightly into a container.', 'task-name': 'packing-boxes'}
- manipulating-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'rearrange a deformable rope such that it connects the two endpoints of a 3-sided square.', 'task-name': 'manipulating-rope'}
- align-rope: {'assets-used': ['square/square-template.urdf'], 'task-description': 'manipulate a deformable rope to connect its end-points between two corners of a 3-sided square.', 'task-name': 'align-rope'}
- cylinder_hurdle_arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- cylinder-hurdle-arrangement: {'task-name': 'cylinder-hurdle-arrangement', 'task-description': 'Arrange six different colored cylinders in ascending order of height over a sequence of three increasingly tall stands while avoiding the box obstacles placed between them.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf', 'box/box-template.urdf']}
- color_coded_pallet_organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color-coded-pallet-organization: {'task-name': 'color-coded-pallet-organization', 'task-description': 'Arrange a series of colored cylinders on a pallet by matching the cylinder colors to the designated colored zones on the pallet, ensuring that each cylinder is placed within the boundaries of its corresponding zone.', 'assets-used': ['pallet/pallet.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- cylinder_tower_balancing: {'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}
- cylinder-tower-balancing: {'task-name': 'cylinder-tower-balancing', 'task-description': 'Construct a balanced tower using three differently sized cylinders by stacking them on top of each other from largest at the bottom to smallest at the top on a single stand without toppling over.', 'assets-used': ['cylinder/cylinder-template.urdf', 'stacking/stand.urdf']}
- color_gradient_tower: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- color-gradient-tower: {'task-name': 'color-gradient-tower', 'task-description': 'Build a tower using six differently colored cylinders by stacking them onto a stand in an order that creates a color gradient from darkest to lightest, while avoiding placement inside marked no-go zones.', 'assets-used': ['stacking/stand.urdf', 'cylinder/cylinder-template.urdf', 'zone/zone.urdf']}
- precision_box_placement: {'task-name': 'precision-box-placement', 'task-description': "Pick up a small blue box and place it precisely within the bounds of a marked white zone on a pallet, ensuring the box does not touch the zone's edges.", 'assets-used': ['box/box-template.urdf', 'zone/zone.urdf', 'pallet/pallet.urdf']}
- gradient_tower_placement: {'task-name': 'gradient-tower-placement', 'task-description': 'Build two separate towers each made of three differently colored cylinders, placing them on a patterned zone marked with two distinct areas, one for each tower, while ensuring that the cylinders in each tower are arranged in a color gradient sequence from the lightest on top to the darkest at the base.', 'assets-used': ['cylinder/cylinder-template.urdf', 'zone/zone.urdf']}




=========
Reply explain your reasons and then say True or False, formatted in a python dictionary, do not miss commas or add extra spaces. Here are some examples.

{
	"task_name": "sort-color-blocks",
	"task_descriptions": "Pick up differently colored blocks and place them into separate bowls of matching color."
    "assets-used": ["bowl.urdf", "yellow-bowl.urdf", "box/box-template.urdf],
	"reasons": "not interesting because it overlaps with the current task `put-block-in-bowl`"
	"add_to_the_task_list": "False",
}

{
  	"task-name": "guided-ball-maze",
  	"task-description": "Navigate a small ball through a maze by tilting the maze board to reach the target zone.",
  	"assets-used": ["zone-template.urdf", "square-template.urdf", "ball.urdf", "maze.urdf"],
   	"reasons": "the language descriptions are too ambiguous. Navigation is also hard to complete."
  	"add_to_the_task_list": "False",  
}

{
 	"task-name": "sort-blocks-by-zone",
 	"task-description": "Sort different colored blocks into their corresponding colored zones marked on the tabletop.",
 	"assets-used": ["zone/zone.urdf", "stacking/block.urdf"],
	"reasons": "the task is not covered in the current list and is an interesting combination of zone and block objects." 
	"add_to_the_task_list": "True",
}

{
    "task-name": "insert_cylinder_in_sphere",
    "task-description": "Pick up the cylinder and insert it into the sphere with an opening on top.",
    "assets-used": ["cylinder/cylinder-template.urdf", "sphere/sphere-template.urdf"],
    "reasons": "this task does not make sense. The sphere does not have an opening on top, and you cannot insert a cylinder into a sphere.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "arrange-blocks-on-pallet",
    "task-description": "arrange the blocks on the pallet in the order: red, orange, yellow, green, blue, and purple.",
    "assets-used": ["stacking/block.urdf", "pallet/pallelt.urdf"],
    "reasons": "this task overlaps with `arrange-boxes-on-pallet` by merely changing the blocks to boxes.", 
    "add_to_the_task_list": "False",
}

{
    "task-name": "cylinder-color-alignment",
    "task-description": "Pick up cylinders of different colors and align them inside a box in the order of the colors displayed on the single green line on the tabletop.",
    "assets-used": ["cylinder/cylinder-template.urdf", "box/box-template.urdf", "line/single-green-line-template.urdf   
    "reasons": "the execution code only has one goal, i.e. it will only move one cylinder on top of the box, which is not that interesting.", 
    "add_to_the_task_list": "False","]
}

{
    "task-name": "build-bridge",
    "task-description": "Construct a bridge using two yellow blocks and three blue blocks. Firstly, place the two yellow blocks on each of the two bases parallel to each other with a fair amount of space in between. Then, place the blue block horizontally on top of the yellow blocks.",
     "assets-used": ["block/block.urdf", "ball/ball-template.urdf"]
    "reasons": "this task is an interesting and long-horizon task for pick and place primitives. Training manipulation agent with this skill will be a useful building block for next skills.", 
    "add_to_the_task_list": "True",
}

=========

Please incorporate these feedbacks when you design new task!



>>> Answer: 
{
    "task-name": "palette-arrangement-challenge",
    "task-description": "Arrange a set of five differently colored blocks on a pallet, each in a specific zone marked with a corresponding color, ensuring that no block is touching another.",
    "assets-used": ["pallet/pallet.urdf", "zone/zone.urdf", "stacking/block.urdf"],
    "reasons": "The task is somewhat similar to 'color-coded-pallet-organization' but with a different object type (blocks instead of cylinders) and an additional constraint (ensuring blocks do not touch each other). However, the task may not be sufficiently novel or complex to warrant addition, given the existing tasks that involve sorting objects by color and placing them in designated zones.",
    "add_to_the_task_list": "False"
}