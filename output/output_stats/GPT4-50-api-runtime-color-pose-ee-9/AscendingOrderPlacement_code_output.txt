import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class AscendingOrderPlacement(Task):
    """Arrange cylinders and blocks by height in ascending order on a marked zone on the tabletop."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we will have at most 5 objects to place, 2 steps per object
        self.lang_template = "place the {shape} in ascending order on the marked zone"
        self.task_completed_desc = "done arranging in ascending order."
        self.ee = Suction  # Use suction end-effector to pick and place objects in 3D space

    def reset(self, env):
        super().reset(env)

        # Define the number of cylinders and blocks
        n_objects = 5

        # Add the goal zone
        zone_size = (0.3, 0.3, 0)  # Define a reasonable size for the zone to fit all objects
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Initialize lists for objects and their sizes
        objects = []
        object_sizes = []

        # Add cylinders and blocks alternatively, starting with the shortest cylinder
        for i in range(n_objects):
            if i % 2 == 0:  # Cylinder
                # Generate a random height for the cylinder
                height = np.random.uniform(0.05, 0.15)
                size = (0.04, 0.04, height)  # Diameter is fixed, height varies
                color = utils.COLORS['blue']  # Assign blue color to cylinders
                template = 'cylinder/cylinder-template.urdf'
                replace = {'SIZE': size, 'COLOR': color}
                urdf = self.fill_template(template, replace)
            else:  # Block
                # Generate a random height for the block
                height = np.random.uniform(0.05, 0.15)
                size = (0.04, 0.04, height)  # Width and length are fixed, height varies
                color = utils.COLORS['red']  # Assign red color to blocks
                urdf = 'stacking/block.urdf'

            # Get a random pose for the object
            pose = self.get_random_pose(env, size)
            # Add the object to the environment
            obj_id = env.add_object(urdf, pose, color=color if i % 2 == 0 else None)
            objects.append(obj_id)
            object_sizes.append(size[2])  # Store the height for sorting

        # Sort objects by height in ascending order
        sorted_indices = np.argsort(object_sizes)
        sorted_objects = [objects[i] for i in sorted_indices]

        # Define the target poses for each object in the sorted list
        for i, obj_id in enumerate(sorted_objects):
            # Calculate the x offset to place objects next to each other without touching
            x_offset = zone_pose[0][0] - zone_size[0] / 2 + 0.05 * (i + 1)
            # Define the target pose
            targ_pose = [(x_offset, zone_pose[0][1], zone_pose[0][2]), (0, 0, 0, 1)]
            # Add the goal for the object
            self.add_goal(objs=[obj_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/n_objects,
                          language_goal=self.lang_template.format(shape='cylinder' if i % 2 == 0 else 'block'))