import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ColorCodedContainerArrangement(Task):
    """Identify and pick up three small blue boxes and three small red cylinders and arrange them alternately in a green container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 12  # We have 6 objects to place, so max_steps is set to twice that number
        self.lang_template = "put the {color} {shape} in the green container"
        self.task_completed_desc = "done arranging the color-coded objects."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors and shapes for the objects
        blue_color = utils.COLORS['blue']
        red_color = utils.COLORS['red']
        green_color = utils.COLORS['green']
        box_shape = 'box'
        cylinder_shape = 'cylinder'

        # Define the size for the boxes and cylinders
        box_size = (0.04, 0.04, 0.04)  # Small box size
        cylinder_size = (0.03, 0.03, 0.06)  # Small cylinder size

        # Add green container
        container_size = self.get_random_size(0.2, 0.3, 0.2, 0.3, 0.05, 0.05)
        container_pose = self.get_random_pose(env, container_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, container_pose, 'fixed', color=green_color)

        # Add blue boxes and red cylinders
        objects = []
        for i in range(3):
            # Add blue box
            box_pose = self.get_random_pose(env, box_size)
            box_template = 'box/box-template.urdf'
            replace = {'DIM': box_size, 'HALF': (box_size[0] / 2, box_size[1] / 2, box_size[2] / 2)}
            box_urdf = self.fill_template(box_template, replace)
            box_id = env.add_object(box_urdf, box_pose, color=blue_color)
            objects.append((box_id, 'box'))

            # Add red cylinder
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_template = 'cylinder/cylinder-template.urdf'
            replace = {'DIM': cylinder_size, 'HALF': (cylinder_size[0] / 2, cylinder_size[1] / 2, cylinder_size[2] / 2)}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=red_color)
            objects.append((cylinder_id, 'cylinder'))

        # Define the target poses inside the container for the objects
        # We will arrange them alternately in a single row within the container
        container_x, container_y, _ = container_pose[0]
        target_poses = []
        for i in range(3):
            # Calculate positions for boxes and cylinders
            offset_x = container_x - container_size[0] / 2 + box_size[0] / 2 + i * (box_size[0] + cylinder_size[0])
            target_poses.append(((offset_x, container_y - container_size[1] / 4, container_size[2]), container_pose[1]))
            target_poses.append(((offset_x, container_y + container_size[1] / 4, container_size[2]), container_pose[1]))

        # Add goals for each object
        for i, (obj_id, shape) in enumerate(objects):
            color = 'blue' if shape == 'box' else 'red'
            language_goal = self.lang_template.format(color=color, shape=shape)
            self.add_goal(objs=[obj_id], matches=np.int32([[1]]), targ_poses=[target_poses[i]], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / 6,
                          language_goal=language_goal)

# Note: The code assumes that the container is large enough to fit all objects in a single layer without stacking.
# Adjustments may be needed based on the actual size of the container and objects.