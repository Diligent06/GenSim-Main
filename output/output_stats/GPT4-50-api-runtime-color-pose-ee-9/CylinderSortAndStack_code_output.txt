import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderSortAndStack(Task):
    """Sort five cylinders of varying sizes and colors by placing them onto the corresponding colored zones on the pallet, and then stack them in ascending order of size on the stand without toppling."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to add 5 goals for sorting and 5 for stacking
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.lang_template = "place the {color} cylinder on the {color} zone, then stack them in ascending order of size"
        self.task_completed_desc = "done sorting and stacking cylinders."

    def reset(self, env):
        super().reset(env)

        # Define the number of cylinders and their sizes
        n_cylinders = 5
        cylinder_sizes = np.linspace(0.02, 0.04, n_cylinders)  # Ascending sizes from 0.02 to 0.04

        # Define colors for cylinders and zones
        colors = ['red', 'green', 'blue', 'yellow', 'purple']
        np.random.shuffle(colors)  # Shuffle colors to avoid fixed color order

        # Add pallet
        pallet_size = (0.3, 0.3, 0.0)  # Pallet size (x, y, z)
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object('pallet/pallet.urdf', pallet_pose, 'fixed')

        # Add zones on the pallet for each color
        zone_size = (0.06, 0.06, 0.0)  # Zone size (x, y, z)
        zone_urdfs = ['zone/zone.urdf' for _ in range(n_cylinders)]
        zone_poses = [self.get_random_pose(env, zone_size) for _ in range(n_cylinders)]
        for i, zone_urdf in enumerate(zone_urdfs):
            env.add_object(zone_urdf, zone_poses[i], 'fixed', color=utils.COLORS[colors[i]])

        # Add stand for stacking
        stand_size = (0.05, 0.05, 0.15)  # Stand size (x, y, z)
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object('stacking/stand.urdf', stand_pose, 'fixed')

        # Add cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for i in range(n_cylinders):
            size = (cylinder_sizes[i], cylinder_sizes[i], 0.1)  # Cylinder size (x, y, z)
            pose = self.get_random_pose(env, size)
            replace = {'SIZE': size}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_id = env.add_object(cylinder_urdf, pose, color=utils.COLORS[colors[i]])
            cylinders.append((cylinder_id, size[0]))  # Store cylinder ID and size

        # Sort cylinders by placing them onto the corresponding colored zones
        for i, (cylinder_id, _) in enumerate(cylinders):
            language_goal = self.lang_template.format(color=colors[i])
            self.add_goal(objs=[cylinder_id], matches=np.int32([[1]]), targ_poses=[zone_poses[i]],
                          replace=False, rotations=False, metric='pose', params=None,
                          step_max_reward=1 / n_cylinders, language_goal=language_goal)

        # Stack cylinders in ascending order of size on the stand
        cylinders_sorted = sorted(cylinders, key=lambda x: x[1])  # Sort by size
        stack_height = 0.01  # Initial height for stacking
        for i, (cylinder_id, size) in enumerate(cylinders_sorted):
            stack_pose = (stand_pose[0], stand_pose[1])  # Use stand pose as base
            stack_pose[0][2] += stack_height  # Increment z-coordinate for stacking
            stack_height += size * 2  # Update stack height for next cylinder
            language_goal = self.lang_template.format(color=colors[i])
            self.add_goal(objs=[cylinder_id], matches=np.int32([[1]]), targ_poses=[stack_pose],
                          replace=False, rotations=True, metric='pose', params=None,
                          step_max_reward=1 / n_cylinders, language_goal=language_goal)