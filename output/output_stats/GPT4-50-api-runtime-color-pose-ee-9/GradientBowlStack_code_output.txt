import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class GradientBowlStack(Task):
    """
    Create a color gradient stack by placing three colored blocks within a bowl,
    ordered from the darkest to the lightest shade, without any blocks falling out of the bowl.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice that number
        self.lang_template = "place the {color} block in the bowl"
        self.task_completed_desc = "done creating a gradient stack."
        self.ee = Suction  # We need to move objects on the Z axis, so we use Suction
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the bowl properties
        bowl_size = (0.18, 0.18, 0.06)  # Size of the bowl
        bowl_urdf = 'bowl/bowl.urdf'  # URDF file for the bowl
        bowl_pose = self.get_random_pose(env, bowl_size)  # Random pose for the bowl
        env.add_object(bowl_urdf, bowl_pose, 'fixed')  # Add the bowl to the environment

        # Define the block properties
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks
        block_urdf = 'stacking/block.urdf'  # URDF file for the blocks

        # Define the colors for the gradient (darkest to lightest)
        colors = ['indigo', 'blue', 'cyan']
        color_names = ['darkest', 'medium', 'lightest']

        # Add blocks and create goals
        blocks = []
        for i, color in enumerate(colors):
            # Get a random pose for the block
            block_pose = self.get_random_pose(env, block_size)
            # Add the block to the environment with the specified color
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

            # Define the language goal for placing the block
            language_goal = self.lang_template.format(color=color_names[i])

            # The target pose for the block is inside the bowl, stacked on top of any previous blocks
            z_offset = bowl_size[2] + (i * block_size[2])  # Calculate the z offset for stacking
            targ_pose = (bowl_pose[0], (bowl_pose[1][0], bowl_pose[1][1], bowl_pose[1][2] + z_offset))

            # Add the goal for the current block
            self.add_goal(objs=[block_id], matches=np.ones((1, 1)), targ_poses=[targ_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/3, language_goal=language_goal)

        # Ensure the x, y, and z coordinates are within the specified ranges
        assert 0.25 <= bowl_pose[0][0] <= 0.75, "Bowl x-coordinate out of range"
        assert -0.5 <= bowl_pose[0][1] <= 0.5, "Bowl y-coordinate out of range"
        assert 0 <= bowl_pose[0][2] <= 0.3, "Bowl z-coordinate out of range"
        for block_pose in blocks:
            assert 0.25 <= block_pose[0][0] <= 0.75, "Block x-coordinate out of range"
            assert -0.5 <= block_pose[0][1] <= 0.5, "Block y-coordinate out of range"
            assert 0 <= block_pose[0][2] <= 0.3, "Block z-coordinate out of range"