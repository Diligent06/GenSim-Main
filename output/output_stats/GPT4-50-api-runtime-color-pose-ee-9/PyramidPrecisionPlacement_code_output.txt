import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PyramidPrecisionPlacement(Task):
    """Construct a precise color-coded pyramid by stacking blocks in a 4-3-2-1 formation on a designated zone."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to call self.add_goal 5 times, so we set max_steps to twice that number
        self.lang_template = "stack the {color} block"
        self.task_completed_desc = "done constructing the pyramid."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector

    def reset(self, env):
        super().reset(env)

        # Define the colors for each level of the pyramid
        colors = ['blue', 'green', 'yellow', 'red']

        # Add the goal zone where the pyramid will be constructed
        zone_size = (0.24, 0.24, 0)  # Size of the zone
        zone_pose = self.get_random_pose(env, zone_size)  # Random pose for the zone within the workspace bounds
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Initialize a list to keep track of the block IDs
        block_ids = []

        # Add blocks for each color
        for i, color in enumerate(colors):
            # Calculate the number of blocks in the current level of the pyramid
            num_blocks = 4 - i
            for _ in range(num_blocks):
                # Define the size of the block
                block_size = (0.04, 0.04, 0.04)  # Size of the block
                # Get a random pose for the block within the workspace bounds
                block_pose = self.get_random_pose(env, block_size)
                # Add the block to the environment with the specified color
                block_id = env.add_object('stacking/block.urdf', block_pose, color=utils.COLORS[color])
                # Keep track of the block's ID
                block_ids.append((block_id, color))

        # Define the target poses for the blocks in the pyramid formation
        # The base of the pyramid has 4 blocks, the next level has 3, then 2, and finally 1 at the top
        level_offsets = [(0.06, 0.06, 0), (0.02, 0.06, 0.04), (-0.02, 0.06, 0.04),
                         (0.06, 0.02, 0), (0.02, 0.02, 0.04), (-0.02, 0.02, 0.04),
                         (0.06, -0.02, 0), (0.02, -0.02, 0.04), (-0.02, -0.02, 0.04),
                         (0.06, -0.06, 0), (0.02, -0.06, 0.04), (-0.02, -0.06, 0.04),
                         (0.04, 0.04, 0.08), (0, 0.04, 0.08), (-0.04, 0.04, 0.08),
                         (0.04, 0, 0.08), (0, 0, 0.08), (-0.04, 0, 0.08),
                         (0.04, -0.04, 0.08), (0, -0.04, 0.08), (-0.04, -0.04, 0.08),
                         (0.02, 0.02, 0.12), (0, 0.02, 0.12), (-0.02, 0.02, 0.12),
                         (0.02, 0, 0.12), (0, 0, 0.12), (-0.02, 0, 0.12),
                         (0.02, -0.02, 0.12), (0, -0.02, 0.12), (-0.02, -0.02, 0.12),
                         (0, 0, 0.16)]  # The top block of the pyramid

        # Add goals for each block
        for i, (block_id, color) in enumerate(block_ids):
            # Calculate the target pose for the current block
            targ_pose = utils.apply(zone_pose, level_offsets[i])
            # Define the language goal for the current block
            language_goal = self.lang_template.format(color=color)
            # Add the goal for the current block
            self.add_goal(objs=[block_id], matches=np.ones((1, 1)), targ_poses=[targ_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / len(block_ids),
                          language_goal=language_goal)

        # Note: We do not need to specify symmetries for the blocks as they are cubes and have symmetry in all axes