import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ZoneSequenceBallSorting(Task):
    """Arrange a set of colored balls into a series of adjacent target zones, each corresponding to a unique color."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we will have 5 balls and 5 zones, 2 steps per ball
        self.lang_template = "put the {color} ball in the {color} zone"
        self.task_completed_desc = "done sorting all balls into their zones."
        self.ee = Suction  # Suction end-effector is suitable for picking up balls
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors and their sequence for the balls and zones
        color_sequence = ['red', 'orange', 'yellow', 'green', 'blue']
        n_balls = len(color_sequence)

        # Add target zones with corresponding colors
        zone_size = (0.1, 0.1, 0)  # Zones are flat squares on the table
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for i, color_name in enumerate(color_sequence):
            zone_pose = self.get_random_pose(env, zone_size)
            zone_color = utils.COLORS[color_name]
            env.add_object(zone_urdf, zone_pose, 'fixed', color=zone_color)
            zone_poses.append(zone_pose)

        # Add balls with corresponding colors
        ball_template = 'ball/ball-template.urdf'
        ball_size = (0.04, 0.04, 0.04)  # Size of the ball
        balls = []
        for i, color_name in enumerate(color_sequence):
            ball_pose = self.get_random_pose(env, ball_size)
            ball_color = utils.COLORS[color_name]
            replace = {'COLOR': ball_color}
            ball_urdf = self.fill_template(ball_template, replace)
            ball_id = env.add_object(ball_urdf, ball_pose)
            balls.append(ball_id)

            # Add language goal for each ball
            language_goal = self.lang_template.format(color=color_name)

            # Add goal for each ball to be in the corresponding zone
            self.add_goal(objs=[ball_id], matches=np.int32([[1]]), targ_poses=[zone_poses[i]], replace=False,
                          rotations=False, metric='zone', params=[(zone_poses[i], zone_size)], step_max_reward=1/n_balls,
                          language_goal=language_goal)

        # The zones are expected to be adjacent and form a gradient, so we sort them by x-coordinate
        zone_poses.sort(key=lambda pose: pose[0][0])

        # Ensure the balls are sorted in the same order as the zones
        for i in range(n_balls):
            # Update the target poses to be the sorted zones
            self.goals[i]['targ_poses'] = [zone_poses[i]]

        # Comment: The task is set up to have each colored ball correspond to a zone of the same color.
        # The zones are sorted to form a gradient, and the balls' goals are updated to match this order.