import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class TowerOfHanoiBlocks(Task):
    """
    Relocate a stack of three differently colored blocks from a source zone to a target zone on the tabletop,
    such that the blocks are transferred one at a time while maintaining their original order,
    mimicking the Tower of Hanoi puzzle.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We have three blocks to move, and we set max_steps to twice the number of blocks
        self.lang_template = "move the {color} block to the {zone} zone"
        self.task_completed_desc = "done relocating the Tower of Hanoi blocks."
        self.ee = Suction  # We need to move blocks on the Z axis, so we use the Suction end-effector
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors for the three blocks
        block_colors = ['red', 'green', 'blue']
        block_color_values = [utils.COLORS[color] for color in block_colors]

        # Define the size of the blocks
        block_size = (0.04, 0.04, 0.04)  # All blocks have the same size

        # Add source and target zones
        zone_size = (0.15, 0.15, 0)  # Zones are flat squares on the table
        source_zone_pose = self.get_random_pose(env, zone_size)
        target_zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', source_zone_pose, 'fixed')
        env.add_object('zone/zone.urdf', target_zone_pose, 'fixed')

        # Add blocks in the source zone, stacked on top of each other
        blocks = []
        for i, color in enumerate(block_colors):
            # Adjust the z-coordinate for stacking
            block_pose = list(source_zone_pose[0])
            block_pose[2] += i * block_size[2]
            block_pose = (block_pose, source_zone_pose[1])

            # Add the block to the environment
            block_id = env.add_object('stacking/block.urdf', block_pose, color=block_color_values[i])
            blocks.append(block_id)

        # Add goals for each block to be moved to the target zone
        for i, block_id in enumerate(blocks):
            # Define the target pose for the block in the target zone
            target_pose = list(target_zone_pose[0])
            target_pose[2] += i * block_size[2]  # Adjust the z-coordinate for stacking
            target_pose = (target_pose, target_zone_pose[1])

            # Define the language goal for the current block
            language_goal = self.lang_template.format(color=block_colors[i], zone="target")

            # Add the goal for the current block
            self.add_goal(
                objs=[block_id],
                matches=np.ones((1, 1)),  # Each block has a unique target pose
                targ_poses=[target_pose],
                replace=False,  # Blocks should not be replaced once placed
                rotations=False,  # Rotation is not considered in this task
                metric='pose',  # We are using pose metric to match the block pose to the target pose
                params=None,  # No additional parameters needed
                step_max_reward=1 / len(blocks),  # Reward is evenly distributed across the blocks
                language_goal=language_goal
            )