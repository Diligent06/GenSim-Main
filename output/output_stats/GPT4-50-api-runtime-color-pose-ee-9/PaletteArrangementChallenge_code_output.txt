import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PaletteArrangementChallenge(Task):
    """
    Arrange a set of five differently colored blocks on a pallet,
    each in a specific zone marked with a corresponding color,
    ensuring that no block is touching another.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Set to twice the number of goals
        self.ee = Suction  # Use Suction end-effector to move blocks in Z axis
        self.lang_template = "place the {color} block in the {color} zone"
        self.task_completed_desc = "done arranging the blocks on the palette."

    def reset(self, env):
        super().reset(env)

        # Define the colors for the blocks and zones
        block_colors = ['red', 'green', 'blue', 'yellow', 'purple']
        np.random.shuffle(block_colors)  # Shuffle to randomize block order

        # Add pallet
        pallet_size = (0.3, 0.3, 0.02)  # Size of the pallet
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object('pallet/pallet.urdf', pallet_pose, 'fixed')

        # Add zones on the pallet for each color
        zone_size = (0.05, 0.05, 0)  # Size of each zone
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for i, color in enumerate(block_colors):
            # Calculate zone position on the pallet
            x = 0.25 + (i % 2) * 0.1  # Alternate between two x positions
            y = -0.5 + (i // 2) * 0.1  # Stack zones along y-axis
            z = 0.02  # Height of the pallet
            zone_pose = ((x, y, z), (0, 0, 0, 1))  # No rotation for zones
            zone_id = env.add_object(zone_urdf, zone_pose, color=utils.COLORS[color])
            zone_poses.append(zone_pose)

        # Add blocks
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks
        block_urdf = 'stacking/block.urdf'
        blocks = []
        for color in block_colors:
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Define goals for each block to be in the corresponding zone
        for i, (block_id, color) in enumerate(zip(blocks, block_colors)):
            language_goal = self.lang_template.format(color=color)
            self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[zone_poses[i]],
                          replace=False, rotations=False, metric='zone',
                          params=[(zone_poses[i], zone_size)], step_max_reward=1,
                          language_goal=language_goal)

        # Set the task to be completed after arranging all blocks
        self.max_steps = len(blocks) * 2  # Allow two steps per block