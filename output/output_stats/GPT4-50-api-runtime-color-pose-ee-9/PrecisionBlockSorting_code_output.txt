import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PrecisionBlockSorting(Task):
    """Sort a set of colored blocks by placing them onto a zone mat, aligning each block within its specifically colored zone without stacking them or letting them touch each other."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we have 5 blocks to sort, 2 steps per block (pick and place)
        self.lang_template = "place the {color} block in the {color} zone"
        self.task_completed_desc = "done sorting blocks."
        self.ee = Suction  # Use suction end-effector to pick and place blocks

    def reset(self, env):
        super().reset(env)

        # Define the number of blocks and zones
        n_blocks = 5
        n_zones = n_blocks  # One zone for each block

        # Define block size
        block_size = (0.04, 0.04, 0.04)  # x, y, z dimensions for the block size

        # Define colors for blocks and zones
        block_colors = ['red', 'blue', 'green', 'yellow', 'purple']
        np.random.shuffle(block_colors)  # Shuffle colors to avoid any fixed order

        # Add blocks with random initial poses
        blocks = []
        for i in range(n_blocks):
            block_pose = self.get_random_pose(env, block_size)
            block_color = utils.COLORS[block_colors[i]]
            block_urdf = 'stacking/block.urdf'
            block_id = env.add_object(block_urdf, block_pose, color=block_color)
            blocks.append((block_id, block_colors[i]))

        # Add zones with fixed poses
        zone_size = (0.05, 0.05, 0)  # x, y, z dimensions for the zone size
        zone_urdf = 'zone/zone.urdf'
        zone_poses = []
        for i in range(n_zones):
            # Calculate fixed positions for zones
            x = 0.25 + (i % 3) * 0.15
            y = -0.5 + (i // 3) * 0.15
            z = 0.001  # Slightly above the table to be visible
            zone_pose = ((x, y, z), (0, 0, 0, 1))  # No rotation for zones
            zone_color = utils.COLORS[block_colors[i]]
            env.add_object(zone_urdf, zone_pose, 'fixed', color=zone_color)
            zone_poses.append((zone_pose, block_colors[i]))

        # Add goals for each block to be placed in the matching color zone
        for block, color in blocks:
            # Find the corresponding zone pose for the block color
            zone_pose, _ = next((zp for zp, zc in zone_poses if zc == color), None)
            if zone_pose:
                language_goal = self.lang_template.format(color=color)
                self.add_goal(objs=[block], matches=np.int32([[1]]), targ_poses=[zone_pose],
                              rotations=False, metric='pose', params=None, step_max_reward=1/n_blocks,
                              language_goal=language_goal)

    def additional_reset(self):
        # Any additional reset steps can be defined here
        pass