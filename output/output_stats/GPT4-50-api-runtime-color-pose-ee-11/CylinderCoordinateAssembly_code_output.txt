import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderCoordinateAssembly(Task):
    """Assemble a structure by placing three different-colored cylinders onto the corresponding colored corners of a zone."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We have 3 goals, so max_steps is twice the number of goals
        self.lang_template = "place the {color} cylinder on the {color} corner"
        self.task_completed_desc = "done assembling the cylinders."
        self.ee = Suction  # Use Suction end-effector to pick and place cylinders vertically

    def reset(self, env):
        super().reset(env)

        # Define cylinder size and colors
        cylinder_size = (0.05, 0.05, 0.15)  # Diameter, Diameter, Height
        cylinder_colors = ['red', 'green', 'blue']
        cylinder_color_values = [utils.COLORS[color] for color in cylinder_colors]

        # Add zone
        zone_size = (0.3, 0.3, 0)  # Length, Width, Height (flat on the surface)
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add corners to the zone with corresponding colors
        corner_template = 'corner/corner-template.urdf'
        corner_size = (0.05, 0.05, 0.05)  # Length, Width, Height
        corner_poses = []
        for i, color in enumerate(cylinder_colors):
            # Calculate corner positions based on the zone pose
            corner_x = zone_pose[0][0] + (i - 1) * zone_size[0] / 2
            corner_y = zone_pose[0][1] + (i - 1) * zone_size[1] / 2
            corner_pose = ((corner_x, corner_y, zone_pose[0][2]), zone_pose[1])
            replace = {'COLOR': cylinder_color_values[i]}
            corner_urdf = self.fill_template(corner_template, replace)
            env.add_object(corner_urdf, corner_pose, 'fixed')
            corner_poses.append(corner_pose)

        # Add cylinders
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinders = []
        for i, color in enumerate(cylinder_colors):
            pose = self.get_random_pose(env, cylinder_size)
            replace = {'COLOR': cylinder_color_values[i]}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_id = env.add_object(cylinder_urdf, pose)
            cylinders.append(cylinder_id)

            # Add goal for each cylinder
            language_goal = self.lang_template.format(color=color)
            self.add_goal(objs=[cylinder_id], matches=np.int32([[1]]), targ_poses=[corner_poses[i]],
                          replace=False, rotations=False, metric='pose', params=None,
                          step_max_reward=1 / 3, language_goal=language_goal)

# Note: The cylinders are expected to be placed upright, so rotations are not considered in the goals (rotations=False).
# The target poses for the cylinders are the positions of the corners, which are calculated based on the zone's pose.
# The cylinders are matched with the corners of the same color, and the language goal reflects this one-to-one relationship.