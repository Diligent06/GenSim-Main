import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class HeightOrderedTowerChallenge(Task):
    """Construct a height-ordered tower by stacking three different-sized cylinders on a designated zone."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice the number of goals
        self.lang_template = "stack the {color} cylinder {position} in the tower"
        self.task_completed_desc = "done building the height-ordered tower."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector

    def reset(self, env):
        super().reset(env)

        # Define the sizes for the cylinders (height, radius)
        sizes = [(0.12, 0.04), (0.08, 0.03), (0.04, 0.02)]  # Large, medium, small

        # Define the colors for the cylinders
        colors = [utils.COLORS['red'], utils.COLORS['green'], utils.COLORS['blue']]

        # Add the zone where the tower will be built
        zone_size = (0.15, 0.15, 0)  # Size of the zone
        zone_pose = self.get_random_pose(env, zone_size)  # Get a random pose for the zone
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')  # Add the zone to the environment

        # Add cylinders with different sizes and colors
        cylinder_template = 'cylinder/cylinder-template.urdf'
        cylinder_poses = []  # Store initial poses of cylinders to use as target poses
        cylinders = []  # Store object IDs of cylinders
        for i, (height, radius) in enumerate(sizes):
            # Get a random pose for the cylinder
            cylinder_pose = self.get_random_pose(env, (2*radius, 2*radius, height))
            cylinder_poses.append(cylinder_pose)

            # Replace placeholders in the URDF template with actual values
            replace = {'DIM': (radius, height), 'COLOR': colors[i]}
            urdf = self.fill_template(cylinder_template, replace)

            # Add the cylinder to the environment and store its ID
            cylinder_id = env.add_object(urdf, cylinder_pose)
            cylinders.append(cylinder_id)

        # Define the target poses for the cylinders in the tower
        base_height = 0.01  # Small offset from the zone surface
        target_poses = [
            (zone_pose[0], zone_pose[1]),  # Base cylinder pose
            (zone_pose[0], (zone_pose[1][0], zone_pose[1][1], zone_pose[1][2], zone_pose[1][3])),  # Middle cylinder pose
            (zone_pose[0], (zone_pose[1][0], zone_pose[1][1], zone_pose[1][2], zone_pose[1][3]))  # Top cylinder pose
        ]
        # Adjust the z-coordinate for each cylinder to stack them
        target_poses[1][0][2] += sizes[0][0] + base_height  # Middle cylinder on top of the base
        target_poses[2][0][2] += sizes[0][0] + sizes[1][0] + base_height  # Top cylinder on top of the middle

        # Add goals for each cylinder
        for i, cylinder_id in enumerate(cylinders):
            position = ['at the base', 'in the middle', 'at the top'][i]
            language_goal = self.lang_template.format(color=colors[i].lower(), position=position)
            self.add_goal(
                objs=[cylinder_id],
                matches=np.ones((1, 1)),  # Each cylinder has a unique target pose
                targ_poses=[target_poses[i]],
                replace=False,  # Each cylinder has a unique place
                rotations=False,  # Rotation is not considered in this task
                metric='pose',  # We use pose metric for this task
                params=None,  # No additional parameters needed
                step_max_reward=1,  # Full reward for placing each cylinder correctly
                language_goal=language_goal
            )