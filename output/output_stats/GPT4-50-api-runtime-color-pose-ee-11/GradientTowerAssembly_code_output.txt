import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class GradientTowerAssembly(Task):
    """Assemble a tower by stacking five different colored blocks from the base upwards,
    with each subsequent block having a lighter color shade to create a gradient effect,
    ensuring that the lightest block is at the top."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We will have 5 goals, so set max_steps to twice the number of goals
        self.lang_template = "stack the {color} block on top of the {base_color} block"
        self.task_completed_desc = "done assembling the gradient tower."
        self.ee = Suction  # Use Suction end-effector to move blocks on the Z axis
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors for the blocks in gradient order (darkest to lightest)
        block_colors = ['blue', 'cyan', 'green', 'yellow', 'orange']
        block_color_names = ['blue', 'light blue', 'green', 'yellow', 'orange']

        # Add base.
        base_size = (0.15, 0.15, 0.005)  # Size of the base
        base_urdf = 'stacking/stand.urdf'
        base_pose = self.get_random_pose(env, base_size)
        env.add_object(base_urdf, base_pose, category='fixed')

        # Add blocks and define their initial random poses.
        block_size = (0.04, 0.04, 0.04)  # Size of each block
        block_urdf = 'stacking/block.urdf'
        blocks = []
        for i in range(5):
            block_pose = self.get_random_pose(env, block_size)
            block_color = utils.COLORS[block_colors[i]]  # Get the RGB values for the block color
            block_id = env.add_object(block_urdf, block_pose, color=block_color)
            blocks.append(block_id)

        # Define target poses for each block, stacked on top of each other.
        # The z-coordinate is incremented by the height of each block to stack them.
        targ_poses = []
        for i in range(5):
            targ_pose = (base_pose[0][0], base_pose[0][1], base_pose[0][2] + (i + 1) * block_size[2])
            targ_poses.append((targ_pose, (0, 0, 0, 1)))  # No rotation needed, keep the orientation same as base

        # Add goals for each block to be stacked in order.
        for i in range(5):
            # Language goal describes the current step of stacking the block.
            if i == 0:
                base_color = "the base"
            else:
                base_color = block_color_names[i - 1] + " block"
            language_goal = self.lang_template.format(color=block_color_names[i], base_color=base_color)
            
            # Add the goal with the corresponding target pose.
            # step_max_reward is 1 since we have only one goal at each step.
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[targ_poses[i]],
                          replace=False, rotations=False, metric='pose', params=None,
                          step_max_reward=1, language_goal=language_goal)