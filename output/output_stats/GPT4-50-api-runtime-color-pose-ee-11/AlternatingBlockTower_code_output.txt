import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class AlternatingBlockTower(Task):
    """Create a tower by alternately stacking a red block and a green cylinder."""

    def __init__(self):
        super().__init__()
        self.max_steps = 8  # We have 4 blocks and 4 cylinders, so 8 steps should be enough
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.lang_template = "stack a {color} {shape}"
        self.task_completed_desc = "done building the alternating block tower."

    def reset(self, env):
        super().reset(env)

        # Define the size of the blocks and cylinders
        block_size = (0.04, 0.04, 0.04)  # x, y, z dimensions for the block
        cylinder_size = (0.04, 0.04, 0.08)  # x, y, z dimensions for the cylinder

        # Define the URDFs for the block and cylinder
        block_urdf = 'stacking/block.urdf'
        cylinder_template = 'cylinder/cylinder-template.urdf'

        # Define colors for the blocks and cylinders
        block_color = utils.COLORS['red']
        cylinder_color = utils.COLORS['green']

        # Initialize lists to store object IDs and target poses
        blocks = []
        cylinders = []
        target_poses = []

        # Add blocks and cylinders to the environment
        for i in range(4):
            # Add a block
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=block_color)
            blocks.append(block_id)

            # Add a cylinder
            replace = {'DIM': cylinder_size, 'HALF': (cylinder_size[0] / 2, cylinder_size[1] / 2, cylinder_size[2] / 2)}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose, color=cylinder_color)
            cylinders.append(cylinder_id)

            # Define the target pose for the block and cylinder
            # The target pose is directly above the previous object in the tower
            z_offset = 0.04 if i == 0 else 0.08  # The first block is placed on the table, others on a cylinder
            target_pose = (block_pose[0], block_pose[1], block_pose[2] + i * z_offset)
            target_poses.append((target_pose, (0, 0, 0, 1)))  # No rotation needed, keep the original orientation

        # Add goals for stacking the blocks and cylinders
        for i in range(4):
            # Add goal for block
            language_goal = self.lang_template.format(color="red", shape="block")
            self.add_goal(objs=[blocks[i]], matches=np.ones((1, 1)), targ_poses=[target_poses[i]], replace=True,
                          rotations=False, metric='pose', params=None, step_max_reward=1/8, language_goal=language_goal)

            # Add goal for cylinder
            language_goal = self.lang_template.format(color="green", shape="cylinder")
            self.add_goal(objs=[cylinders[i]], matches=np.ones((1, 1)), targ_poses=[target_poses[i]], replace=True,
                          rotations=False, metric='pose', params=None, step_max_reward=1/8, language_goal=language_goal)