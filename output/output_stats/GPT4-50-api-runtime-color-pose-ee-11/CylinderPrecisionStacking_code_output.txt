import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderPrecisionStacking(Task):
    """Sequentially place three colored cylinders of decreasing diameters on top of each other."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice the number of goals
        self.ee = Suction  # Use Suction end-effector to lift cylinders on the Z axis

        # Define the language templates for each cylinder placement
        self.lang_template = "place the {color} cylinder on the {target}"
        self.task_completed_desc = "done stacking the cylinders."

    def reset(self, env):
        super().reset(env)

        # Define the sizes for the cylinders (diameter, height)
        sizes = [(0.08, 0.04), (0.06, 0.04), (0.04, 0.04)]

        # Define the colors for the cylinders
        colors = ['red', 'green', 'blue']

        # Add pallet as the base for stacking
        pallet_size = (0.3, 0.3, 0.02)  # Size of the pallet
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object('pallet/pallet.urdf', pallet_pose, 'fixed')

        # Initialize list to store cylinder IDs and target poses
        cylinder_ids = []
        target_poses = []

        # Add cylinders with decreasing sizes
        for i, size in enumerate(sizes):
            # Generate a random pose for the cylinder
            pose = self.get_random_pose(env, size)

            # Define the cylinder color
            color = utils.COLORS[colors[i]]

            # Create the cylinder URDF using the template
            cylinder_template = 'cylinder/cylinder-template.urdf'
            replace = {'SIZE': size, 'COLOR': color}
            cylinder_urdf = self.fill_template(cylinder_template, replace)

            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, pose)
            cylinder_ids.append(cylinder_id)

            # Define the target pose for the cylinder
            # The x, y coordinates are the same as the pallet, and z is incremented with each cylinder
            target_pose = (pallet_pose[0], pallet_pose[1] + (0, 0, i * size[1]))
            target_poses.append(target_pose)

        # Add goals for each cylinder
        for i, cylinder_id in enumerate(cylinder_ids):
            # Define the language goal for placing the cylinder
            color = colors[i]
            target = "top" if i == 0 else colors[i-1] + " cylinder"
            language_goal = self.lang_template.format(color=color, target=target)

            # Add the goal for the current cylinder
            self.add_goal(
                objs=[cylinder_id],
                matches=np.ones((1, 1)),  # Each cylinder has a single match
                targ_poses=[target_poses[i]],  # Target pose for the current cylinder
                replace=False,  # Cylinders should not be replaced once placed
                rotations=True,  # Allow rotations for precision placement
                metric='pose',  # Use pose matching for evaluation
                params=None,  # No additional parameters needed
                step_max_reward=1 / len(sizes),  # Reward is split across all cylinders
                language_goal=language_goal  # Language goal for the current step
            )