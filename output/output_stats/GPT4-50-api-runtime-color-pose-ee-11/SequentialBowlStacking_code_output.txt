import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class SequentialBowlStacking(Task):
    """Stack a series of three bowls of decreasing sizes into one another without tipping any over."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is set to twice that number
        self.lang_template = "stack the {size} bowl on the {target_size} one"
        self.task_completed_desc = "done stacking all bowls."
        self.ee = Suction  # Use Suction end-effector to lift bowls on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define the sizes for the three bowls (large, medium, small)
        bowl_sizes = [(0.12, 0.12, 0.06), (0.1, 0.1, 0.05), (0.08, 0.08, 0.04)]
        bowl_colors = ['blue', 'green', 'red']  # Assign colors to each bowl
        bowl_urdf = 'bowl/bowl.urdf'

        # Add stand for the bowls to be stacked upon
        stand_size = (0.15, 0.15, 0.02)
        stand_urdf = 'stacking/stand.urdf'
        stand_pose = self.get_random_pose(env, stand_size)
        env.add_object(stand_urdf, stand_pose, 'fixed')

        # Initialize list to store bowl object IDs and poses
        bowls = []
        bowl_poses = []

        # Add bowls to the environment
        for i, size in enumerate(bowl_sizes):
            color = utils.COLORS[bowl_colors[i]]  # Get the RGB values for the bowl color
            pose = self.get_random_pose(env, size)  # Get a random pose for the bowl
            bowl_id = env.add_object(bowl_urdf, pose, 'rigid', color=color)  # Add bowl to the environment
            bowls.append(bowl_id)
            bowl_poses.append(pose)

        # Define the language goals for stacking the bowls
        size_names = ['large', 'medium', 'small']
        for i in range(1, len(bowls)):
            language_goal = self.lang_template.format(size=size_names[i], target_size=size_names[i-1])
            # Add goal for each bowl to be stacked on top of the previous one
            self.add_goal(
                objs=[bowls[i]],  # Current bowl to move
                matches=np.ones((1, 1)),  # One-to-one correspondence
                targ_poses=[bowl_poses[i-1]],  # Target pose is the pose of the previous (larger) bowl
                replace=False,  # Bowls must be stacked in order
                rotations=True,  # Allow rotations for proper alignment
                metric='pose',  # Use pose metric for evaluation
                params=None,  # No additional parameters needed
                step_max_reward=1 / len(bowls),  # Reward is split across the goals
                language_goal=language_goal  # Language instruction for the goal
            )

        # The final goal is to have all bowls stacked with the smallest on top
        self.add_goal(
            objs=bowls,  # All bowls
            matches=np.eye(len(bowls)),  # Each bowl matches with its corresponding target pose
            targ_poses=bowl_poses,  # Target poses are the initial poses of the bowls
            replace=False,  # Bowls must be stacked in order
            rotations=True,  # Allow rotations for proper alignment
            metric='pose',  # Use pose metric for evaluation
            params=None,  # No additional parameters needed
            step_max_reward=1,  # Full reward for completing the final goal
            language_goal=self.task_completed_desc  # Language instruction for the final goal
        )