import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylindricalTowerBalance(Task):
    """Create a balanced tower by stacking five cylinders of the same diameter but different colors in a specific order."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We have 5 cylinders to stack, so 10 steps should be sufficient
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.lang_template = "stack the {color} cylinder"
        self.task_completed_desc = "done stacking the cylindrical tower."

    def reset(self, env):
        super().reset(env)

        # Define the size of the zone where the cylinders will be stacked
        zone_size = (0.1, 0.1, 0)  # Small circular zone
        zone_pose = self.get_random_pose(env, zone_size)  # Get a random pose for the zone within the workspace bounds
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')  # Add the zone to the environment

        # Define the size and template for the cylinders
        cylinder_size = (0.05, 0.05, 0.1)  # Diameter and height for the cylinder
        cylinder_template = 'cylinder/cylinder-template.urdf'

        # Define the colors for the cylinders
        colors = ['red', 'green', 'blue', 'yellow', 'purple']
        np.random.shuffle(colors)  # Shuffle the colors to randomize the order for stacking

        # Add cylinders to the environment
        cylinders = []
        for i, color in enumerate(colors):
            # Get a random pose for the cylinder within the workspace bounds
            cylinder_pose = self.get_random_pose(env, cylinder_size)
            # Fill the URDF template with the specific color and size for the cylinder
            replace = {'COLOR': utils.COLORS[color], 'SIZE': cylinder_size}
            cylinder_urdf = self.fill_template(cylinder_template, replace)
            # Add the cylinder to the environment and store its ID
            cylinder_id = env.add_object(cylinder_urdf, cylinder_pose)
            cylinders.append(cylinder_id)

            # Define the language goal for stacking this cylinder
            language_goal = self.lang_template.format(color=color)

            # The target pose for the cylinder is on top of the previous cylinder or the zone
            if i == 0:
                # The first cylinder goes on the zone
                targ_pose = zone_pose
            else:
                # Subsequent cylinders go on top of the previous one
                # We use the pose of the previous cylinder and increase the z-coordinate
                x, y, z = cylinders[i-1].pose[0]
                targ_pose = [(x, y, z + cylinder_size[2]), (0, 0, 0, 1)]  # No rotation needed, keep it upright

            # Add the goal for stacking this cylinder
            self.add_goal(objs=[cylinder_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/5,
                          language_goal=language_goal)

        # The task is to stack the cylinders in the specific order defined by the shuffled colors
        # The tower must remain stable for at least 3 seconds, which is checked by the environment