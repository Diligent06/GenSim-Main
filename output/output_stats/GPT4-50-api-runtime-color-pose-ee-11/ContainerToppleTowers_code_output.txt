import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Spatula

class ContainerToppleTowers(Task):
    """
    Carefully extract and relocate three colored blocks stacked into a tower on top of a container
    without toppling the stack, and place them inside an adjacent zone marked on the tabletop.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We have 3 blocks to move, so 6 steps should be sufficient
        self.lang_template = "move the {color} block to the marked zone without toppling the tower"
        self.task_completed_desc = "done relocating the blocks."
        self.primitive = primitives.push  # We use the push primitive to move blocks
        self.ee = Spatula  # Spatula is suitable for moving blocks in a 2D plane
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors of the blocks
        block_colors = ['red', 'green', 'blue']
        block_color_values = [utils.COLORS[color] for color in block_colors]

        # Define the size of the blocks
        block_size = (0.04, 0.04, 0.04)  # Size of each block

        # Add container box on which the tower will be stacked
        container_size = (0.15, 0.15, 0.15)  # Size of the container
        container_pose = self.get_random_pose(env, container_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': tuple(s / 2 for s in container_size)}
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, container_pose, 'fixed')

        # Add blocks on top of the container to form a tower
        blocks = []
        for i in range(3):
            # Stack blocks on top of each other by incrementing the z-coordinate
            block_pose = (container_pose[0][0], container_pose[0][1], container_pose[0][2] + (i + 1) * block_size[2])
            block_urdf = 'stacking/block.urdf'
            block_id = env.add_object(block_urdf, block_pose, color=block_color_values[i])
            blocks.append(block_id)

        # Add goal zone where blocks need to be placed
        zone_size = (0.1, 0.1, 0)  # Size of the goal zone
        zone_pose = self.get_random_pose(env, zone_size)
        env.add_object('zone/zone.urdf', zone_pose, 'fixed')

        # Add goals for each block
        for i, block_id in enumerate(blocks):
            # Define the language goal for moving each block
            language_goal = self.lang_template.format(color=block_colors[i])
            # Add the goal for the current block
            self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[zone_pose], replace=False,
                          rotations=False, metric='zone', params=[(zone_pose, zone_size)], step_max_reward=1 / 3,
                          language_goal=language_goal)

        # The task is to move each block to the zone without toppling the tower
        # Each block has a separate goal with a maximum reward of 1/3 (since there are 3 blocks)