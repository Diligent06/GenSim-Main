import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BowlBalancingBlocks(Task):
    """Balance blocks on the rim of a bowl without letting them fall inside or outside the bowl."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we will call self.add_goal 5 times
        self.lang_template = "balance the {color} block on the rim of the bowl"
        self.task_completed_desc = "done balancing blocks on the bowl."
        self.ee = Suction  # Using Suction since we need to move blocks in the Z axis
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the bowl properties
        bowl_size = (0.18, 0.18, 0.06)  # Size of the bowl (x, y, z)
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_pose = self.get_random_pose(env, bowl_size)
        bowl_color = utils.COLORS['green']  # Color of the bowl

        # Add the bowl to the environment
        env.add_object(bowl_urdf, bowl_pose, 'fixed', color=bowl_color)

        # Define properties for the blocks
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks (x, y, z)
        block_urdf = 'stacking/block.urdf'
        n_blocks = 5  # Number of blocks to balance
        block_colors = ['red', 'blue', 'yellow', 'purple', 'orange']  # Colors of the blocks

        # Add blocks to the environment
        blocks = []
        for i in range(n_blocks):
            block_pose = self.get_random_pose(env, block_size)
            block_color = utils.COLORS[block_colors[i]]
            block_id = env.add_object(block_urdf, block_pose, color=block_color)
            blocks.append(block_id)

            # Define the target pose for each block on the rim of the bowl
            # Assuming the rim of the bowl is at z = bowl_size[2] / 2
            # and the blocks are to be placed at equal intervals around the rim
            angle = 2 * np.pi * i / n_blocks  # Angle for each block to be placed
            rim_radius = bowl_size[0] / 2 - block_size[0] / 2  # Radius where blocks will be placed
            x_offset = rim_radius * np.cos(angle)
            y_offset = rim_radius * np.sin(angle)
            target_pose = (bowl_pose[0][0] + x_offset, bowl_pose[0][1] + y_offset, bowl_size[2] / 2)

            # Add goal for each block
            language_goal = self.lang_template.format(color=block_colors[i])
            self.add_goal(objs=[block_id], matches=np.ones((1, 1)), targ_poses=[(target_pose, (0, 0, 0, 1))],
                          replace=False, rotations=False, metric='pose', params=None, step_max_reward=1/n_blocks,
                          language_goal=language_goal)

        # The task is to balance each block on the rim of the bowl without letting them fall