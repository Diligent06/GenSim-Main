import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class CylinderTowerBalancing(Task):
    """
    Create a balanced tower by stacking three cylinders of different colors
    on top of each other on a single pallet, ensuring the tower doesn't topple over.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice that number
        self.ee = Suction  # Using Suction end-effector to pick and place cylinders
        self.lang_template = "stack the {color} cylinder on top of the {base_color} one"
        self.task_completed_desc = "done stacking the cylinder tower."

    def reset(self, env):
        super().reset(env)

        # Define the size of the pallet and cylinders
        pallet_size = (0.3, 0.3, 0.02)  # x, y, z dimensions
        cylinder_height = 0.1
        cylinder_radius = 0.05
        cylinder_size = (cylinder_radius * 2, cylinder_radius * 2, cylinder_height)

        # Add pallet to the environment
        pallet_urdf = 'pallet/pallet.urdf'
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object(pallet_urdf, pallet_pose, 'fixed')

        # Define colors for the cylinders
        colors = ['red', 'green', 'blue']
        cylinder_urdfs = []

        # Add cylinders to the environment
        for color in colors:
            # Generate a random pose for the cylinder
            pose = self.get_random_pose(env, cylinder_size)
            # Generate the color for the cylinder
            rgb = utils.COLORS[color]
            # Create the cylinder URDF using the template
            replace = {'COLOR': rgb, 'SIZE': cylinder_size}
            cylinder_urdf = self.fill_template('cylinder/cylinder-template.urdf', replace)
            cylinder_urdfs.append(cylinder_urdf)
            # Add the cylinder to the environment
            env.add_object(cylinder_urdf, pose)

        # Define the target poses for the cylinders on the pallet
        # The target z-coordinate is incremented by the cylinder height for each subsequent cylinder
        base_z = pallet_pose[0][2] + pallet_size[2] + cylinder_height / 2
        targ_poses = [
            (pallet_pose[0], pallet_pose[1]),  # Base cylinder directly on the pallet
            ((pallet_pose[0][0], pallet_pose[0][1], base_z + cylinder_height), pallet_pose[1]),  # Middle cylinder
            ((pallet_pose[0][0], pallet_pose[0][1], base_z + 2 * cylinder_height), pallet_pose[1])  # Top cylinder
        ]

        # Add goals for stacking the cylinders
        for i in range(len(colors)):
            # The language goal describes the action to stack the current cylinder on top of the previous one
            base_color = 'the pallet' if i == 0 else colors[i - 1]
            language_goal = self.lang_template.format(color=colors[i], base_color=base_color)
            # Add the goal with the corresponding target pose
            self.add_goal(objs=[cylinder_urdfs[i]], matches=np.ones((1, 1)), targ_poses=[targ_poses[i]],
                          replace=False, rotations=True, metric='pose', params=None,
                          step_max_reward=1 / len(colors), language_goal=language_goal)

# Instantiate the task
task = CylinderTowerBalancing()