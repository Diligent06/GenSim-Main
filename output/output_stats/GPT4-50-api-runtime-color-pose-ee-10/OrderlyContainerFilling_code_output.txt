import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class OrderlyContainerFilling(Task):
    """Arrange a series of colored balls and blocks in an alternating color pattern within a container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we will have 5 calls to self.add_goal
        self.lang_template = "place the {color} {object} in the container"
        self.task_completed_desc = "done filling the container orderly."
        self.ee = Suction  # Use Suction end-effector for picking and placing in Z axis

    def reset(self, env):
        super().reset(env)

        # Define the colors for the balls and blocks
        ball_colors = ['red', 'green', 'blue', 'yellow', 'purple']
        block_colors = ['orange', 'indigo', 'violet', 'gray', 'silver']

        # Add container box
        container_size = (0.3, 0.2, 0.1)  # x, y, z dimensions
        container_pose = self.get_random_pose(env, container_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, container_pose, 'fixed')

        # Add balls and blocks
        objects = []
        for i in range(5):
            # Add ball
            ball_size = (0.04, 0.04, 0.04)  # x, y, z dimensions
            ball_pose = self.get_random_pose(env, ball_size)
            ball_template = 'ball/ball-template.urdf'
            ball_color = utils.COLORS[ball_colors[i]]
            replace = {'COLOR': ball_color}
            ball_urdf = self.fill_template(ball_template, replace)
            ball_id = env.add_object(ball_urdf, ball_pose)
            objects.append((ball_id, 'ball', ball_colors[i]))

            # Add block
            block_size = (0.04, 0.04, 0.04)  # x, y, z dimensions
            block_pose = self.get_random_pose(env, block_size)
            block_urdf = 'stacking/block.urdf'
            block_color = utils.COLORS[block_colors[i]]
            block_id = env.add_object(block_urdf, block_pose, color=block_color)
            objects.append((block_id, 'block', block_colors[i]))

        # Define the order of placement in the container, starting with balls
        for i, (obj_id, obj_type, color) in enumerate(objects):
            # Alternate between balls and blocks
            obj_name = 'ball' if obj_type == 'ball' else 'block'
            language_goal = self.lang_template.format(color=color, object=obj_name)

            # Calculate the target pose within the container
            # Assuming a simple stacking along the z-axis
            target_pose = (container_pose[0], container_pose[1])  # Use container pose as reference
            target_pose[0][2] += (i // 2) * 0.04  # Increment z for each ball/block pair

            # Add goal for each object
            self.add_goal(objs=[obj_id], matches=np.int32([[1]]), targ_poses=[target_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1/len(objects),
                          language_goal=language_goal)

        # Set the primitive for the task
        self.primitive = primitives.pick_place