import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class SequentialBowlStacking(Task):
    """Stack three differently colored bowls inside each other without toppling over, from largest at the bottom to smallest on top."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is set to twice the number of goals
        self.lang_template = "stack the {color} bowl {position} inside the {other_color} bowl"
        self.task_completed_desc = "done stacking the bowls."
        self.ee = Suction  # Use Suction end-effector to lift bowls on the Z axis

    def reset(self, env):
        super().reset(env)

        # Define bowl sizes (diameter, height)
        bowl_sizes = [
            (0.18, 0.08),  # Large bowl
            (0.15, 0.06),  # Medium bowl
            (0.12, 0.04)   # Small bowl
        ]

        # Define bowl colors
        bowl_colors = ['red', 'green', 'blue']

        # Add bowls to the environment with random poses
        bowl_urdf = 'bowl/bowl.urdf'
        bowls = []
        for size, color in zip(bowl_sizes, bowl_colors):
            # Generate a random pose for the bowl
            bowl_pose = self.get_random_pose(env, size)
            # Add the bowl to the environment
            bowl_id = env.add_object(bowl_urdf, bowl_pose, color=utils.COLORS[color])
            bowls.append((bowl_id, bowl_pose))

        # Define the target poses for the bowls, which is the initial pose of the largest bowl
        target_pose = bowls[0][1]  # The target pose is the pose of the largest bowl

        # Add goals for each bowl to be stacked
        for i, (bowl_id, _) in enumerate(bowls):
            if i == 0:
                continue  # Skip the largest bowl as it's the base and doesn't need to be moved
            # Define the language goal for the current bowl
            language_goal = self.lang_template.format(
                color=bowl_colors[i],
                position="on top of" if i > 0 else "inside",
                other_color=bowl_colors[i-1]
            )
            # Add the goal for the current bowl
            self.add_goal(
                objs=[bowl_id],  # The current bowl to move
                matches=np.ones((1, 1)),  # The current bowl matches with one target pose
                targ_poses=[target_pose],  # The target pose is the pose of the largest bowl
                replace=False,  # Each bowl has a unique target pose
                rotations=False,  # Rotation is not considered in this task
                metric='pose',  # We use pose metric to check if the bowl is correctly placed
                params=None,  # No additional parameters needed
                step_max_reward=1,  # Full reward for completing this step
                language_goal=language_goal  # The language goal for this step
            )

# Instantiate the task
task = SequentialBowlStacking()