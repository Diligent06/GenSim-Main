import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ContainerBlockSequence(Task):
    """
    Arrange a sequence of differently colored blocks within a container,
    placing them in a specific order from left to right following a given color pattern.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Set to twice the number of expected goals
        self.ee = Suction  # Use Suction end-effector to pick and place blocks

        # Define the language template and task completion description
        self.lang_template = "place the {color} block in the container in the {position} position"
        self.task_completed_desc = "done arranging the blocks in sequence."
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the color sequence for the blocks
        color_sequence = ['red', 'green', 'blue', 'yellow', 'purple']
        n_blocks = len(color_sequence)  # Number of blocks to place

        # Add container
        container_size = self.get_random_size(0.3, 0.35, 0.15, 0.2, 0.05, 0.1)
        container_pose = self.get_random_pose(env, container_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': tuple(s / 2 for s in container_size)}
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, container_pose, 'fixed')

        # Add blocks and define their target poses within the container
        block_urdf = 'stacking/block.urdf'
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks
        block_ids = []
        targ_poses = []

        # Calculate the starting x-coordinate for the first block
        start_x = container_pose[0][0] - container_size[0] / 2 + block_size[0] / 2
        spacing = container_size[0] / n_blocks  # Spacing between blocks

        for i, color_name in enumerate(color_sequence):
            # Generate the color for the block
            color = utils.COLORS[color_name]

            # Generate a random pose for the block
            block_pose = self.get_random_pose(env, block_size)

            # Add the block to the environment
            block_id = env.add_object(block_urdf, block_pose, color=color)
            block_ids.append(block_id)

            # Define the target pose for the block within the container
            targ_x = start_x + i * spacing
            targ_pose = [(targ_x, container_pose[0][1], container_pose[0][2]), container_pose[1]]
            targ_poses.append(targ_pose)

            # Define the language goal for placing this block
            position = ['leftmost', 'left', 'center', 'right', 'rightmost'][i]
            language_goal = self.lang_template.format(color=color_name, position=position)

            # Add the goal for this block
            self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[targ_pose], replace=False,
                          rotations=True, metric='pose', params=None, step_max_reward=1 / n_blocks,
                          language_goal=language_goal)

        # Ensure the blocks are placed in the correct sequence
        for i in range(n_blocks):
            self.goals[i]['matches'] = np.zeros((n_blocks, n_blocks))
            self.goals[i]['matches'][i][i] = 1