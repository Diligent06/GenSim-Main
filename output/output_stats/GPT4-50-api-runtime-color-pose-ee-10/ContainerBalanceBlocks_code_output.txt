import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class ContainerBalanceBlocks(Task):
    """Balance blocks on the edges of an open container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 4  # Assuming we want to balance 2 blocks, so max_steps is twice the number of blocks
        self.lang_template = "balance the {color} block on the edge of the container"
        self.task_completed_desc = "done balancing blocks."
        self.ee = Suction  # Suction is needed to lift blocks in the Z axis

    def reset(self, env):
        super().reset(env)

        # Container parameters
        container_size = (0.15, 0.15, 0.05)  # Size of the container (x, y, z)
        container_pose = self.get_random_pose(env, container_size)  # Random pose for the container
        container_urdf = 'container/container-template.urdf'
        container_replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_urdf, container_replace)
        env.add_object(container_urdf, container_pose, 'fixed')

        # Block parameters
        n_blocks = 2  # Number of blocks to balance
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks (x, y, z)
        block_urdf = 'stacking/block.urdf'
        block_colors = ['red', 'blue']  # Colors for the blocks
        blocks = []

        # Add blocks and define goals
        for i in range(n_blocks):
            # Get a random pose for the block
            block_pose = self.get_random_pose(env, block_size)
            # Add the block to the environment
            block_color = utils.COLORS[block_colors[i]]
            block_id = env.add_object(block_urdf, block_pose, color=block_color)
            blocks.append(block_id)

            # Define the target pose for the block to be balanced on the container edge
            # For simplicity, we'll balance them on the middle of the edges along the x-axis of the container
            edge_x = container_pose[0][0] + (-1)**i * (container_size[0] / 2 - block_size[0] / 2)
            edge_y = container_pose[0][1]
            edge_z = container_pose[0][2] + container_size[2] / 2 + block_size[2] / 2  # Just above the container edge
            target_pose = [(edge_x, edge_y, edge_z), (0, 0, 0, 1)]  # No rotation needed, hence the unit quaternion

            # Add the goal for the block
            language_goal = self.lang_template.format(color=block_colors[i])
            self.add_goal(objs=[block_id], matches=np.ones((1, 1)), targ_poses=[target_pose], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1 / n_blocks,
                          language_goal=language_goal)

        # Set the primitive to be used for this task
        self.primitive = primitives.push  # We use push primitive to slide blocks to the edge