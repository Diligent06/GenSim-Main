import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BowlBallTower(Task):
    """Stack three differently colored balls into a vertical tower inside a bowl without the tower toppling over."""

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is twice that number
        self.lang_template = "put the {color} ball in the bowl"
        self.task_completed_desc = "done stacking the ball tower."
        self.ee = Suction  # We need to move balls on the Z axis, so we use the Suction end-effector
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the size and pose of the bowl
        bowl_size = (0.18, 0.18, 0.06)  # x, y, z dimensions for the bowl
        bowl_pose = self.get_random_pose(env, bowl_size)
        bowl_urdf = 'bowl/bowl.urdf'
        env.add_object(bowl_urdf, bowl_pose, 'fixed')  # The bowl is a fixed object in the environment

        # Define the colors and sizes for the balls
        ball_colors = ['red', 'green', 'blue']  # The colors of the balls
        ball_size = (0.04, 0.04, 0.04)  # All balls have the same size

        # Add balls to the environment
        ball_template = 'ball/ball-template.urdf'
        ball_ids = []
        for color in ball_colors:
            ball_color = utils.COLORS[color]  # Get the RGB values for the color
            ball_pose = self.get_random_pose(env, ball_size)
            replace = {'COLOR': ball_color}
            ball_urdf = self.fill_template(ball_template, replace)
            ball_id = env.add_object(ball_urdf, ball_pose)
            ball_ids.append(ball_id)

        # Define the target poses for the balls inside the bowl
        # The balls should be stacked on top of each other, so we increment the z-coordinate
        z_offset = 0.04  # The z-offset to stack the balls
        targ_poses = []
        for i in range(3):
            # The x, y coordinates are the same as the bowl's, and z is incremented
            targ_pose = (bowl_pose[0], (0, 0, bowl_pose[0][2] + z_offset * (i + 1)))
            targ_poses.append(targ_pose)

        # Add goals for each ball
        for i, ball_id in enumerate(ball_ids):
            language_goal = self.lang_template.format(color=ball_colors[i])
            # Each ball has a separate goal with a step_max_reward of 1/3 since there are three balls
            self.add_goal(objs=[ball_id], matches=np.ones((1, 1)), targ_poses=[targ_poses[i]], replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/3, language_goal=language_goal)

# Note: The code assumes that the 'fill_template' method correctly replaces the 'COLOR' placeholder in the ball URDF template.
# The 'get_random_pose' method is used to ensure that the initial poses of the balls and the bowl are collision-free.
# The 'add_goal' method is called for each ball with the corresponding target pose inside the bowl.