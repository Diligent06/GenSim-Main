import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class GradientTower(Task):
    """Construct a color-gradient tower by stacking colored cylinders in ascending size order."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to stack 5 cylinders, so 10 steps should be sufficient
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.lang_template = "stack the {color} cylinder on the tower"
        self.task_completed_desc = "done constructing the gradient tower."

    def reset(self, env):
        super().reset(env)

        # Define the colors for the gradient, from darkest to lightest
        gradient_colors = ['black', 'gray', 'silver', 'white', 'gold']

        # Define the sizes for the cylinders, from largest to smallest
        cylinder_sizes = [(0.08, 0.08, 0.04 * i) for i in range(5, 0, -1)]

        # Add pallet
        pallet_size = (0.3, 0.3, 0.02)  # Fixed size for the pallet
        pallet_pose = self.get_random_pose(env, pallet_size)
        env.add_object('pallet/pallet.urdf', pallet_pose, 'fixed')

        # Add cylinders
        cylinders = []
        for i in range(5):
            # Generate a random pose for the cylinder on the pallet
            pose = self.get_random_pose(env, cylinder_sizes[i])

            # Fill in the cylinder template with the specific size and color
            replace = {
                'SIZE': cylinder_sizes[i],
                'COLOR': utils.COLORS[gradient_colors[i]],
            }
            cylinder_urdf = self.fill_template('cylinder/cylinder-template.urdf', replace)

            # Add the cylinder to the environment
            cylinder_id = env.add_object(cylinder_urdf, pose)
            cylinders.append((cylinder_id, pose))

        # Define the target poses for the cylinders, stacked on top of each other
        # Starting from the base pose of the pallet
        base_x, base_y, _ = pallet_pose[0]
        target_poses = [(base_x, base_y, 0.02 + sum(cylinder_sizes[i][2] for i in range(idx))) for idx in range(5)]

        # Add goals for each cylinder to be stacked in ascending order
        for i, (cylinder_id, _) in enumerate(cylinders):
            # The target pose for the current cylinder
            target_pose = (target_poses[i], (0, 0, 0, 1))  # No rotation needed, quaternions set to identity

            # Language goal for the current step
            language_goal = self.lang_template.format(color=gradient_colors[i])

            # Add the goal for the current cylinder
            self.add_goal(
                objs=[cylinder_id],
                matches=np.ones((1, 1)),  # Each cylinder has a unique place
                targ_poses=[target_pose],
                replace=False,  # Each target is unique
                rotations=False,  # No rotation needed for this task
                metric='pose',  # We are using pose metric for evaluation
                params=None,  # No additional parameters needed
                step_max_reward=1 / 5,  # Equal reward for each cylinder, adding up to 1
                language_goal=language_goal
            )