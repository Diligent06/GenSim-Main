import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class StackAndAlignBlocks(Task):
    """
    Stack three different colored blocks on top of each other and align them with a single green line on the tabletop.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We will have 3 goals, so max_steps is set to twice that number
        self.lang_template = "stack the {color} block on top of the {base_color} block and align with the green line"
        self.task_completed_desc = "done stacking and aligning blocks."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors for the blocks
        block_colors = ['red', 'blue', 'yellow']
        block_color_names = ['red', 'blue', 'yellow']
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks (x, y, z)

        # Add blocks to the environment
        blocks = []
        block_urdf = 'stacking/block.urdf'
        for color_name in block_color_names:
            color = utils.COLORS[color_name]
            block_pose = self.get_random_pose(env, block_size)
            block_id = env.add_object(block_urdf, block_pose, color=color)
            blocks.append((block_id, block_pose))

        # Add the green line to the environment
        line_size = (0.3, 0.005, 0.005)  # Size of the line (x, y, z)
        line_template = 'line/single-green-line-template.urdf'
        line_pose = self.get_random_pose(env, line_size)
        replace = {'SIZE': line_size}
        line_urdf = self.fill_template(line_template, replace)
        env.add_object(line_urdf, line_pose, 'fixed')

        # Define the target poses for the blocks to be stacked
        # The target poses are directly above each other, aligned with the green line
        base_block_pose = blocks[0][1]  # Use the pose of the first block as the base
        targ_poses = [
            base_block_pose,  # Base block remains in the same place
            (base_block_pose[0], (0, 0, 0, 1)),  # Second block directly on top of the first
            (utils.apply(base_block_pose, (0, 0, block_size[2])), (0, 0, 0, 1))  # Third block on top of the second
        ]

        # Add goals for stacking the blocks
        for i in range(1, len(blocks)):
            color_name = block_color_names[i]
            base_color_name = block_color_names[i-1]
            language_goal = self.lang_template.format(color=color_name, base_color=base_color_name)
            self.add_goal(
                objs=[blocks[i][0]],  # Current block to stack
                matches=np.ones((1, 1)),  # Single match since we're stacking one block at a time
                targ_poses=[targ_poses[i]],  # Target pose for the current block
                replace=False,  # Blocks should not be replaced once stacked
                rotations=False,  # No need for rotation since blocks are axis-aligned
                metric='pose',  # We're using pose metric for stacking
                params=None,  # No additional parameters needed
                step_max_reward=1 / 3,  # Reward is split across the three stacking actions
                language_goal=language_goal
            )

        # The blocks should also be aligned with the green line, which is part of the task description
        # This is implicitly handled by the target poses being aligned with the base block's pose