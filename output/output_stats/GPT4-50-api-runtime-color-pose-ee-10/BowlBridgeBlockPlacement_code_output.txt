import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class BowlBridgeBlockPlacement(Task):
    """Construct a bridge using two bowls turned upside down and place a sequence of colored blocks across the gap, creating a stable color-sorted bridge."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # We expect to place 5 blocks, so 10 steps should be sufficient
        self.lang_template = "place the {color} block on the bridge"
        self.task_completed_desc = "done constructing the bridge."
        self.ee = Suction  # We need to move objects on the Z axis, so Suction is appropriate

    def reset(self, env):
        super().reset(env)

        # Define the size of the bowls and blocks
        bowl_size = (0.18, 0.18, 0.06)  # x, y, z dimensions for the bowl
        block_size = (0.05, 0.05, 0.05)  # x, y, z dimensions for the blocks

        # Add two bowls to serve as the base of the bridge
        bowl_urdf = 'bowl/bowl.urdf'
        bowl_poses = []
        for _ in range(2):
            # Get a random pose for the bowl ensuring it doesn't collide with other objects
            bowl_pose = self.get_random_pose(env, bowl_size)
            # Add the bowl object to the environment in an upside-down orientation to form the bridge base
            env.add_object(bowl_urdf, bowl_pose, 'fixed')
            bowl_poses.append(bowl_pose)

        # Define the sequence of colors for the blocks
        block_colors = ['red', 'orange', 'yellow', 'green', 'blue']
        block_urdf = 'stacking/block.urdf'
        blocks = []

        # Add blocks to the environment
        for color in block_colors:
            # Get a random pose for the block ensuring it doesn't collide with other objects
            block_pose = self.get_random_pose(env, block_size)
            # Add the block object to the environment with the specified color
            block_id = env.add_object(block_urdf, block_pose, color=utils.COLORS[color])
            blocks.append(block_id)

        # Calculate the positions for the blocks to be placed on the bridge
        # We assume the bridge is formed by the gap between the two bowls
        bridge_poses = []
        for i in range(len(block_colors)):
            # Calculate the x position as the midpoint between the two bowls plus an offset for each block
            x_pos = (bowl_poses[0][0][0] + bowl_poses[1][0][0]) / 2 + (i - len(block_colors) / 2) * block_size[0]
            # The y position is the same as the bowls, and z is slightly above the bowl's rim
            y_pos = bowl_poses[0][0][1]
            z_pos = bowl_poses[0][0][2] + bowl_size[2] / 2 + block_size[2] / 2
            # The orientation is the same as the bowls (assuming they are placed flat)
            bridge_poses.append(((x_pos, y_pos, z_pos), bowl_poses[0][1]))

        # Add goals for each block to be placed on the bridge in the correct order
        for i, block_id in enumerate(blocks):
            language_goal = self.lang_template.format(color=block_colors[i])
            self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[bridge_poses[i]],
                          replace=False, rotations=True, metric='pose', params=None,
                          step_max_reward=1 / len(blocks), language_goal=language_goal)