import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class PrecisionBlockSorting(Task):
    """Sort and place a set of differently colored blocks into corresponding colored zones within a container."""

    def __init__(self):
        super().__init__()
        self.max_steps = 10  # Assuming we have 5 blocks to sort, 2 steps per block (pick & place)
        self.lang_template = "put the {color} block in the {color} zone"
        self.task_completed_desc = "done sorting blocks."
        self.ee = Suction  # Use suction end-effector to pick and place blocks

    def reset(self, env):
        super().reset(env)

        # Define the number of blocks and zones
        n_blocks = 5
        n_zones = n_blocks  # One zone per block

        # Define the size of the blocks and zones
        block_size = (0.04, 0.04, 0.04)  # Size of the blocks
        zone_size = (0.1, 0.1, 0)  # Size of the zones (2D)

        # Add container box
        container_size = self.get_random_size(0.3, 0.5, 0.3, 0.5, 0.05, 0.1)
        container_pose = self.get_random_pose(env, container_size)
        container_template = 'container/container-template.urdf'
        replace = {'DIM': container_size, 'HALF': (container_size[0] / 2, container_size[1] / 2, container_size[2] / 2)}
        container_urdf = self.fill_template(container_template, replace)
        env.add_object(container_urdf, container_pose, 'fixed')

        # Define available colors
        colors = ['red', 'green', 'blue', 'yellow', 'purple']
        color_names = [f"{color} zone" for color in colors]

        # Add zones inside the container
        zone_poses = []
        for i in range(n_zones):
            # Generate a random pose for the zone inside the container
            zone_pose = self.get_random_pose(env, zone_size)
            zone_urdf = self.fill_template('zone/zone.urdf', {'COLOR': utils.COLORS[colors[i]]})
            env.add_object(zone_urdf, zone_pose, 'fixed')
            zone_poses.append(zone_pose)

        # Add blocks
        blocks = []
        for i in range(n_blocks):
            # Generate a random pose for the block
            block_pose = self.get_random_pose(env, block_size)
            block_urdf = 'stacking/block.urdf'
            block_color = utils.COLORS[colors[i]]
            block_id = env.add_object(block_urdf, block_pose, color=block_color)
            blocks.append(block_id)

            # Define the language goal for placing the block in the correct zone
            language_goal = self.lang_template.format(color=colors[i])

            # Add goal for each block to be in the corresponding zone
            self.add_goal(objs=[block_id], matches=np.int32([[1]]), targ_poses=[zone_poses[i]], replace=False,
                          rotations=True, metric='zone', params=[(zone_poses[i], zone_size)], step_max_reward=1 / n_blocks,
                          language_goal=language_goal)