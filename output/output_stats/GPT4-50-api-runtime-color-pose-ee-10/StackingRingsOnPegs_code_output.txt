import numpy as np
import os
import pybullet as p
import random
from cliport.tasks import primitives
from cliport.tasks.grippers import Spatula
from cliport.tasks.task import Task
from cliport.utils import utils
import numpy as np
from cliport.tasks.task import Task
from cliport.utils import utils
from cliport.tasks.grippers import Suction

class StackingRingsOnPegs(Task):
    """
    Place three different colored cylindrical rings onto a matching colored peg
    that is protruding vertically from a base, ensuring each ring sits flush with the previous one.
    """

    def __init__(self):
        super().__init__()
        self.max_steps = 6  # We have three rings to place, so max_steps is twice the number of rings
        self.lang_template = "place the {color} ring on the {color} peg"
        self.task_completed_desc = "done stacking rings on pegs."
        self.ee = Suction  # We need to move objects on the Z axis, so we use the Suction end-effector
        self.additional_reset()

    def reset(self, env):
        super().reset(env)

        # Define the colors for the rings and pegs
        ring_colors = ['red', 'green', 'blue']
        peg_colors = ring_colors  # Matching colors for pegs

        # Define the size for the rings and pegs
        ring_size = (0.05, 0.05, 0.02)  # (radius, radius, height)
        peg_size = (0.01, 0.01, 0.15)  # (radius, radius, height)

        # Add pegs to the environment
        peg_urdf = 'insertion/fixture.urdf'
        peg_poses = []
        for color in peg_colors:
            peg_pose = self.get_random_pose(env, peg_size)
            peg_color = utils.COLORS[color]
            env.add_object(peg_urdf, peg_pose, 'fixed', color=peg_color)
            peg_poses.append(peg_pose)

        # Add rings to the environment
        ring_urdf = 'cylinder/cylinder-template.urdf'
        rings = []
        for i, color in enumerate(ring_colors):
            ring_pose = self.get_random_pose(env, ring_size)
            ring_color = utils.COLORS[color]
            replace = {'DIM': ring_size, 'COLOR': ring_color}
            urdf = self.fill_template(ring_urdf, replace)
            ring_id = env.add_object(urdf, ring_pose)
            rings.append(ring_id)

            # Define the target pose for each ring, which is the pose of the matching peg
            # The target pose only needs the position, as the orientation is fixed for the rings
            target_pose = [(peg_poses[i][0], peg_poses[i][1])]  # We use the x, y position of the pegs and a fixed z

            # Add the goal for each ring
            language_goal = self.lang_template.format(color=color)
            self.add_goal(objs=[ring_id], matches=np.ones((1, 1)), targ_poses=target_pose, replace=False,
                          rotations=False, metric='pose', params=None, step_max_reward=1/3,
                          language_goal=language_goal)

        # Set the primitive for the task
        self.primitive = primitives.push  # Although we use Suction, we still need to define the primitive